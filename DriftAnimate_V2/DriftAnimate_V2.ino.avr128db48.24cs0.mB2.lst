
C:\Users\Spence\AppData\Local\Temp\arduino_build_761867/DriftAnimate_V2.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	db c3       	rjmp	.+1974   	; 0x7b8 <__ctors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	0c c4       	rjmp	.+2072   	; 0x81e <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	0a c4       	rjmp	.+2068   	; 0x81e <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	08 c4       	rjmp	.+2064   	; 0x81e <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	06 c4       	rjmp	.+2060   	; 0x81e <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	04 c4       	rjmp	.+2056   	; 0x81e <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	02 c4       	rjmp	.+2052   	; 0x81e <__bad_interrupt>
      1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
      1c:	00 c4       	rjmp	.+2048   	; 0x81e <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	fe c3       	rjmp	.+2044   	; 0x81e <__bad_interrupt>
      22:	00 00       	nop
../../../../crt1/gcrt1.S:75
      24:	fc c3       	rjmp	.+2040   	; 0x81e <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	fa c3       	rjmp	.+2036   	; 0x81e <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	f8 c3       	rjmp	.+2032   	; 0x81e <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	f6 c3       	rjmp	.+2028   	; 0x81e <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	f4 c3       	rjmp	.+2024   	; 0x81e <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	f2 c3       	rjmp	.+2020   	; 0x81e <__bad_interrupt>
      3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
      3c:	f0 c3       	rjmp	.+2016   	; 0x81e <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	ee c3       	rjmp	.+2012   	; 0x81e <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	ec c3       	rjmp	.+2008   	; 0x81e <__bad_interrupt>
      46:	00 00       	nop
../../../../crt1/gcrt1.S:84
      48:	ea c3       	rjmp	.+2004   	; 0x81e <__bad_interrupt>
      4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
      4c:	e8 c3       	rjmp	.+2000   	; 0x81e <__bad_interrupt>
      4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
      50:	e6 c3       	rjmp	.+1996   	; 0x81e <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	0c 94 a8 13 	jmp	0x2750	; 0x2750 <__vector_21>
../../../../crt1/gcrt1.S:88
      58:	0c 94 65 13 	jmp	0x26ca	; 0x26ca <__vector_22>
../../../../crt1/gcrt1.S:89
      5c:	0c 94 8f 13 	jmp	0x271e	; 0x271e <__vector_23>
../../../../crt1/gcrt1.S:90
      60:	de c3       	rjmp	.+1980   	; 0x81e <__bad_interrupt>
      62:	00 00       	nop
../../../../crt1/gcrt1.S:91
      64:	dc c3       	rjmp	.+1976   	; 0x81e <__bad_interrupt>
      66:	00 00       	nop
../../../../crt1/gcrt1.S:92
      68:	da c3       	rjmp	.+1972   	; 0x81e <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	d8 c3       	rjmp	.+1968   	; 0x81e <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	d6 c3       	rjmp	.+1964   	; 0x81e <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	d4 c3       	rjmp	.+1960   	; 0x81e <__bad_interrupt>
      76:	00 00       	nop
../../../../crt1/gcrt1.S:96
      78:	0c 94 b4 14 	jmp	0x2968	; 0x2968 <__vector_30>
../../../../crt1/gcrt1.S:97
      7c:	0c 94 d7 13 	jmp	0x27ae	; 0x27ae <__vector_31>
../../../../crt1/gcrt1.S:98
      80:	ce c3       	rjmp	.+1948   	; 0x81e <__bad_interrupt>
      82:	00 00       	nop
../../../../crt1/gcrt1.S:99
      84:	cc c3       	rjmp	.+1944   	; 0x81e <__bad_interrupt>
      86:	00 00       	nop
../../../../crt1/gcrt1.S:100
      88:	ca c3       	rjmp	.+1940   	; 0x81e <__bad_interrupt>
      8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
      8c:	c8 c3       	rjmp	.+1936   	; 0x81e <__bad_interrupt>
      8e:	00 00       	nop
../../../../crt1/gcrt1.S:102
      90:	c6 c3       	rjmp	.+1932   	; 0x81e <__bad_interrupt>
      92:	00 00       	nop
../../../../crt1/gcrt1.S:103
      94:	c4 c3       	rjmp	.+1928   	; 0x81e <__bad_interrupt>
      96:	00 00       	nop
../../../../crt1/gcrt1.S:104
      98:	c2 c3       	rjmp	.+1924   	; 0x81e <__bad_interrupt>
      9a:	00 00       	nop
../../../../crt1/gcrt1.S:105
      9c:	c0 c3       	rjmp	.+1920   	; 0x81e <__bad_interrupt>
      9e:	00 00       	nop
../../../../crt1/gcrt1.S:106
      a0:	be c3       	rjmp	.+1916   	; 0x81e <__bad_interrupt>
      a2:	00 00       	nop
../../../../crt1/gcrt1.S:107
      a4:	bc c3       	rjmp	.+1912   	; 0x81e <__bad_interrupt>
      a6:	00 00       	nop
../../../../crt1/gcrt1.S:108
      a8:	ba c3       	rjmp	.+1908   	; 0x81e <__bad_interrupt>
      aa:	00 00       	nop
../../../../crt1/gcrt1.S:109
      ac:	b8 c3       	rjmp	.+1904   	; 0x81e <__bad_interrupt>
      ae:	00 00       	nop
../../../../crt1/gcrt1.S:110
      b0:	0c 94 ff 13 	jmp	0x27fe	; 0x27fe <__vector_44>
../../../../crt1/gcrt1.S:111
      b4:	b4 c3       	rjmp	.+1896   	; 0x81e <__bad_interrupt>
      b6:	00 00       	nop
../../../../crt1/gcrt1.S:112
      b8:	b2 c3       	rjmp	.+1892   	; 0x81e <__bad_interrupt>
      ba:	00 00       	nop
../../../../crt1/gcrt1.S:113
      bc:	b0 c3       	rjmp	.+1888   	; 0x81e <__bad_interrupt>
      be:	00 00       	nop
../../../../crt1/gcrt1.S:114
      c0:	ae c3       	rjmp	.+1884   	; 0x81e <__bad_interrupt>
      c2:	00 00       	nop
../../../../crt1/gcrt1.S:115
      c4:	ac c3       	rjmp	.+1880   	; 0x81e <__bad_interrupt>
      c6:	00 00       	nop
../../../../crt1/gcrt1.S:116
      c8:	aa c3       	rjmp	.+1876   	; 0x81e <__bad_interrupt>
      ca:	00 00       	nop
../../../../crt1/gcrt1.S:117
      cc:	a8 c3       	rjmp	.+1872   	; 0x81e <__bad_interrupt>
      ce:	00 00       	nop
../../../../crt1/gcrt1.S:118
      d0:	a6 c3       	rjmp	.+1868   	; 0x81e <__bad_interrupt>
      d2:	00 00       	nop
../../../../crt1/gcrt1.S:119
      d4:	a4 c3       	rjmp	.+1864   	; 0x81e <__bad_interrupt>
      d6:	00 00       	nop
../../../../crt1/gcrt1.S:120
      d8:	a2 c3       	rjmp	.+1860   	; 0x81e <__bad_interrupt>
      da:	00 00       	nop
../../../../crt1/gcrt1.S:121
      dc:	a0 c3       	rjmp	.+1856   	; 0x81e <__bad_interrupt>
      de:	00 00       	nop
../../../../crt1/gcrt1.S:122
      e0:	9e c3       	rjmp	.+1852   	; 0x81e <__bad_interrupt>
      e2:	00 00       	nop
../../../../crt1/gcrt1.S:123
      e4:	9c c3       	rjmp	.+1848   	; 0x81e <__bad_interrupt>
      e6:	00 00       	nop
../../../../crt1/gcrt1.S:124
      e8:	9a c3       	rjmp	.+1844   	; 0x81e <__bad_interrupt>
      ea:	00 00       	nop
../../../../crt1/gcrt1.S:125
      ec:	98 c3       	rjmp	.+1840   	; 0x81e <__bad_interrupt>
      ee:	00 00       	nop
../../../../crt1/gcrt1.S:126
      f0:	96 c3       	rjmp	.+1836   	; 0x81e <__bad_interrupt>
	...

000000f4 <__trampolines_end>:
__trampolines_start():
      f4:	20 44       	sbci	r18, 0x40	; 64
      f6:	52 49       	sbci	r21, 0x92	; 146
      f8:	46 54       	subi	r20, 0x46	; 70
      fa:	32 20       	and	r3, r2
	...

000000fd <mode9Name>:
      fd:	20 46 41 44 45 32 20 20 00                           FADE2  .

00000106 <mode8Name>:
     106:	20 44 4f 54 53 32 20 20 00                           DOTS2  .

0000010f <mode7Name>:
     10f:	20 20 57 41 56 45 20 20 00                            WAVE  .

00000118 <mode6Name>:
     118:	20 20 46 41 44 45 20 20 00                            FADE  .

00000121 <mode5Name>:
     121:	20 20 44 4f 54 53 20 20 00                            DOTS  .

0000012a <mode4Name>:
     12a:	20 52 41 49 4e 42 4f 57 00                           RAINBOW.

00000133 <mode3Name>:
     133:	20 50 55 4c 53 45 20 20 00                           PULSE  .

0000013c <mode2Name>:
     13c:	20 43 4f 4d 45 54 53 20 00                           COMETS .

00000145 <mode1Name>:
     145:	44 52 49 46 54 49 4e 47 00                          DRIFTING.

0000014e <mode0Name>:
     14e:	20 53 4f 4c 49 44 20 20 00                           SOLID  .

00000157 <mode7R2>:
     157:	20 44 57 45 4c 4c 20 00                              DWELL .

0000015f <mode4R2>:
     15f:	20 44 49 52 45 43 54 00                              DIRECT.

00000167 <mode5R1>:
     167:	44 45 4e 53 49 54 59 00                             DENSITY.

0000016f <mode2R2>:
     16f:	20 4c 45 4e 47 54 48 00                              LENGTH.

00000177 <mode1R1>:
     177:	20 4e 55 4d 42 45 52 00                              NUMBER.

0000017f <mode1R0>:
     17f:	20 53 50 45 45 44 20 00                              SPEED .

00000187 <pallete10>:
     187:	53 54 41 54 49 43 20 00                             STATIC .

0000018f <pallete9>:
     18f:	50 55 52 50 4c 45 20 00                             PURPLE .

00000197 <pallete8>:
     197:	50 55 4d 50 4b 49 4e 00                             PUMPKIN.

0000019f <pallete7>:
     19f:	4a 55 4e 47 4c 45 20 00                             JUNGLE .

000001a7 <pallete6>:
     1a7:	20 20 46 49 52 45 20 00                               FIRE .

000001af <pallete5>:
     1af:	53 45 58 54 49 4d 45 00                             SEXTIME.

000001b7 <pallete4>:
     1b7:	4c 49 5a 41 52 44 20 00                             LIZARD .

000001bf <pallete3>:
     1bf:	53 55 4e 53 45 54 20 00                             SUNSET .

000001c7 <pallete2>:
     1c7:	20 20 43 4f 4f 4c 20 00                               COOL .

000001cf <pallete1>:
     1cf:	20 20 57 41 52 4d 20 00                               WARM .

000001d7 <pallete0>:
     1d7:	52 41 49 4e 42 4f 57 00                             RAINBOW.

000001df <mode0R0>:
     1df:	20 20 20 20 20 20 20 00                                    .

000001e7 <mode1L5>:
     1e7:	4d 41 58 20 42 4c 55 00                             MAX BLU.

000001ef <mode1L4>:
     1ef:	4d 49 4e 20 42 4c 55 00                             MIN BLU.

000001f7 <mode1L3>:
     1f7:	4d 41 58 20 47 52 4e 00                             MAX GRN.

000001ff <mode1L2>:
     1ff:	4d 49 4e 20 47 52 4e 00                             MIN GRN.

00000207 <mode1L1>:
     207:	4d 41 58 20 52 45 44 00                             MAX RED.

0000020f <mode1L0>:
     20f:	4d 49 4e 20 52 45 44 00                             MIN RED.

00000217 <mode0L2>:
     217:	20 20 42 4c 55 45 20 00                               BLUE .

0000021f <mode0L1>:
     21f:	20 47 52 45 45 4e 20 00                              GREEN .

00000227 <mode0L0>:
     227:	20 20 52 45 44 20 20 00                               RED  .

0000022f <defaultValueRight>:
	...
     237:	05 00 00 00 00 00 00 00 0a 0a 05 00 00 00 00 00     ................
     247:	05 05 00 00 00 00 00 00 05 0a 00 00 00 00 00 00     ................
     257:	05 0a 00 00 00 00 00 00 05 00 00 00 00 00 00 00     ................
     267:	05 14 02 00 00 00 00 00 05 0a 00 00 00 00 00 00     ................
     277:	05 0a 02 00 00 00 00 00 05 0a 02 00 00 00 00 00     ................

00000287 <defaultValueLeft>:
     287:	ff ff ff 00 00 00 00 00 00 1f 00 1f 00 1f 00 00     ................
     297:	00 1f 00 1f 00 1f 00 00 00 1f 00 1f 00 1f 00 00     ................
	...
     2af:	00 1f 00 1f 00 1f 00 00 ff ff ff ff ff ff 00 00     ................
	...

000002df <getModeRatio(unsigned int)::__c>:
     2df:	45 52 52 4f 52 3a 20 72 61 74 69 6f 20 6f 75 74     ERROR: ratio out
     2ef:	20 6f 66 20 72 61 6e 67 65 00                        of range.

000002f9 <leftValues>:
     2f9:	00 01 02 03 04 06 08 0b 0e 12 16 1b 21 27 2e 36     ............!'.6
     309:	3f 49 54 5f 6a 75 80 8b 97 a3 b0 bd cc dc ed ff     ?IT_ju..........

00000319 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)::__c>:
     319:	45 52 52 4f 52 3a 20 72 61 74 69 6f 20 6f 75 74     ERROR: ratio out
     329:	20 6f 66 20 72 61 6e 67 65 00                        of range.

00000333 <colorPallete>:
     333:	ff 00 00 00 ff 00 00 00 ff 00 00 00 00 00 00 00     ................
	...
     34b:	ff 60 20 ff 64 00 f0 80 28 ff 20 00 00 00 00 00     .` .d...(. .....
	...
     363:	ff 00 40 00 40 ff 00 d2 a0 a0 00 a0 00 00 00 00     ..@.@...........
	...
     37b:	ff 50 14 ff 64 00 c4 10 40 a0 00 40 ff 20 00 00     .P..d...@..@. ..
	...
     393:	00 ff 00 00 80 10 00 20 00 40 a0 00 00 00 00 00     ....... .@......
	...
     3ab:	ff 00 10 c4 00 40 ff 10 64 ff 00 40 00 00 00 00     .....@..d..@....
	...
     3c3:	ff 40 00 c4 20 00 dc 40 00 ff 10 00 00 00 00 00     .@.. ..@........
	...
     3db:	00 ff 00 20 ff 00 00 ff 20 20 ff 20 00 00 00 00     ... ....  . ....
	...
     3f3:	ff 40 00 c4 20 00 dc 40 00 20 ff 00 00 00 00 00     .@.. ..@. ......
	...
     40b:	c0 00 60 c4 00 40 ff 10 64 ff 00 40 00 00 00 00     ..`..@..d..@....
	...
     423:	a0 a0 8c e4 e4 c8 80 80 6e 3c 3c 32 00 00 00 00     ........n<<2....
	...

0000043b <maxValueLeft>:
     43b:	1f 1f 1f 00 00 00 00 00 1f 1f 1f 1f 1f 1f 00 00     ................
     44b:	1f 1f 1f 1f 1f 1f 00 00 1f 1f 1f 1f 1f 1f 00 00     ................
	...
     463:	1f 1f 1f 1f 1f 1f 00 00 1f 1f 1f 1f 1f 1f 00 00     ................
     473:	0a 00 00 00 00 00 00 00 0a 00 00 00 00 00 00 00     ................
     483:	0a 00 00 00 00 00 00 00 0a 00 00 00 00 00 00 00     ................

00000493 <__vector_30::enc_states>:
     493:	00 ff 01 00 01 00 00 ff ff 00 00 01 00 01 ff 00     ................

000004a3 <setup::__c>:
     4a3:	4e 6f 74 68 69 6e 67 20 77 6f 72 6b 73 21 00        Nothing works!.

000004b2 <setup::__c>:
     4b2:	57 6f 61 68 20 49 27 6d 20 6f 6e 20 61 20 44 42     Woah I'm on a DB
     4c2:	21 00                                               !.

000004c4 <handleUI()::__c>:
     4c4:	4d 6f 64 65 20 53 61 76 65 64 00                    Mode Saved.

000004cf <handleUI()::__c>:
     4cf:	63 6c 65 61 72 65 64 00                             cleared.

000004d7 <handleUI()::__c>:
     4d7:	53 61 76 65 64 20 6d 6f 64 65 00                    Saved mode.

000004e2 <doAttractLCD()::__c>:
     4e2:	41 44 4a 55 53 54 20 4c 49 47 48 54 49 4e 47 00     ADJUST LIGHTING.

000004f2 <doAttractLCD()::__c>:
     4f2:	54 55 52 4e 20 4d 59 20 4b 4e 4f 42 53 20 3b 29     TURN MY KNOBS ;)
	...

00000503 <doAttractLCD()::__c>:
     503:	55 53 45 20 4b 4e 4f 42 53 26 42 55 54 54 4f 4e     USE KNOBS&BUTTON
	...

00000514 <doAttractLCD()::__c>:
     514:	50 4c 41 59 20 57 49 54 48 20 4d 45 00              PLAY WITH ME.

00000521 <doAttractLCD()::__c>:
     521:	72 65 61 6c 20 70 61 72 74 79 00                    real party.

0000052c <doAttractLCD()::__c>:
     52c:	54 68 69 73 20 69 73 20 6e 6f 74 20 61 00           This is not a.

0000053a <doAttractLCD()::__c>:
     53a:	41 56 52 31 32 38 44 42 34 38 00                    AVR128DB48.

00000545 <doAttractLCD()::__c>:
     545:	4c 69 67 68 74 20 54 65 73 74 20 76 32 2e 31 00     Light Test v2.1.

00000555 <handleLCD()::__c>:
     555:	46 57 44 00                                         FWD.

00000559 <handleLCD()::__c>:
     559:	52 45 56 00                                         REV.

0000055d <modeNames>:
     55d:	4e 01 45 01 3c 01 33 01 2a 01 21 01 18 01 0f 01     N.E.<.3.*.!.....
     56d:	06 01 fd 00 f4 00                                   ......

00000573 <handleLCD()::__c>:
     573:	20 20 20 20 00                                          .

00000578 <maxSetting>:
     578:	02 00 05 00 05 02 05 01 ff 02 05 02 05 00 00 03     ................
     588:	00 02 00 03 00 02                                   ......

0000058e <handleLCD()::__c>:
     58e:	20 20 20 20 00                                          .

00000593 <modesR>:
     593:	df 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     5a3:	7f 01 77 01 00 00 00 00 00 00 00 00 00 00 00 00     ..w.............
     5b3:	7f 01 77 01 6f 01 00 00 00 00 00 00 00 00 00 00     ..w.o...........
     5c3:	7f 01 67 01 00 00 00 00 00 00 00 00 00 00 00 00     ..g.............
     5d3:	7f 01 6f 01 5f 01 00 00 00 00 00 00 00 00 00 00     ..o._...........
     5e3:	7f 01 67 01 5f 01 00 00 00 00 00 00 00 00 00 00     ..g._...........
     5f3:	7f 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     603:	7f 01 6f 01 57 01 5f 01 00 00 00 00 00 00 00 00     ..o.W._.........
     613:	7f 01 67 01 5f 01 00 00 00 00 00 00 00 00 00 00     ..g._...........
     623:	7f 01 6f 01 57 01 5f 01 00 00 00 00 00 00 00 00     ..o.W._.........
     633:	7f 01 6f 01 57 01 00 00 00 00 00 00 00 00 00 00     ..o.W...........

00000643 <palleteNames>:
     643:	d7 01 cf 01 c7 01 bf 01 b7 01 af 01 a7 01 9f 01     ................
     653:	97 01 8f 01 87 01                                   ......

00000659 <modesL>:
     659:	27 02 1f 02 17 02 00 00 00 00 00 00 00 00 00 00     '...............
     669:	0f 02 07 02 ff 01 f7 01 ef 01 e7 01 00 00 00 00     ................
     679:	0f 02 07 02 ff 01 f7 01 ef 01 e7 01 00 00 00 00     ................
     689:	0f 02 07 02 ff 01 f7 01 ef 01 e7 01 00 00 00 00     ................
     699:	df 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     6a9:	0f 02 07 02 ff 01 f7 01 ef 01 e7 01 00 00 00 00     ................
     6b9:	0f 02 ff 01 ef 01 07 02 f7 01 e7 01 00 00 00 00     ................
     6c9:	df 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     6d9:	df 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     6e9:	df 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     6f9:	df 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................

00000709 <pulseBrightnessTable>:
     709:	00 01 02 03 04 05 06 07 08 09 0a 0c 0e 10 12 14     ................
     719:	16 18 1a 1c 1f 22 25 28 2b 2e 31 34 37 3b 3f 43     ....."%(+.147;?C
     729:	47 4b 4f 53 57 5c 61 66 6b 70 75 7a 7f 85 8b 91     GKOSW\afkpuz....
     739:	97 9d a3 a9 af b6 bd c4 cb d2 d9 e0 e7 ef f7 ff     ................

00000749 <colorCount>:
     749:	03 04 04 05 04 04 04 04 04 04 04                    ...........

00000754 <maxValueRight>:
	...
     75c:	0a 00 00 00 00 00 00 00 0a 0a 0a 00 00 00 00 00     ................
     76c:	0a 14 00 00 00 00 00 00 0a 0a 01 00 00 00 00 00     ................
     77c:	0a 0c 01 00 00 00 00 00 0a 00 00 00 00 00 00 00     ................
     78c:	0a 28 14 01 00 00 00 00 0a 0c 01 00 00 00 00 00     .(..............
     79c:	0a 14 14 01 00 00 00 00 0a 14 14 00 00 00 00 00     ................

000007ac <_usart0_pins>:
     7ac:	00 00 02 01 04 06 03 00 03 00                       ..........

000007b6 <__ctors_start>:
__ctors_start():
     7b6:	c4 15       	cp	r28, r4

000007b8 <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
     7b8:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
     7ba:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
     7bc:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
     7be:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
     7c0:	df e7       	ldi	r29, 0x7F	; 127
../../../../crt1/gcrt1.S:237
     7c2:	de bf       	out	0x3e, r29	; 62

000007c4 <_initThreeStuff()>:
init_reset_flags():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:103

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    if (RSTCTRL.RSTFR == 0){
     7c4:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
     7c8:	81 11       	cpse	r24, r1
     7ca:	05 c0       	rjmp	.+10     	; 0x7d6 <__do_copy_data>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:104
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
     7cc:	88 ed       	ldi	r24, 0xD8	; 216
     7ce:	91 e0       	ldi	r25, 0x01	; 1
     7d0:	84 bf       	out	0x34, r24	; 52
     7d2:	90 93 41 00 	sts	0x0041, r25	; 0x800041 <__TEXT_REGION_LENGTH__+0x7e0041>

000007d6 <__do_copy_data>:
__do_copy_data():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2373
     7d6:	11 e4       	ldi	r17, 0x41	; 65
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2374
     7d8:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2375
     7da:	b0 e4       	ldi	r27, 0x40	; 64
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2376
     7dc:	ee e7       	ldi	r30, 0x7E	; 126
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2377
     7de:	f7 e4       	ldi	r31, 0x47	; 71
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2378
     7e0:	00 e0       	ldi	r16, 0x00	; 0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2379
     7e2:	0b bf       	out	0x3b, r16	; 59
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2380
     7e4:	02 c0       	rjmp	.+4      	; 0x7ea <__do_copy_data+0x14>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2382
     7e6:	07 90       	elpm	r0, Z+
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2383
     7e8:	0d 92       	st	X+, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2385
     7ea:	ac 34       	cpi	r26, 0x4C	; 76
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2386
     7ec:	b1 07       	cpc	r27, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2387
     7ee:	d9 f7       	brne	.-10     	; 0x7e6 <__do_copy_data+0x10>

000007f0 <__do_clear_bss>:
__do_clear_bss():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     7f0:	2e e4       	ldi	r18, 0x4E	; 78
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     7f2:	ac e4       	ldi	r26, 0x4C	; 76
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     7f4:	b1 e4       	ldi	r27, 0x41	; 65
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     7f6:	01 c0       	rjmp	.+2      	; 0x7fa <.do_clear_bss_start>

000007f8 <.do_clear_bss_loop>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     7f8:	1d 92       	st	X+, r1

000007fa <.do_clear_bss_start>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     7fa:	ae 33       	cpi	r26, 0x3E	; 62
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     7fc:	b2 07       	cpc	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     7fe:	e1 f7       	brne	.-8      	; 0x7f8 <.do_clear_bss_loop>

00000800 <__do_global_ctors>:
__do_global_ctors():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     800:	13 e0       	ldi	r17, 0x03	; 3
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     802:	cc ed       	ldi	r28, 0xDC	; 220
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     804:	d3 e0       	ldi	r29, 0x03	; 3
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     806:	04 c0       	rjmp	.+8      	; 0x810 <__do_global_ctors+0x10>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     808:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     80a:	fe 01       	movw	r30, r28
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     80c:	0e 94 b0 23 	call	0x4760	; 0x4760 <__tablejump2__>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     810:	cb 3d       	cpi	r28, 0xDB	; 219
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     812:	d1 07       	cpc	r29, r17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     814:	c9 f7       	brne	.-14     	; 0x808 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     816:	0e 94 45 16 	call	0x2c8a	; 0x2c8a <main>
../../../../crt1/gcrt1.S:315
     81a:	0c 94 bd 23 	jmp	0x477a	; 0x477a <_exit>

0000081e <__bad_interrupt>:
__vector_38():
../../../../crt1/gcrt1.S:209
     81e:	f0 cb       	rjmp	.-2080   	; 0x0 <__vectors>

00000820 <Print::print(char)>:
print():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:68
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
     820:	dc 01       	movw	r26, r24
     822:	ed 91       	ld	r30, X+
     824:	fc 91       	ld	r31, X
     826:	01 90       	ld	r0, Z+
     828:	f0 81       	ld	r31, Z
     82a:	e0 2d       	mov	r30, r0
     82c:	09 94       	ijmp

0000082e <Print::print(__FlashStringHelper const*)>:
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:40
  }
  return n;
}

size_t Print::print(const __FlashStringHelper *ifsh)
{
     82e:	ef 92       	push	r14
     830:	ff 92       	push	r15
     832:	0f 93       	push	r16
     834:	1f 93       	push	r17
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
     83a:	8c 01       	movw	r16, r24
     83c:	7b 01       	movw	r14, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:43
#if defined(__AVR__)
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
     83e:	d0 e0       	ldi	r29, 0x00	; 0
     840:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:45
  while (1) {
    unsigned char c = pgm_read_byte(p++);
     842:	f7 01       	movw	r30, r14
     844:	ec 0f       	add	r30, r28
     846:	fd 1f       	adc	r31, r29
     848:	64 91       	lpm	r22, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:46
    if (c == 0) break;
     84a:	66 23       	and	r22, r22
     84c:	61 f0       	breq	.+24     	; 0x866 <Print::print(__FlashStringHelper const*)+0x38>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:47
    if (write(c)) n++;
     84e:	d8 01       	movw	r26, r16
     850:	ed 91       	ld	r30, X+
     852:	fc 91       	ld	r31, X
     854:	01 90       	ld	r0, Z+
     856:	f0 81       	ld	r31, Z
     858:	e0 2d       	mov	r30, r0
     85a:	c8 01       	movw	r24, r16
     85c:	09 95       	icall
     85e:	89 2b       	or	r24, r25
     860:	11 f0       	breq	.+4      	; 0x866 <Print::print(__FlashStringHelper const*)+0x38>
     862:	21 96       	adiw	r28, 0x01	; 1
     864:	ee cf       	rjmp	.-36     	; 0x842 <Print::print(__FlashStringHelper const*)+0x14>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:54
  }
  return n;
#else
  return print(reinterpret_cast<const char *>(ifsh));
#endif
}
     866:	ce 01       	movw	r24, r28
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	1f 91       	pop	r17
     86e:	0f 91       	pop	r16
     870:	ff 90       	pop	r15
     872:	ef 90       	pop	r14
     874:	08 95       	ret

00000876 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:30

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     876:	af 92       	push	r10
     878:	bf 92       	push	r11
     87a:	cf 92       	push	r12
     87c:	df 92       	push	r13
     87e:	ef 92       	push	r14
     880:	ff 92       	push	r15
     882:	0f 93       	push	r16
     884:	1f 93       	push	r17
     886:	cf 93       	push	r28
     888:	df 93       	push	r29
     88a:	6c 01       	movw	r12, r24
     88c:	7b 01       	movw	r14, r22
     88e:	8b 01       	movw	r16, r22
     890:	04 0f       	add	r16, r20
     892:	15 1f       	adc	r17, r21
     894:	eb 01       	movw	r28, r22
     896:	5e 01       	movw	r10, r28
     898:	ae 18       	sub	r10, r14
     89a:	bf 08       	sbc	r11, r15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:32
  size_t n = 0;
  while (size--) {
     89c:	c0 17       	cp	r28, r16
     89e:	d1 07       	cpc	r29, r17
     8a0:	59 f0       	breq	.+22     	; 0x8b8 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:33
    if (write(*buffer++)) n++;
     8a2:	69 91       	ld	r22, Y+
     8a4:	d6 01       	movw	r26, r12
     8a6:	ed 91       	ld	r30, X+
     8a8:	fc 91       	ld	r31, X
     8aa:	01 90       	ld	r0, Z+
     8ac:	f0 81       	ld	r31, Z
     8ae:	e0 2d       	mov	r30, r0
     8b0:	c6 01       	movw	r24, r12
     8b2:	09 95       	icall
     8b4:	89 2b       	or	r24, r25
     8b6:	79 f7       	brne	.-34     	; 0x896 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:37
    else break;
  }
  return n;
}
     8b8:	c5 01       	movw	r24, r10
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	1f 91       	pop	r17
     8c0:	0f 91       	pop	r16
     8c2:	ff 90       	pop	r15
     8c4:	ef 90       	pop	r14
     8c6:	df 90       	pop	r13
     8c8:	cf 90       	pop	r12
     8ca:	bf 90       	pop	r11
     8cc:	af 90       	pop	r10
     8ce:	08 95       	ret

000008d0 <UartClass::availableForWrite()>:
availableForWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:288
int UartClass::availableForWrite(void) {
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     8d0:	fc 01       	movw	r30, r24
     8d2:	55 89       	ldd	r21, Z+21	; 0x15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:289
    tail = _tx_buffer_tail;
     8d4:	46 89       	ldd	r20, Z+22	; 0x16
     8d6:	25 2f       	mov	r18, r21
     8d8:	30 e0       	ldi	r19, 0x00	; 0
     8da:	84 2f       	mov	r24, r20
     8dc:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:292
  }
  if (head >= tail) {
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     8de:	82 1b       	sub	r24, r18
     8e0:	93 0b       	sbc	r25, r19
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:291

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    tail = _tx_buffer_tail;
  }
  if (head >= tail) {
     8e2:	54 17       	cp	r21, r20
     8e4:	10 f0       	brcs	.+4      	; 0x8ea <UartClass::availableForWrite()+0x1a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:292
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     8e6:	cf 96       	adiw	r24, 0x3f	; 63
     8e8:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:294
  }
  return tail - head - 1;
     8ea:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:295
}
     8ec:	08 95       	ret

000008ee <UartClass::read()>:
read():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:272
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}

int UartClass::read(void) {
     8ee:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:274
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     8f0:	93 89       	ldd	r25, Z+19	; 0x13
     8f2:	84 89       	ldd	r24, Z+20	; 0x14
     8f4:	98 17       	cp	r25, r24
     8f6:	61 f0       	breq	.+24     	; 0x910 <UartClass::read()+0x22>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:277
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     8f8:	a4 89       	ldd	r26, Z+20	; 0x14
     8fa:	ae 0f       	add	r26, r30
     8fc:	bf 2f       	mov	r27, r31
     8fe:	b1 1d       	adc	r27, r1
     900:	57 96       	adiw	r26, 0x17	; 23
     902:	8c 91       	ld	r24, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:278
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
     904:	94 89       	ldd	r25, Z+20	; 0x14
     906:	9f 5f       	subi	r25, 0xFF	; 255
     908:	9f 73       	andi	r25, 0x3F	; 63
     90a:	94 8b       	std	Z+20, r25	; 0x14
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:279
    return c;
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:275
}

int UartClass::read(void) {
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     910:	8f ef       	ldi	r24, 0xFF	; 255
     912:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:281
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     914:	08 95       	ret

00000916 <UartClass::peek()>:
peek():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:264

int UartClass::available(void) {
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void) {
     916:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:265
  if (_rx_buffer_head == _rx_buffer_tail) {
     918:	93 89       	ldd	r25, Z+19	; 0x13
     91a:	84 89       	ldd	r24, Z+20	; 0x14
     91c:	98 17       	cp	r25, r24
     91e:	31 f0       	breq	.+12     	; 0x92c <UartClass::peek()+0x16>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:268
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     920:	84 89       	ldd	r24, Z+20	; 0x14
     922:	e8 0f       	add	r30, r24
     924:	f1 1d       	adc	r31, r1
     926:	87 89       	ldd	r24, Z+23	; 0x17
     928:	90 e0       	ldi	r25, 0x00	; 0
     92a:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:266
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
}

int UartClass::peek(void) {
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     92c:	8f ef       	ldi	r24, 0xFF	; 255
     92e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:270
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     930:	08 95       	ret

00000932 <UartClass::available()>:
available():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:260
  // Note: Does not change output pins
  // though the datasheetsays turning the TX module sets it to input.
  _state = 0;
}

int UartClass::available(void) {
     932:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:261
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
     934:	93 89       	ldd	r25, Z+19	; 0x13
     936:	24 89       	ldd	r18, Z+20	; 0x14
     938:	89 2f       	mov	r24, r25
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	80 5c       	subi	r24, 0xC0	; 192
     93e:	9f 4f       	sbci	r25, 0xFF	; 255
     940:	82 1b       	sub	r24, r18
     942:	91 09       	sbc	r25, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:262
}
     944:	8f 73       	andi	r24, 0x3F	; 63
     946:	99 27       	eor	r25, r25
     948:	08 95       	ret

0000094a <UartClass::end()>:
end():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:244
  (*MyUSART).CTRLB = ctrlb;
  _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask);
  SREG=oldSREG;
}

void UartClass::end() {
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	ec 01       	movw	r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:246
  // wait for transmission of outgoing data
  flush();
     950:	e8 81       	ld	r30, Y
     952:	f9 81       	ldd	r31, Y+1	; 0x01
     954:	06 80       	ldd	r0, Z+6	; 0x06
     956:	f7 81       	ldd	r31, Z+7	; 0x07
     958:	e0 2d       	mov	r30, r0
     95a:	09 95       	icall
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:249
  // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
  // TXCIE only used in half duplex
  (*_hwserial_module).CTRLB &= ~(USART_RXEN_bm | USART_TXEN_bm);
     95c:	ec 85       	ldd	r30, Y+12	; 0x0c
     95e:	fd 85       	ldd	r31, Y+13	; 0x0d
     960:	86 81       	ldd	r24, Z+6	; 0x06
     962:	8f 73       	andi	r24, 0x3F	; 63
     964:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:250
  (*_hwserial_module).CTRLA &= ~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
     966:	ec 85       	ldd	r30, Y+12	; 0x0c
     968:	fd 85       	ldd	r31, Y+13	; 0x0d
     96a:	85 81       	ldd	r24, Z+5	; 0x05
     96c:	8f 71       	andi	r24, 0x1F	; 31
     96e:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:251
  (*_hwserial_module).STATUS =  USART_TXCIF_bm; // want to make sure no chanceofthat firing in error.
     970:	ec 85       	ldd	r30, Y+12	; 0x0c
     972:	fd 85       	ldd	r31, Y+13	; 0x0d
     974:	80 e4       	ldi	r24, 0x40	; 64
     976:	84 83       	std	Z+4, r24	; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:253
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
     978:	8c 89       	ldd	r24, Y+20	; 0x14
     97a:	8b 8b       	std	Y+19, r24	; 0x13
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:257

  // Note: Does not change output pins
  // though the datasheetsays turning the TX module sets it to input.
  _state = 0;
     97c:	1a 8a       	std	Y+18, r1	; 0x12
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:258
}
     97e:	df 91       	pop	r29
     980:	cf 91       	pop	r28
     982:	08 95       	ret

00000984 <UartClass::begin(unsigned long, unsigned int)>:
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:178
    _pin_set = 0;
  }
  return false;
}

void UartClass::begin(unsigned long baud, uint16_t options) {
     984:	8f 92       	push	r8
     986:	9f 92       	push	r9
     988:	af 92       	push	r10
     98a:	bf 92       	push	r11
     98c:	ef 92       	push	r14
     98e:	ff 92       	push	r15
     990:	0f 93       	push	r16
     992:	1f 93       	push	r17
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	8c 01       	movw	r16, r24
     99a:	4a 01       	movw	r8, r20
     99c:	5b 01       	movw	r10, r22
     99e:	79 01       	movw	r14, r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:181
  // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
  // without first calling end()
  if (_state & 1) {
     9a0:	dc 01       	movw	r26, r24
     9a2:	52 96       	adiw	r26, 0x12	; 18
     9a4:	8c 91       	ld	r24, X
     9a6:	52 97       	sbiw	r26, 0x12	; 18
     9a8:	80 ff       	sbrs	r24, 0
     9aa:	07 c0       	rjmp	.+14     	; 0x9ba <UartClass::begin(unsigned long, unsigned int)+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:182
    this->end();
     9ac:	ed 91       	ld	r30, X+
     9ae:	fc 91       	ld	r31, X
     9b0:	02 88       	ldd	r0, Z+18	; 0x12
     9b2:	f3 89       	ldd	r31, Z+19	; 0x13
     9b4:	e0 2d       	mov	r30, r0
     9b6:	c8 01       	movw	r24, r16
     9b8:	09 95       	icall
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:193
     if ((options & 0x1004) == 0) {         // or they want SERIAL_5N1. But if they used that constant, a ketbit is set - do we see that?
      ctrlc = (uint8_t SERIAL_8N1);         // If not give them the default that they exoected;
    }
  }
  uint16_t baud_setting = 0;
  uint8_t ctrla = (uint8_t) (options >> 8); // the options high byte...
     9ba:	df 2d       	mov	r29, r15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:194
  uint8_t ctrlb = (~ctrla & 0xC0);          // Top two bits (TXEN RXEN), inverted so they match he sense in the registers.
     9bc:	cf 2d       	mov	r28, r15
     9be:	c0 95       	com	r28
     9c0:	c0 7c       	andi	r28, 0xC0	; 192
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:195
  if (baud > F_CPU / 8) {                    // requested baud too high!
     9c2:	b1 ec       	ldi	r27, 0xC1	; 193
     9c4:	8b 16       	cp	r8, r27
     9c6:	b6 ec       	ldi	r27, 0xC6	; 198
     9c8:	9b 06       	cpc	r9, r27
     9ca:	bd e2       	ldi	r27, 0x2D	; 45
     9cc:	ab 06       	cpc	r10, r27
     9ce:	b1 04       	cpc	r11, r1
     9d0:	08 f4       	brcc	.+2      	; 0x9d4 <UartClass::begin(unsigned long, unsigned int)+0x50>
     9d2:	bc c0       	rjmp	.+376    	; 0xb4c <UartClass::begin(unsigned long, unsigned int)+0x1c8>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:197
    baud_setting = 64;                      // so set to the maximum baud rate setting.
    ctrlb |= USART_RXMODE0_bm;              // set the U2X bit in what will become CTRLB
     9d4:	c2 60       	ori	r28, 0x02	; 2
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:196
  }
  uint16_t baud_setting = 0;
  uint8_t ctrla = (uint8_t) (options >> 8); // the options high byte...
  uint8_t ctrlb = (~ctrla & 0xC0);          // Top two bits (TXEN RXEN), inverted so they match he sense in the registers.
  if (baud > F_CPU / 8) {                    // requested baud too high!
    baud_setting = 64;                      // so set to the maximum baud rate setting.
     9d6:	20 e4       	ldi	r18, 0x40	; 64
     9d8:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:209
    }                                       // Calculate the baud_setting for valid baud rate.
    baud_setting = (((4 * F_CPU) / baud));
  }
  // Baud setting done now we do the other options.
  // that aren't in CTRLC;
  if (ctrla & 0x04) {                       // is ODME option set?
     9da:	d2 fd       	sbrc	r29, 2
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:210
    ctrlb |= USART_ODME_bm;                 // set the big in what will become CTRLB
     9dc:	c8 60       	ori	r28, 0x08	; 8
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:212
  }
  ctrla &= 0x09;                            // Only LBME and RS485; will get written to CTRLA.
     9de:	d9 70       	andi	r29, 0x09	; 9
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:213
  if (ctrlb & USART_RXEN_bm) {              // if RX is to be enabled
     9e0:	c7 fd       	sbrc	r28, 7
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:214
    ctrla  |= USART_RXCIE_bm;               // we will want to enable the ISR.
     9e2:	d0 68       	ori	r29, 0x80	; 128
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:216
  }
  uint8_t setpinmask = ctrlb & 0xC8;        // ODME in bit 3, TX and RX enabled in bit 6, 7
     9e4:	8c 2f       	mov	r24, r28
     9e6:	88 7c       	andi	r24, 0xC8	; 200
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:217
  if ((ctrla & USART_LBME_bm) && ((ctrlb & 0xC0) == 0xC0)) { //if it's half duplex requires special treatment if
     9e8:	d3 ff       	sbrs	r29, 3
     9ea:	0c c0       	rjmp	.+24     	; 0xa04 <UartClass::begin(unsigned long, unsigned int)+0x80>
     9ec:	4c 2f       	mov	r20, r28
     9ee:	40 7c       	andi	r20, 0xC0	; 192
     9f0:	40 3c       	cpi	r20, 0xC0	; 192
     9f2:	41 f4       	brne	.+16     	; 0xa04 <UartClass::begin(unsigned long, unsigned int)+0x80>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:218
    _state      |= 2;                       // since that changes some behavior (RXC disabled while sending)
     9f4:	d8 01       	movw	r26, r16
     9f6:	52 96       	adiw	r26, 0x12	; 18
     9f8:	4c 91       	ld	r20, X
     9fa:	52 97       	sbiw	r26, 0x12	; 18
     9fc:	42 60       	ori	r20, 0x02	; 2
     9fe:	52 96       	adiw	r26, 0x12	; 18
     a00:	4c 93       	st	X, r20
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:219
    setpinmask  |= 0x10;                    // this tells _set_pins not to disturb the configuation on the RX pin.
     a02:	80 61       	ori	r24, 0x10	; 16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:221
  }
  if (ctrla & USART_RS485_bm) {           // RS485 mode recorded here too... because we may need to
     a04:	d0 fd       	sbrc	r29, 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:222
    setpinmask  |= 0x01;                   // set pin output if we need to do that. Datasheet isn't clear
     a06:	81 60       	ori	r24, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:224
  }
  uint8_t oldSREG = SREG;
     a08:	bf b6       	in	r11, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:225
  cli();
     a0a:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:226
  volatile USART_t* MyUSART                = _hwserial_module;
     a0c:	d8 01       	movw	r26, r16
     a0e:	1c 96       	adiw	r26, 0x0c	; 12
     a10:	ed 91       	ld	r30, X+
     a12:	fc 91       	ld	r31, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:227
  (*MyUSART).CTRLA       = ctrla;
     a14:	d5 83       	std	Z+5, r29	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:228
  (*MyUSART).CTRLB       = 0;
     a16:	16 82       	std	Z+6, r1	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:229
  (*MyUSART).CTRLC       = (uint8_t) options;
     a18:	e7 82       	std	Z+7, r14	; 0x07
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:230
  (*MyUSART).BAUD        = baud_setting;
     a1a:	20 87       	std	Z+8, r18	; 0x08
     a1c:	31 87       	std	Z+9, r19	; 0x09
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:232
  // Set USART mode of operation
  if (options & SERIAL_EVENT_RX) {
     a1e:	f5 fe       	sbrs	r15, 5
     a20:	b5 c0       	rjmp	.+362    	; 0xb8c <UartClass::begin(unsigned long, unsigned int)+0x208>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:233
    setpinmask          &= 0x7F; // Remove the RX pin in this case because we get the input from elsewhere.
     a22:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:234
    (*MyUSART).EVCTRL    = 1;    // enable event input - not clear from datasheet what's needed to
     a24:	91 e0       	ldi	r25, 0x01	; 1
     a26:	94 87       	std	Z+12, r25	; 0x0c
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:235
    (*MyUSART).TXPLCTRL  = 0xFF; // Disable pulse length encoding.
     a28:	9f ef       	ldi	r25, 0xFF	; 255
     a2a:	95 87       	std	Z+13, r25	; 0x0d
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:239
  } else {
    (*MyUSART).EVCTRL    = 0;
  }
  (*MyUSART).CTRLB = ctrlb;
     a2c:	c6 83       	std	Z+6, r28	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:240
  _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask);
     a2e:	f8 01       	movw	r30, r16
     a30:	91 89       	ldd	r25, Z+17	; 0x11
     a32:	f0 88       	ldd	r15, Z+16	; 0x10
     a34:	26 85       	ldd	r18, Z+14	; 0x0e
     a36:	37 85       	ldd	r19, Z+15	; 0x0f
_set_pins():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:352
  *portmux       = temp;
#endif
}

void UartClass::_set_pins(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_setting, uint8_t enmask) { // enmask 76 are bits, for ernsablr
  uint8_t* mux_row_ptr   = mux_table_ptr + (mux_setting * USART_PINS_WIDTH);
     a38:	f9 01       	movw	r30, r18
     a3a:	43 e0       	ldi	r20, 0x03	; 3
     a3c:	94 9f       	mul	r25, r20
     a3e:	e0 0d       	add	r30, r0
     a40:	f1 1d       	adc	r31, r1
     a42:	11 24       	eor	r1, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:353
  uint16_t mux_row_gc_tx = pgm_read_word_near(mux_row_ptr); // Clever trick for faster PGM reads of consecutive bytes!
     a44:	65 91       	lpm	r22, Z+
     a46:	74 91       	lpm	r23, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:355
  uint8_t mux_group_code = (uint8_t) (mux_row_gc_tx); // this is the mux
  if (mux_setting < mux_count) {  // if false, pinmux none was selected
     a48:	9f 15       	cp	r25, r15
     a4a:	08 f0       	brcs	.+2      	; 0xa4e <UartClass::begin(unsigned long, unsigned int)+0xca>
     a4c:	60 c0       	rjmp	.+192    	; 0xb0e <UartClass::begin(unsigned long, unsigned int)+0x18a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:356
    uint8_t mux_pin_tx   = (uint8_t) (mux_row_gc_tx >> 8);
     a4e:	97 2f       	mov	r25, r23
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:357
    uint8_t outype = ((enmask & 0x08) ? INPUT_PULLUP : OUTPUT); // If it's ODME, we don't set pins OUTPUT.
     a50:	c2 e0       	ldi	r28, 0x02	; 2
_set_pins():
     a52:	83 ff       	sbrs	r24, 3
begin():
     a54:	c1 e0       	ldi	r28, 0x01	; 1
_set_pins():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:358
    if (enmask & 0x40) {            // If TXEN, set the TX pin
     a56:	86 ff       	sbrs	r24, 6
     a58:	17 c0       	rjmp	.+46     	; 0xa88 <UartClass::begin(unsigned long, unsigned int)+0x104>
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a5a:	99 32       	cpi	r25, 0x29	; 41
     a5c:	a8 f4       	brcc	.+42     	; 0xa88 <UartClass::begin(unsigned long, unsigned int)+0x104>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
     a5e:	47 2f       	mov	r20, r23
     a60:	50 e0       	ldi	r21, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a62:	fa 01       	movw	r30, r20
     a64:	e9 58       	subi	r30, 0x89	; 137
     a66:	ff 4b       	sbci	r31, 0xBF	; 191
     a68:	90 81       	ld	r25, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     a6a:	9f 3f       	cpi	r25, 0xFF	; 255
     a6c:	69 f0       	breq	.+26     	; 0xa88 <UartClass::begin(unsigned long, unsigned int)+0x104>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     a6e:	fa 01       	movw	r30, r20
     a70:	e0 56       	subi	r30, 0x60	; 96
     a72:	ff 4b       	sbci	r31, 0xBF	; 191
     a74:	e0 81       	ld	r30, Z
     a76:	a0 e2       	ldi	r26, 0x20	; 32
     a78:	ea 9f       	mul	r30, r26
     a7a:	f0 01       	movw	r30, r0
     a7c:	11 24       	eor	r1, r1
     a7e:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:227
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
     a80:	c1 30       	cpi	r28, 0x01	; 1
     a82:	09 f0       	breq	.+2      	; 0xa86 <UartClass::begin(unsigned long, unsigned int)+0x102>
     a84:	85 c0       	rjmp	.+266    	; 0xb90 <UartClass::begin(unsigned long, unsigned int)+0x20c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
     a86:	91 83       	std	Z+1, r25	; 0x01
_set_pins():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:361
      pinMode(mux_pin_tx, outype);  // to above-determined vbalue.
    }
    if (enmask & 0x80) {            // If RXEN, a bit more complicated...
     a88:	87 ff       	sbrs	r24, 7
     a8a:	2a c0       	rjmp	.+84     	; 0xae0 <UartClass::begin(unsigned long, unsigned int)+0x15c>
     a8c:	91 e0       	ldi	r25, 0x01	; 1
     a8e:	97 0f       	add	r25, r23
     a90:	49 2f       	mov	r20, r25
     a92:	50 e0       	ldi	r21, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     a94:	99 32       	cpi	r25, 0x29	; 41
     a96:	20 f5       	brcc	.+72     	; 0xae0 <UartClass::begin(unsigned long, unsigned int)+0x15c>
     a98:	fa 01       	movw	r30, r20
     a9a:	e9 58       	subi	r30, 0x89	; 137
     a9c:	ff 4b       	sbci	r31, 0xBF	; 191
     a9e:	90 81       	ld	r25, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     aa0:	9f 3f       	cpi	r25, 0xFF	; 255
     aa2:	f1 f0       	breq	.+60     	; 0xae0 <UartClass::begin(unsigned long, unsigned int)+0x15c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     aa4:	fa 01       	movw	r30, r20
     aa6:	e0 56       	subi	r30, 0x60	; 96
     aa8:	ff 4b       	sbci	r31, 0xBF	; 191
     aaa:	e0 81       	ld	r30, Z
     aac:	b0 e2       	ldi	r27, 0x20	; 32
     aae:	eb 9f       	mul	r30, r27
     ab0:	f0 01       	movw	r30, r0
     ab2:	11 24       	eor	r1, r1
     ab4:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     ab6:	4c 5c       	subi	r20, 0xCC	; 204
     ab8:	5f 4b       	sbci	r21, 0xBF	; 191
     aba:	da 01       	movw	r26, r20
     abc:	cc 91       	ld	r28, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
     abe:	cf 3f       	cpi	r28, 0xFF	; 255
     ac0:	09 f4       	brne	.+2      	; 0xac4 <UartClass::begin(unsigned long, unsigned int)+0x140>
     ac2:	80 c0       	rjmp	.+256    	; 0xbc4 <UartClass::begin(unsigned long, unsigned int)+0x240>
     ac4:	af 01       	movw	r20, r30
     ac6:	40 5f       	subi	r20, 0xF0	; 240
     ac8:	5f 4f       	sbci	r21, 0xFF	; 255
     aca:	c4 0f       	add	r28, r20
     acc:	d5 2f       	mov	r29, r21
     ace:	d1 1d       	adc	r29, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
     ad0:	5f b7       	in	r21, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
     ad2:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
     ad4:	92 83       	std	Z+2, r25	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
     ad6:	48 81       	ld	r20, Y
     ad8:	48 60       	ori	r20, 0x08	; 8
     ada:	48 83       	st	Y, r20
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
     adc:	95 83       	std	Z+5, r25	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
     ade:	5f bf       	out	0x3f, r21	; 63
_set_pins():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:368
        pinMode(mux_pin_tx + 1, INPUT_PULLUP);
    } else {
        pinMode(mux_pin_tx + 1, INPUT_PULLUP);
      }
    }
    if (enmask & 1) {
     ae0:	80 ff       	sbrs	r24, 0
     ae2:	15 c0       	rjmp	.+42     	; 0xb0e <UartClass::begin(unsigned long, unsigned int)+0x18a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:369
      pinMode(mux_pin_tx + 3, OUTPUT); // in RS485 mode we need to make sure that XDIR is an output
     ae4:	83 e0       	ldi	r24, 0x03	; 3
     ae6:	87 0f       	add	r24, r23
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     ae8:	89 32       	cpi	r24, 0x29	; 41
     aea:	88 f4       	brcc	.+34     	; 0xb0e <UartClass::begin(unsigned long, unsigned int)+0x18a>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
     aec:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
     aee:	fc 01       	movw	r30, r24
     af0:	e9 58       	subi	r30, 0x89	; 137
     af2:	ff 4b       	sbci	r31, 0xBF	; 191
     af4:	40 81       	ld	r20, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
     af6:	4f 3f       	cpi	r20, 0xFF	; 255
     af8:	51 f0       	breq	.+20     	; 0xb0e <UartClass::begin(unsigned long, unsigned int)+0x18a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
     afa:	80 56       	subi	r24, 0x60	; 96
     afc:	9f 4b       	sbci	r25, 0xBF	; 191
     afe:	dc 01       	movw	r26, r24
     b00:	ec 91       	ld	r30, X
     b02:	b0 e2       	ldi	r27, 0x20	; 32
     b04:	eb 9f       	mul	r30, r27
     b06:	f0 01       	movw	r30, r0
     b08:	11 24       	eor	r1, r1
     b0a:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
     b0c:	41 83       	std	Z+1, r20	; 0x01
_mux_set():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:330



void UartClass::_mux_set(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_code) {
#if HWSERIAL_MUX_REG_COUNT > 1  // for big pincount devices that have more then one USART PORTMUX register
  uint8_t* mux_info_ptr = mux_table_ptr + (mux_count * USART_PINS_WIDTH) + 1;
     b0e:	f9 01       	movw	r30, r18
     b10:	43 e0       	ldi	r20, 0x03	; 3
     b12:	f4 9e       	mul	r15, r20
     b14:	e0 0d       	add	r30, r0
     b16:	f1 1d       	adc	r31, r1
     b18:	11 24       	eor	r1, r1
     b1a:	31 96       	adiw	r30, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:331
  uint16_t mux_options_off_gm = pgm_read_word_near(mux_info_ptr);  /* pointer offset to the second columun
     b1c:	25 91       	lpm	r18, Z+
     b1e:	34 91       	lpm	r19, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:334
  at the end bottom row of the table, with info about the mux options, rather than a specefic option
  Low byte is the offset from USARTROUTEA, second byte is the group mask. */
  volatile uint8_t* portmux  = (uint8_t*)(HWSERIAL_MUX_REGISTER_BASE + (uint8_t)mux_options_off_gm); //offset
     b20:	f9 01       	movw	r30, r18
     b22:	ff 27       	eor	r31, r31
     b24:	ee 51       	subi	r30, 0x1E	; 30
     b26:	fa 4f       	sbci	r31, 0xFA	; 250
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:335
  uint8_t temp   = *portmux;
     b28:	90 81       	ld	r25, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:336
  temp          &= ~((uint8_t) (mux_options_off_gm >> 8)); //Group Mask
     b2a:	83 2f       	mov	r24, r19
     b2c:	80 95       	com	r24
     b2e:	89 23       	and	r24, r25
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:337
  temp          |= mux_code;
     b30:	68 2b       	or	r22, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:338
  *portmux       = temp;
     b32:	60 83       	st	Z, r22
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:241
  } else {
    (*MyUSART).EVCTRL    = 0;
  }
  (*MyUSART).CTRLB = ctrlb;
  _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask);
  SREG=oldSREG;
     b34:	bf be       	out	0x3f, r11	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:242
}
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	bf 90       	pop	r11
     b44:	af 90       	pop	r10
     b46:	9f 90       	pop	r9
     b48:	8f 90       	pop	r8
     b4a:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:199
  uint8_t ctrlb = (~ctrla & 0xC0);          // Top two bits (TXEN RXEN), inverted so they match he sense in the registers.
  if (baud > F_CPU / 8) {                    // requested baud too high!
    baud_setting = 64;                      // so set to the maximum baud rate setting.
    ctrlb |= USART_RXMODE0_bm;              // set the U2X bit in what will become CTRLB
  } else if (baud < (F_CPU / 16800)) {      // Baud rate is too low
    baud_setting = 65535;                   // minimum baud rate.
     b4c:	2f ef       	ldi	r18, 0xFF	; 255
     b4e:	3f ef       	ldi	r19, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:198
  uint8_t ctrla = (uint8_t) (options >> 8); // the options high byte...
  uint8_t ctrlb = (~ctrla & 0xC0);          // Top two bits (TXEN RXEN), inverted so they match he sense in the registers.
  if (baud > F_CPU / 8) {                    // requested baud too high!
    baud_setting = 64;                      // so set to the maximum baud rate setting.
    ctrlb |= USART_RXMODE0_bm;              // set the U2X bit in what will become CTRLB
  } else if (baud < (F_CPU / 16800)) {      // Baud rate is too low
     b50:	e4 e9       	ldi	r30, 0x94	; 148
     b52:	8e 16       	cp	r8, r30
     b54:	e5 e0       	ldi	r30, 0x05	; 5
     b56:	9e 06       	cpc	r9, r30
     b58:	a1 04       	cpc	r10, r1
     b5a:	b1 04       	cpc	r11, r1
     b5c:	08 f4       	brcc	.+2      	; 0xb60 <UartClass::begin(unsigned long, unsigned int)+0x1dc>
     b5e:	3d cf       	rjmp	.-390    	; 0x9da <UartClass::begin(unsigned long, unsigned int)+0x56>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:201
    baud_setting = 65535;                   // minimum baud rate.
  } else {
    if (baud > F_CPU / 16) {                // if this baud is too fast for non-U2X
     b60:	f1 e6       	ldi	r31, 0x61	; 97
     b62:	8f 16       	cp	r8, r31
     b64:	f3 ee       	ldi	r31, 0xE3	; 227
     b66:	9f 06       	cpc	r9, r31
     b68:	f6 e1       	ldi	r31, 0x16	; 22
     b6a:	af 06       	cpc	r10, r31
     b6c:	b1 04       	cpc	r11, r1
     b6e:	28 f0       	brcs	.+10     	; 0xb7a <UartClass::begin(unsigned long, unsigned int)+0x1f6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:202
      ctrlb |= USART_RXMODE0_bm;            // set the U2X bit in what will become CTRLB
     b70:	c2 60       	ori	r28, 0x02	; 2
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:203
      baud >>= 1;                           // And lower the baud rate by haldf
     b72:	b6 94       	lsr	r11
     b74:	a7 94       	ror	r10
     b76:	97 94       	ror	r9
     b78:	87 94       	ror	r8
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:205
    }                                       // Calculate the baud_setting for valid baud rate.
    baud_setting = (((4 * F_CPU) / baud));
     b7a:	60 e0       	ldi	r22, 0x00	; 0
     b7c:	78 ed       	ldi	r23, 0xD8	; 216
     b7e:	88 eb       	ldi	r24, 0xB8	; 184
     b80:	95 e0       	ldi	r25, 0x05	; 5
     b82:	a5 01       	movw	r20, r10
     b84:	94 01       	movw	r18, r8
     b86:	0e 94 42 21 	call	0x4284	; 0x4284 <__udivmodsi4>
     b8a:	27 cf       	rjmp	.-434    	; 0x9da <UartClass::begin(unsigned long, unsigned int)+0x56>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:237
  if (options & SERIAL_EVENT_RX) {
    setpinmask          &= 0x7F; // Remove the RX pin in this case because we get the input from elsewhere.
    (*MyUSART).EVCTRL    = 1;    // enable event input - not clear from datasheet what's needed to
    (*MyUSART).TXPLCTRL  = 0xFF; // Disable pulse length encoding.
  } else {
    (*MyUSART).EVCTRL    = 0;
     b8c:	14 86       	std	Z+12, r1	; 0x0c
     b8e:	4e cf       	rjmp	.-356    	; 0xa2c <UartClass::begin(unsigned long, unsigned int)+0xa8>
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
     b90:	4c 5c       	subi	r20, 0xCC	; 204
     b92:	5f 4b       	sbci	r21, 0xBF	; 191
     b94:	da 01       	movw	r26, r20
     b96:	cc 91       	ld	r28, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
     b98:	30 97       	sbiw	r30, 0x00	; 0
     b9a:	89 f0       	breq	.+34     	; 0xbbe <UartClass::begin(unsigned long, unsigned int)+0x23a>
     b9c:	cf 3f       	cpi	r28, 0xFF	; 255
     b9e:	79 f0       	breq	.+30     	; 0xbbe <UartClass::begin(unsigned long, unsigned int)+0x23a>
     ba0:	af 01       	movw	r20, r30
     ba2:	40 5f       	subi	r20, 0xF0	; 240
     ba4:	5f 4f       	sbci	r21, 0xFF	; 255
     ba6:	c4 0f       	add	r28, r20
     ba8:	d5 2f       	mov	r29, r21
     baa:	d1 1d       	adc	r29, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
     bac:	5f b7       	in	r21, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
     bae:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
     bb0:	92 83       	std	Z+2, r25	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
     bb2:	48 81       	ld	r20, Y
     bb4:	48 60       	ori	r20, 0x08	; 8
     bb6:	48 83       	st	Y, r20
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
     bb8:	95 83       	std	Z+5, r25	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
     bba:	5f bf       	out	0x3f, r21	; 63
     bbc:	65 cf       	rjmp	.-310    	; 0xa88 <UartClass::begin(unsigned long, unsigned int)+0x104>
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
     bbe:	d0 e0       	ldi	r29, 0x00	; 0
     bc0:	c0 e0       	ldi	r28, 0x00	; 0
     bc2:	f4 cf       	rjmp	.-24     	; 0xbac <UartClass::begin(unsigned long, unsigned int)+0x228>
     bc4:	d0 e0       	ldi	r29, 0x00	; 0
     bc6:	c0 e0       	ldi	r28, 0x00	; 0
     bc8:	83 cf       	rjmp	.-250    	; 0xad0 <UartClass::begin(unsigned long, unsigned int)+0x14c>

00000bca <UartClass::_tx_data_empty_irq(UartClass&)>:
_tx_data_empty_irq():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:80
    }
  }
}


void UartClass::_tx_data_empty_irq(UartClass& uartClass) {
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:81
  USART_t* usartModule = (USART_t*)uartClass._hwserial_module;  // reduces size a little bit
     bd0:	a4 85       	ldd	r26, Z+12	; 0x0c
     bd2:	b5 85       	ldd	r27, Z+13	; 0x0d
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:82
  tx_buffer_index_t txTail = uartClass._tx_buffer_tail;
     bd4:	26 89       	ldd	r18, Z+22	; 0x16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:94
  } //moved to poll function to make ISR smaller and faster
*/

  // There must be more data in the output
  // buffer. Send the next byte
  uint8_t c = uartClass._tx_buffer[txTail];
     bd6:	ec 01       	movw	r28, r24
     bd8:	c2 0f       	add	r28, r18
     bda:	d1 1d       	adc	r29, r1
     bdc:	c9 5a       	subi	r28, 0xA9	; 169
     bde:	df 4f       	sbci	r29, 0xFF	; 255
     be0:	88 81       	ld	r24, Y
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:99

  // clear the TXCIF flag -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written. It is critical to do this BEFORE we write the next byte
  usartModule->STATUS = USART_TXCIF_bm;
     be2:	90 e4       	ldi	r25, 0x40	; 64
     be4:	14 96       	adiw	r26, 0x04	; 4
     be6:	9c 93       	st	X, r25
     be8:	14 97       	sbiw	r26, 0x04	; 4
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:100
  usartModule->TXDATAL = c;
     bea:	12 96       	adiw	r26, 0x02	; 2
     bec:	8c 93       	st	X, r24
     bee:	12 97       	sbiw	r26, 0x02	; 2
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:102

  txTail = (txTail + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  //% SERIAL_TX_BUFFER_SIZE;
     bf0:	2f 5f       	subi	r18, 0xFF	; 255
     bf2:	2f 73       	andi	r18, 0x3F	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:103
  uint8_t ctrla = usartModule->CTRLA;
     bf4:	15 96       	adiw	r26, 0x05	; 5
     bf6:	9c 91       	ld	r25, X
     bf8:	15 97       	sbiw	r26, 0x05	; 5
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:104
  if (uartClass._tx_buffer_head == txTail) {
     bfa:	35 89       	ldd	r19, Z+21	; 0x15
     bfc:	82 89       	ldd	r24, Z+18	; 0x12
     bfe:	32 13       	cpse	r19, r18
     c00:	09 c0       	rjmp	.+18     	; 0xc14 <UartClass::_tx_data_empty_irq(UartClass&)+0x4a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:106
    // Buffer empty, so disable "data register empty" interrupt
    ctrla &= ~(USART_DREIE_bm);
     c02:	9f 7d       	andi	r25, 0xDF	; 223
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:107
    if (uartClass._state & 2) {
     c04:	81 fd       	sbrc	r24, 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:108
      ctrla |= USART_TXCIE_bm; //in half duplex, turn on TXC interrupt, which will reenable RX int.
     c06:	90 64       	ori	r25, 0x40	; 64
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:113
    }
    usartModule->CTRLA = ctrla;
  } else if (uartClass._state & 2) {
    ctrla &= ~USART_TXCIE_bm;
    usartModule->CTRLA = ctrla;
     c08:	15 96       	adiw	r26, 0x05	; 5
     c0a:	9c 93       	st	X, r25
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:115
  }
  uartClass._tx_buffer_tail = txTail;
     c0c:	26 8b       	std	Z+22, r18	; 0x16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:116
}
     c0e:	df 91       	pop	r29
     c10:	cf 91       	pop	r28
     c12:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:111
    ctrla &= ~(USART_DREIE_bm);
    if (uartClass._state & 2) {
      ctrla |= USART_TXCIE_bm; //in half duplex, turn on TXC interrupt, which will reenable RX int.
    }
    usartModule->CTRLA = ctrla;
  } else if (uartClass._state & 2) {
     c14:	81 ff       	sbrs	r24, 1
     c16:	fa cf       	rjmp	.-12     	; 0xc0c <UartClass::_tx_data_empty_irq(UartClass&)+0x42>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:112
    ctrla &= ~USART_TXCIE_bm;
     c18:	9f 7b       	andi	r25, 0xBF	; 191
     c1a:	f6 cf       	rjmp	.-20     	; 0xc08 <UartClass::_tx_data_empty_irq(UartClass&)+0x3e>

00000c1c <UartClass::_poll_tx_data_empty()>:
_poll_tx_data_empty():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:121
}


// To invoke data empty "interrupt" via a call, use this method
void UartClass::_poll_tx_data_empty(void) {
  if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
     c1c:	0f b6       	in	r0, 0x3f	; 63
     c1e:	07 fe       	sbrs	r0, 7
     c20:	04 c0       	rjmp	.+8      	; 0xc2a <UartClass::_poll_tx_data_empty()+0xe>
     c22:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x7e0111>
     c26:	22 23       	and	r18, r18
     c28:	a1 f0       	breq	.+40     	; 0xc52 <UartClass::_poll_tx_data_empty()+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:138
    // so we'll have to poll the "data register empty" flag ourselves.
    // If it is set, pretend an interrupt has happened and call the handler
    // to free up space for us.
    // -Spence 10/23/20
    // Invoke interrupt handler only if conditions data register is empty
    if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     c2a:	dc 01       	movw	r26, r24
     c2c:	1c 96       	adiw	r26, 0x0c	; 12
     c2e:	ed 91       	ld	r30, X+
     c30:	fc 91       	ld	r31, X
     c32:	1d 97       	sbiw	r26, 0x0d	; 13
     c34:	24 81       	ldd	r18, Z+4	; 0x04
     c36:	25 ff       	sbrs	r18, 5
     c38:	0c c0       	rjmp	.+24     	; 0xc52 <UartClass::_poll_tx_data_empty()+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:139
      if (_tx_buffer_head != _tx_buffer_tail) {
     c3a:	55 96       	adiw	r26, 0x15	; 21
     c3c:	3c 91       	ld	r19, X
     c3e:	55 97       	sbiw	r26, 0x15	; 21
     c40:	56 96       	adiw	r26, 0x16	; 22
     c42:	2c 91       	ld	r18, X
     c44:	32 17       	cp	r19, r18
     c46:	21 f0       	breq	.+8      	; 0xc50 <UartClass::_poll_tx_data_empty()+0x34>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:141
        // Buffer empty, so disable "data register empty" interrupt
        (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     c48:	85 81       	ldd	r24, Z+5	; 0x05
     c4a:	8f 7d       	andi	r24, 0xDF	; 223
     c4c:	85 83       	std	Z+5, r24	; 0x05
     c4e:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:145

        return;
      }
      _tx_data_empty_irq(*this);
     c50:	bc cf       	rjmp	.-136    	; 0xbca <UartClass::_tx_data_empty_irq(UartClass&)>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:151
    }
  }
  // In case interrupts are enabled, the interrupt routine will be invoked by itself
  // Note that this currently does not handle cases where the DRE interruopt becomes
  // disabled, yet you are actually attempting to send. I don't think it can happen.
}
     c52:	08 95       	ret

00000c54 <UartClass::write(unsigned char)>:
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:398
  }
}



size_t UartClass::write(uint8_t c) {
     c54:	0f 93       	push	r16
     c56:	1f 93       	push	r17
     c58:	cf 93       	push	r28
     c5a:	df 93       	push	r29
     c5c:	ec 01       	movw	r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:399
  _state |= 1;
     c5e:	8a 89       	ldd	r24, Y+18	; 0x12
     c60:	98 2f       	mov	r25, r24
     c62:	91 60       	ori	r25, 0x01	; 1
     c64:	9a 8b       	std	Y+18, r25	; 0x12
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:405

  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective data rate at high (>
  // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
  if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     c66:	2d 89       	ldd	r18, Y+21	; 0x15
     c68:	9e 89       	ldd	r25, Y+22	; 0x16
     c6a:	29 13       	cpse	r18, r25
     c6c:	0a c0       	rjmp	.+20     	; 0xc82 <UartClass::write(unsigned char)+0x2e>
     c6e:	ec 85       	ldd	r30, Y+12	; 0x0c
     c70:	fd 85       	ldd	r31, Y+13	; 0x0d
     c72:	94 81       	ldd	r25, Z+4	; 0x04
     c74:	95 ff       	sbrs	r25, 5
     c76:	05 c0       	rjmp	.+10     	; 0xc82 <UartClass::write(unsigned char)+0x2e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:406
    if (_state & 2) { //in half duplex mode, we turn off RXC interrupt
     c78:	81 fd       	sbrc	r24, 1
     c7a:	0d c0       	rjmp	.+26     	; 0xc96 <UartClass::write(unsigned char)+0x42>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:413
      ctrla &= ~USART_RXCIE_bm;
      ctrla |= USART_TXCIE_bm;
      (*_hwserial_module).STATUS = USART_TXCIF_bm;
      (*_hwserial_module).CTRLA = ctrla;
    } else {
      (*_hwserial_module).STATUS = USART_TXCIF_bm;
     c7c:	80 e4       	ldi	r24, 0x40	; 64
     c7e:	84 83       	std	Z+4, r24	; 0x04
     c80:	12 c0       	rjmp	.+36     	; 0xca6 <UartClass::write(unsigned char)+0x52>
     c82:	06 2f       	mov	r16, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:435
*/

    return 1;
  }

  tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
     c84:	1d 89       	ldd	r17, Y+21	; 0x15
     c86:	1f 5f       	subi	r17, 0xFF	; 255
     c88:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:439

  // If the output buffer is full, there's nothing for it other than to
  // wait for the interrupt handler to empty it a bit (or emulate interrupts)
  while (i == _tx_buffer_tail) {
     c8a:	8e 89       	ldd	r24, Y+22	; 0x16
     c8c:	81 13       	cpse	r24, r17
     c8e:	15 c0       	rjmp	.+42     	; 0xcba <UartClass::write(unsigned char)+0x66>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:440
    _poll_tx_data_empty();
     c90:	ce 01       	movw	r24, r28
     c92:	c4 df       	rcall	.-120    	; 0xc1c <UartClass::_poll_tx_data_empty()>
     c94:	fa cf       	rjmp	.-12     	; 0xc8a <UartClass::write(unsigned char)+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:407
  // to the data register and be done. This shortcut helps
  // significantly improve the effective data rate at high (>
  // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
  if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
    if (_state & 2) { //in half duplex mode, we turn off RXC interrupt
      uint8_t ctrla = (*_hwserial_module).CTRLA;
     c96:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:408
      ctrla &= ~USART_RXCIE_bm;
     c98:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:409
      ctrla |= USART_TXCIE_bm;
     c9a:	80 64       	ori	r24, 0x40	; 64
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:410
      (*_hwserial_module).STATUS = USART_TXCIF_bm;
     c9c:	90 e4       	ldi	r25, 0x40	; 64
     c9e:	94 83       	std	Z+4, r25	; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:411
      (*_hwserial_module).CTRLA = ctrla;
     ca0:	ec 85       	ldd	r30, Y+12	; 0x0c
     ca2:	fd 85       	ldd	r31, Y+13	; 0x0d
     ca4:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:416
    } else {
      (*_hwserial_module).STATUS = USART_TXCIF_bm;
    }
    // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
    (*_hwserial_module).TXDATAL = c;
     ca6:	ec 85       	ldd	r30, Y+12	; 0x0c
     ca8:	fd 85       	ldd	r31, Y+13	; 0x0d
     caa:	62 83       	std	Z+2, r22	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:456
    // Enable "data register empty interrupt"
    (*_hwserial_module).CTRLA |= USART_DREIE_bm;
  }

  return 1;
}
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	90 e0       	ldi	r25, 0x00	; 0
     cb0:	df 91       	pop	r29
     cb2:	cf 91       	pop	r28
     cb4:	1f 91       	pop	r17
     cb6:	0f 91       	pop	r16
     cb8:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:442
  // If the output buffer is full, there's nothing for it other than to
  // wait for the interrupt handler to empty it a bit (or emulate interrupts)
  while (i == _tx_buffer_tail) {
    _poll_tx_data_empty();
  }
  _tx_buffer[_tx_buffer_head] = c;
     cba:	ed 89       	ldd	r30, Y+21	; 0x15
     cbc:	ec 0f       	add	r30, r28
     cbe:	fd 2f       	mov	r31, r29
     cc0:	f1 1d       	adc	r31, r1
     cc2:	e9 5a       	subi	r30, 0xA9	; 169
     cc4:	ff 4f       	sbci	r31, 0xFF	; 255
     cc6:	00 83       	st	Z, r16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:443
  _tx_buffer_head = i;
     cc8:	1d 8b       	std	Y+21, r17	; 0x15
     cca:	ec 85       	ldd	r30, Y+12	; 0x0c
     ccc:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:444
  if (_state & 2) { //in half duplex mode, we turn off RXC interrupt
     cce:	8a 89       	ldd	r24, Y+18	; 0x12
     cd0:	81 ff       	sbrs	r24, 1
     cd2:	09 c0       	rjmp	.+18     	; 0xce6 <UartClass::write(unsigned char)+0x92>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:445
    uint8_t ctrla = (*_hwserial_module).CTRLA;
     cd4:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:446
    ctrla &= ~USART_RXCIE_bm;
     cd6:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:447
    ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
     cd8:	80 66       	ori	r24, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:448
    (*_hwserial_module).STATUS = USART_TXCIF_bm;
     cda:	90 e4       	ldi	r25, 0x40	; 64
     cdc:	94 83       	std	Z+4, r25	; 0x04
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:449
    (*_hwserial_module).CTRLA = ctrla;
     cde:	ec 85       	ldd	r30, Y+12	; 0x0c
     ce0:	fd 85       	ldd	r31, Y+13	; 0x0d
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:452
  } else {
    // Enable "data register empty interrupt"
    (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     ce2:	85 83       	std	Z+5, r24	; 0x05
     ce4:	e3 cf       	rjmp	.-58     	; 0xcac <UartClass::write(unsigned char)+0x58>
     ce6:	85 81       	ldd	r24, Z+5	; 0x05
     ce8:	80 62       	ori	r24, 0x20	; 32
     cea:	fb cf       	rjmp	.-10     	; 0xce2 <UartClass::write(unsigned char)+0x8e>

00000cec <UartClass::flush()>:
flush():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:297
    return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  }
  return tail - head - 1;
}

void UartClass::flush() {
     cec:	cf 93       	push	r28
     cee:	df 93       	push	r29
     cf0:	ec 01       	movw	r28, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:301
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXCIF (transmit
  // complete) bit to 1 during initialization
  if (!(_state & 1)) {
     cf2:	8a 89       	ldd	r24, Y+18	; 0x12
     cf4:	80 ff       	sbrs	r24, 0
     cf6:	0b c0       	rjmp	.+22     	; 0xd0e <UartClass::flush()+0x22>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:317
  // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
  // and in that case flush(), and write() with full buffer would just straight up hang...


  // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
  while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     cf8:	ec 85       	ldd	r30, Y+12	; 0x0c
     cfa:	fd 85       	ldd	r31, Y+13	; 0x0d
     cfc:	85 81       	ldd	r24, Z+5	; 0x05
     cfe:	85 fd       	sbrc	r24, 5
     d00:	03 c0       	rjmp	.+6      	; 0xd08 <UartClass::flush()+0x1c>
     d02:	84 81       	ldd	r24, Z+4	; 0x04
     d04:	86 fd       	sbrc	r24, 6
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:319
    // poll this, which will ensure that bytes keep getting sent even if interrupts are disabled or something.
    _poll_tx_data_empty();
     d06:	03 c0       	rjmp	.+6      	; 0xd0e <UartClass::flush()+0x22>
     d08:	ce 01       	movw	r24, r28
     d0a:	88 df       	rcall	.-240    	; 0xc1c <UartClass::_poll_tx_data_empty()>
     d0c:	f5 cf       	rjmp	.-22     	; 0xcf8 <UartClass::flush()+0xc>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:323
  }
  // When we get here, nothing is queued anymore (DREIE is disabled) and
  // the hardware finished transmission (TXCIF is set).
}
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	08 95       	ret

00000d14 <UartClass::operator bool()>:
operator 3():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.h:130
    inline size_t write(unsigned long n) {return write((uint8_t)n);}
    inline size_t write(long n)          {return write((uint8_t)n);}
    inline size_t write(unsigned int n)  {return write((uint8_t)n);}
    inline size_t write(int n)           {return write((uint8_t)n);}
    using Print::write;   // pull in write(str) and write(buf, size) from Print
    explicit operator bool() {return true;}
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	08 95       	ret

00000d18 <micros>:
micros():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:211
      #else
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
     d18:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:212
      cli();
     d1a:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:227
        TCD0.CTRLE = TCD_SCAPTUREA_bm;
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); //wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
      #else
        ticks = _timer->CNT;
     d1c:	e0 91 2a 0b 	lds	r30, 0x0B2A	; 0x800b2a <__TEXT_REGION_LENGTH__+0x7e0b2a>
     d20:	f0 91 2b 0b 	lds	r31, 0x0B2B	; 0x800b2b <__TEXT_REGION_LENGTH__+0x7e0b2b>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:228
        flags = _timer->INTFLAGS;
     d24:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:239
       * Next, get the current number of overflows
       */
      #if defined(MILLIS_USE_TIMERA0) || defined(MILLIS_USE_TIMERA1) || defined(MILLIS_USE_TIMERD0)
        overflows = timer_overflow_count;
      #else
        overflows = timer_millis;
     d28:	20 91 7e 41 	lds	r18, 0x417E	; 0x80417e <timer_millis>
     d2c:	30 91 7f 41 	lds	r19, 0x417F	; 0x80417f <timer_millis+0x1>
     d30:	40 91 80 41 	lds	r20, 0x4180	; 0x804180 <timer_millis+0x2>
     d34:	50 91 81 41 	lds	r21, 0x4181	; 0x804181 <timer_millis+0x3>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:243
      #endif

      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG;
     d38:	9f bf       	out	0x3f, r25	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:264
          }
        #else
          // here, ticks is F_CPU/2000 so it's trickier to pick something to check against.
          // Why not just do a damned normal compare? that bitwise and saved like 2-3 clocks, and vastly decreased our tolerance to disabled interrupts.
          #define OVERFLOW_THRESHOLD ((F_CPU / 2000) - 500)
          if ((flags & TCB_CAPT_bm) && (ticks < OVERFLOW_THRESHOLD)) {
     d3a:	80 ff       	sbrs	r24, 0
     d3c:	08 c0       	rjmp	.+16     	; 0xd4e <micros+0x36>
     d3e:	ec 3e       	cpi	r30, 0xEC	; 236
     d40:	8c e2       	ldi	r24, 0x2C	; 44
     d42:	f8 07       	cpc	r31, r24
     d44:	20 f4       	brcc	.+8      	; 0xd4e <micros+0x36>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:265
            overflows++;
     d46:	2f 5f       	subi	r18, 0xFF	; 255
     d48:	3f 4f       	sbci	r19, 0xFF	; 255
     d4a:	4f 4f       	sbci	r20, 0xFF	; 255
     d4c:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:384
         * 57 replaced with 30 save 27 clocks @ 12 = 2 us saved
         * 67 replaced with 32 save 35 clocks @ 24 = 1.5us saved
         * 77 replaced with 34 save 43 clocks @ 48 = 1 us saved
         */
        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          __asm__ __volatile__(
     d4e:	0f 01       	movw	r0, r30
     d50:	16 94       	lsr	r1
     d52:	07 94       	ror	r0
     d54:	16 94       	lsr	r1
     d56:	07 94       	ror	r0
     d58:	16 94       	lsr	r1
     d5a:	07 94       	ror	r0
     d5c:	16 94       	lsr	r1
     d5e:	07 94       	ror	r0
     d60:	f0 01       	movw	r30, r0
     d62:	16 94       	lsr	r1
     d64:	07 94       	ror	r0
     d66:	e0 0d       	add	r30, r0
     d68:	f1 1d       	adc	r31, r1
     d6a:	16 94       	lsr	r1
     d6c:	07 94       	ror	r0
     d6e:	10 2c       	mov	r1, r0
     d70:	16 94       	lsr	r1
     d72:	01 18       	sub	r0, r1
     d74:	16 94       	lsr	r1
     d76:	01 0c       	add	r0, r1
     d78:	16 94       	lsr	r1
     d7a:	01 18       	sub	r0, r1
     d7c:	16 94       	lsr	r1
     d7e:	01 0c       	add	r0, r1
     d80:	16 94       	lsr	r1
     d82:	01 18       	sub	r0, r1
     d84:	16 94       	lsr	r1
     d86:	16 94       	lsr	r1
     d88:	01 0c       	add	r0, r1
     d8a:	11 24       	eor	r1, r1
     d8c:	e0 19       	sub	r30, r0
     d8e:	f1 09       	sbc	r31, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:429
            "add r0,r1"     "\n\t"  // + ticks >> 9
            "eor r1,r1"     "\n\t"  // clear out r1
            "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
            "sbc %B0,r1"    "\n"    // carry
            : "+r" (ticks));        // Do the rest in C
          microseconds = overflows * 1000 + ticks; // nice and clean.
     d90:	a8 ee       	ldi	r26, 0xE8	; 232
     d92:	b3 e0       	ldi	r27, 0x03	; 3
     d94:	0e 94 32 21 	call	0x4264	; 0x4264 <__muluhisi3>
     d98:	6e 0f       	add	r22, r30
     d9a:	7f 1f       	adc	r23, r31
     d9c:	81 1d       	adc	r24, r1
     d9e:	91 1d       	adc	r25, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:594
          microseconds = ((overflows *  clockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                            + (ticks * (clockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif //end of timer-specific part of micros calculations
      return microseconds;
    }
     da0:	08 95       	ret

00000da2 <delay>:
delay():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:600
  #endif //end of non-RTC micros code
#endif //end of non-MILLIS_USE_TIMERNONE code

#if   (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC))) //delay implementation when we do have micros()
  void delay(unsigned long ms)
  {
     da2:	8f 92       	push	r8
     da4:	9f 92       	push	r9
     da6:	af 92       	push	r10
     da8:	bf 92       	push	r11
     daa:	cf 92       	push	r12
     dac:	df 92       	push	r13
     dae:	ef 92       	push	r14
     db0:	ff 92       	push	r15
     db2:	4b 01       	movw	r8, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:601
    uint32_t start = micros();
     db4:	5c 01       	movw	r10, r24
     db6:	b0 df       	rcall	.-160    	; 0xd18 <micros>
     db8:	6b 01       	movw	r12, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:605

    while (ms > 0) {
      yield();
      while (ms > 0 && (micros() - start) >= 1000) {
     dba:	7c 01       	movw	r14, r24
     dbc:	ad df       	rcall	.-166    	; 0xd18 <micros>
     dbe:	6c 19       	sub	r22, r12
     dc0:	7d 09       	sbc	r23, r13
     dc2:	8e 09       	sbc	r24, r14
     dc4:	9f 09       	sbc	r25, r15
     dc6:	68 3e       	cpi	r22, 0xE8	; 232
     dc8:	73 40       	sbci	r23, 0x03	; 3
     dca:	81 05       	cpc	r24, r1
     dcc:	91 05       	cpc	r25, r1
     dce:	b0 f3       	brcs	.-20     	; 0xdbc <delay+0x1a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:606
        ms--;
     dd0:	21 e0       	ldi	r18, 0x01	; 1
     dd2:	82 1a       	sub	r8, r18
     dd4:	91 08       	sbc	r9, r1
     dd6:	a1 08       	sbc	r10, r1
     dd8:	b1 08       	sbc	r11, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:607
        start += 1000;
     dda:	88 ee       	ldi	r24, 0xE8	; 232
     ddc:	c8 0e       	add	r12, r24
     dde:	83 e0       	ldi	r24, 0x03	; 3
     de0:	d8 1e       	adc	r13, r24
     de2:	e1 1c       	adc	r14, r1
     de4:	f1 1c       	adc	r15, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:605
  {
    uint32_t start = micros();

    while (ms > 0) {
      yield();
      while (ms > 0 && (micros() - start) >= 1000) {
     de6:	81 14       	cp	r8, r1
     de8:	91 04       	cpc	r9, r1
     dea:	a1 04       	cpc	r10, r1
     dec:	b1 04       	cpc	r11, r1
     dee:	31 f7       	brne	.-52     	; 0xdbc <delay+0x1a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:610
        ms--;
        start += 1000;
      }
    }
  }
     df0:	ff 90       	pop	r15
     df2:	ef 90       	pop	r14
     df4:	df 90       	pop	r13
     df6:	cf 90       	pop	r12
     df8:	bf 90       	pop	r11
     dfa:	af 90       	pop	r10
     dfc:	9f 90       	pop	r9
     dfe:	8f 90       	pop	r8
     e00:	08 95       	ret

00000e02 <millis>:
millis():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:182
  unsigned long millis()
  {
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
     e02:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:183
    cli();
     e04:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:195
      m = (m << 16);
      m += RTC.CNT;
      //now correct for there being 1000ms to the second instead of 1024
      m = m - (m >> 5) - (m >> 6); */
    #else
      m = timer_millis;
     e06:	60 91 7e 41 	lds	r22, 0x417E	; 0x80417e <timer_millis>
     e0a:	70 91 7f 41 	lds	r23, 0x417F	; 0x80417f <timer_millis+0x1>
     e0e:	80 91 80 41 	lds	r24, 0x4180	; 0x804180 <timer_millis+0x2>
     e12:	90 91 81 41 	lds	r25, 0x4181	; 0x804181 <timer_millis+0x3>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:196
      SREG = oldSREG;
     e16:	2f bf       	out	0x3f, r18	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:199
    #endif
    return m;
  }
     e18:	08 95       	ret

00000e1a <hd44780::command(unsigned char)>:
command():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:819
// command() - send hd44780 command byte to lcd
//
// Returns 0 on success, non zero if command failed
//
inline int hd44780::command(uint8_t value)
{
     e1a:	8f 92       	push	r8
     e1c:	9f 92       	push	r9
     e1e:	af 92       	push	r10
     e20:	bf 92       	push	r11
     e22:	ef 92       	push	r14
     e24:	ff 92       	push	r15
     e26:	1f 93       	push	r17
     e28:	cf 93       	push	r28
     e2a:	df 93       	push	r29
     e2c:	ec 01       	movw	r28, r24
     e2e:	16 2f       	mov	r17, r22
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:822
int status;

	status = iowrite(HD44780_IOcmd, value);
     e30:	e8 81       	ld	r30, Y
     e32:	f9 81       	ldd	r31, Y+1	; 0x01
     e34:	04 84       	ldd	r0, Z+12	; 0x0c
     e36:	f5 85       	ldd	r31, Z+13	; 0x0d
     e38:	e0 2d       	mov	r30, r0
     e3a:	46 2f       	mov	r20, r22
     e3c:	70 e0       	ldi	r23, 0x00	; 0
     e3e:	60 e0       	ldi	r22, 0x00	; 0
     e40:	09 95       	icall
     e42:	7c 01       	movw	r14, r24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:825

	// executime time depends on command
	if((value == HD44780_CLEARDISPLAY) || (value == HD44780_RETURNHOME))
     e44:	11 50       	subi	r17, 0x01	; 1
     e46:	12 30       	cpi	r17, 0x02	; 2
     e48:	d0 f4       	brcc	.+52     	; 0xe7e <hd44780::command(unsigned char)+0x64>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:827
	{
		_curcol = 0;
     e4a:	19 86       	std	Y+9, r1	; 0x09
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:829
		_currow = 0;
		markStart(_chExecTime);
     e4c:	1a 86       	std	Y+10, r1	; 0x0a
     e4e:	88 88       	ldd	r8, Y+16	; 0x10
     e50:	99 88       	ldd	r9, Y+17	; 0x11
     e52:	aa 88       	ldd	r10, Y+18	; 0x12
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:397
	virtual int iosetContrast(uint8_t contvalue){if(contvalue) return(RV_ENOTSUP); else return(RV_ENOTSUP);}// optional

	uint8_t _rowOffsets[4]; // memory address of start of each row/line

	// stuff for tracking execution times
	inline void markStart(uint32_t exectime) { _startTime = (uint32_t) micros(); _execTime = exectime;}
     e54:	bb 88       	ldd	r11, Y+19	; 0x13
markStart():
     e56:	60 df       	rcall	.-320    	; 0xd18 <micros>
     e58:	68 8f       	std	Y+24, r22	; 0x18
     e5a:	79 8f       	std	Y+25, r23	; 0x19
     e5c:	8a 8f       	std	Y+26, r24	; 0x1a
     e5e:	9b 8f       	std	Y+27, r25	; 0x1b
     e60:	8c 8e       	std	Y+28, r8	; 0x1c
     e62:	9d 8e       	std	Y+29, r9	; 0x1d
     e64:	ae 8e       	std	Y+30, r10	; 0x1e
     e66:	bf 8e       	std	Y+31, r11	; 0x1f
command():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:837
	{
		markStart(_insExecTime);
	}

	return(status);
}
     e68:	c7 01       	movw	r24, r14
     e6a:	df 91       	pop	r29
     e6c:	cf 91       	pop	r28
     e6e:	1f 91       	pop	r17
     e70:	ff 90       	pop	r15
     e72:	ef 90       	pop	r14
     e74:	bf 90       	pop	r11
     e76:	af 90       	pop	r10
     e78:	9f 90       	pop	r9
     e7a:	8f 90       	pop	r8
     e7c:	08 95       	ret
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:833
		_currow = 0;
		markStart(_chExecTime);
	}
	else
	{
		markStart(_insExecTime);
     e7e:	8c 88       	ldd	r8, Y+20	; 0x14
     e80:	9d 88       	ldd	r9, Y+21	; 0x15
     e82:	ae 88       	ldd	r10, Y+22	; 0x16
     e84:	bf 88       	ldd	r11, Y+23	; 0x17
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:548
	return(rval);
}

int hd44780::clear()
{
	return(command(HD44780_CLEARDISPLAY));  // clear display, set cursor to 0,0
     e86:	e7 cf       	rjmp	.-50     	; 0xe56 <hd44780::command(unsigned char)+0x3c>

00000e88 <hd44780::clear() [clone .constprop.24]>:
clear():
     e88:	61 e0       	ldi	r22, 0x01	; 1
     e8a:	85 e1       	ldi	r24, 0x15	; 21
     e8c:	9e e4       	ldi	r25, 0x4E	; 78
     e8e:	c5 cf       	rjmp	.-118    	; 0xe1a <hd44780::command(unsigned char)>

00000e90 <hd44780::setCursor(unsigned char, unsigned char)>:
setCursor():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:573
	return(RV_ENOERR);
}


int hd44780::setCursor(uint8_t col, uint8_t row)
{
     e90:	dc 01       	movw	r26, r24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:578
	// while this could return RV_EINVAL for invalid parameters
	// it is going to adjust them to maintain compability with existing LiquidCrystal
	// library and to allow a back door way to set the ddram address - see below

	if ( row >= _rows ) 
     e92:	18 96       	adiw	r26, 0x08	; 8
     e94:	8c 91       	ld	r24, X
     e96:	18 97       	sbiw	r26, 0x08	; 8
     e98:	48 17       	cp	r20, r24
     e9a:	10 f0       	brcs	.+4      	; 0xea0 <hd44780::setCursor(unsigned char, unsigned char)+0x10>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:581
	{
		// set to max line (rows/lines start at 0, _rows is 1 based)
		row = _rows-1;
     e9c:	4f ef       	ldi	r20, 0xFF	; 255
     e9e:	48 0f       	add	r20, r24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:597
	 * position takes into consideration line wrapping.
	 * i.e. positioning to col 16, row 0  on a 16x2 display
	 * will position the cursor to col 0 row 1.
	 */

	if(_wraplines)
     ea0:	1b 96       	adiw	r26, 0x0b	; 11
     ea2:	9c 91       	ld	r25, X
     ea4:	1b 97       	sbiw	r26, 0x0b	; 11
     ea6:	99 23       	and	r25, r25
     ea8:	89 f0       	breq	.+34     	; 0xecc <hd44780::setCursor(unsigned char, unsigned char)+0x3c>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:600
	{
		// wrap while requested col > toal cols
		while(col >= _cols)
     eaa:	17 96       	adiw	r26, 0x07	; 7
     eac:	9c 91       	ld	r25, X
     eae:	17 97       	sbiw	r26, 0x07	; 7
     eb0:	69 17       	cp	r22, r25
     eb2:	30 f0       	brcs	.+12     	; 0xec0 <hd44780::setCursor(unsigned char, unsigned char)+0x30>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:602
		{
			col -= _cols;
     eb4:	69 1b       	sub	r22, r25
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:603
			if(++row >= _rows)
     eb6:	4f 5f       	subi	r20, 0xFF	; 255
     eb8:	48 17       	cp	r20, r24
     eba:	d0 f3       	brcs	.-12     	; 0xeb0 <hd44780::setCursor(unsigned char, unsigned char)+0x20>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:604
				row = 0; // wrap back to top line
     ebc:	40 e0       	ldi	r20, 0x00	; 0
     ebe:	f8 cf       	rjmp	.-16     	; 0xeb0 <hd44780::setCursor(unsigned char, unsigned char)+0x20>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:608
		}

		// save position
		_curcol = col;
     ec0:	19 96       	adiw	r26, 0x09	; 9
     ec2:	6c 93       	st	X, r22
     ec4:	19 97       	sbiw	r26, 0x09	; 9
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:609
		_currow = row;
     ec6:	1a 96       	adiw	r26, 0x0a	; 10
     ec8:	4c 93       	st	X, r20
     eca:	1a 97       	sbiw	r26, 0x0a	; 10
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:625
	//
	if(!(_displaymode & HD44780_ENTRYLEFT2RIGHT))
		return(command(HD44780_SETDDRAMADDR | (_cols - col -1 + _rowOffsets[row])));
	else
#endif
		return(command(HD44780_SETDDRAMADDR | (col + _rowOffsets[row])));
     ecc:	fd 01       	movw	r30, r26
     ece:	e4 0f       	add	r30, r20
     ed0:	f1 1d       	adc	r31, r1
     ed2:	84 85       	ldd	r24, Z+12	; 0x0c
     ed4:	68 0f       	add	r22, r24
     ed6:	60 68       	ori	r22, 0x80	; 128
     ed8:	cd 01       	movw	r24, r26
     eda:	9f cf       	rjmp	.-194    	; 0xe1a <hd44780::command(unsigned char)>

00000edc <hd44780::write(unsigned char)>:
write():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:874

// write() - process data character byte to lcd
// returns number of bytes successfully written to device
// i.e. 1 if success or 0 if no character was processed (error)
size_t hd44780::write(uint8_t value)
{
     edc:	8f 92       	push	r8
     ede:	9f 92       	push	r9
     ee0:	af 92       	push	r10
     ee2:	bf 92       	push	r11
     ee4:	ef 92       	push	r14
     ee6:	ff 92       	push	r15
     ee8:	0f 93       	push	r16
     eea:	1f 93       	push	r17
     eec:	cf 93       	push	r28
     eee:	df 93       	push	r29
     ef0:	ec 01       	movw	r28, r24
     ef2:	46 2f       	mov	r20, r22
_write():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:900
// returns 1 if success or 0 if no byte was processed (error)
size_t hd44780::_write(uint8_t value)
{
int status = 1; //assume success

	if(iowrite(HD44780_IOdata, value))
     ef4:	e8 81       	ld	r30, Y
     ef6:	f9 81       	ldd	r31, Y+1	; 0x01
     ef8:	04 84       	ldd	r0, Z+12	; 0x0c
     efa:	f5 85       	ldd	r31, Z+13	; 0x0d
     efc:	e0 2d       	mov	r30, r0
     efe:	61 e0       	ldi	r22, 0x01	; 1
     f00:	70 e0       	ldi	r23, 0x00	; 0
     f02:	09 95       	icall
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:902
		status = 0; // write was unsuccessful
	markStart(_insExecTime);
     f04:	7c 01       	movw	r14, r24
     f06:	8c 88       	ldd	r8, Y+20	; 0x14
     f08:	9d 88       	ldd	r9, Y+21	; 0x15
     f0a:	ae 88       	ldd	r10, Y+22	; 0x16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:397
     f0c:	bf 88       	ldd	r11, Y+23	; 0x17
markStart():
     f0e:	04 df       	rcall	.-504    	; 0xd18 <micros>
     f10:	68 8f       	std	Y+24, r22	; 0x18
     f12:	79 8f       	std	Y+25, r23	; 0x19
     f14:	8a 8f       	std	Y+26, r24	; 0x1a
     f16:	9b 8f       	std	Y+27, r25	; 0x1b
     f18:	8c 8e       	std	Y+28, r8	; 0x1c
     f1a:	9d 8e       	std	Y+29, r9	; 0x1d
     f1c:	ae 8e       	std	Y+30, r10	; 0x1e
     f1e:	bf 8e       	std	Y+31, r11	; 0x1f
_write():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:900
// returns 1 if success or 0 if no byte was processed (error)
size_t hd44780::_write(uint8_t value)
{
int status = 1; //assume success

	if(iowrite(HD44780_IOdata, value))
     f20:	01 e0       	ldi	r16, 0x01	; 1
     f22:	10 e0       	ldi	r17, 0x00	; 0
     f24:	ef 28       	or	r14, r15
     f26:	11 f0       	breq	.+4      	; 0xf2c <hd44780::write(unsigned char)+0x50>
     f28:	10 e0       	ldi	r17, 0x00	; 0
     f2a:	00 e0       	ldi	r16, 0x00	; 0
write():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:878
size_t hd44780::write(uint8_t value)
{
size_t rval;

	rval = _write(value);
	if(_wraplines)
     f2c:	8b 85       	ldd	r24, Y+11	; 0x0b
     f2e:	88 23       	and	r24, r24
     f30:	91 f0       	breq	.+36     	; 0xf56 <hd44780::write(unsigned char)+0x7a>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:881
	{
		// currently only works for left to right mode
		if(++_curcol >= _cols)
     f32:	89 85       	ldd	r24, Y+9	; 0x09
     f34:	8f 5f       	subi	r24, 0xFF	; 255
     f36:	89 87       	std	Y+9, r24	; 0x09
     f38:	9f 81       	ldd	r25, Y+7	; 0x07
     f3a:	89 17       	cp	r24, r25
     f3c:	60 f0       	brcs	.+24     	; 0xf56 <hd44780::write(unsigned char)+0x7a>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:883
		{
			_curcol = 0;
     f3e:	19 86       	std	Y+9, r1	; 0x09
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:884
			_currow++;
     f40:	8a 85       	ldd	r24, Y+10	; 0x0a
     f42:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:885
			if(_currow >= _rows)
     f44:	8a 87       	std	Y+10, r24	; 0x0a
     f46:	98 85       	ldd	r25, Y+8	; 0x08
     f48:	89 17       	cp	r24, r25
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:886
				_currow = 0;
     f4a:	08 f0       	brcs	.+2      	; 0xf4e <hd44780::write(unsigned char)+0x72>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:887
			setCursor(_curcol, _currow);
     f4c:	1a 86       	std	Y+10, r1	; 0x0a
     f4e:	4a 85       	ldd	r20, Y+10	; 0x0a
     f50:	60 e0       	ldi	r22, 0x00	; 0
     f52:	ce 01       	movw	r24, r28
     f54:	9d df       	rcall	.-198    	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:891
		}
	}
	return (rval);
}
     f56:	c8 01       	movw	r24, r16
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	1f 91       	pop	r17
     f5e:	0f 91       	pop	r16
     f60:	ff 90       	pop	r15
     f62:	ef 90       	pop	r14
     f64:	bf 90       	pop	r11
     f66:	af 90       	pop	r10
     f68:	9f 90       	pop	r9
     f6a:	8f 90       	pop	r8
     f6c:	08 95       	ret

00000f6e <hd44780::iosetContrast(unsigned char)>:
iosetContrast():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:392
	// i/o subclass functions
	virtual int ioinit() {return 0;}	// optional - successful if not implemented
	virtual int ioread(hd44780::iotype type) {if(type) return(RV_ENOTSUP);else return(RV_ENOTSUP);}	// optional, return fail if not implemented
	virtual int iowrite(hd44780::iotype type, uint8_t value)=0;// mandatory
	virtual int iosetBacklight(uint8_t dimvalue){if(dimvalue) return(RV_ENOTSUP); else return(RV_ENOTSUP);}	// optional
	virtual int iosetContrast(uint8_t contvalue){if(contvalue) return(RV_ENOTSUP); else return(RV_ENOTSUP);}// optional
     f6e:	8d ef       	ldi	r24, 0xFD	; 253
     f70:	9f ef       	ldi	r25, 0xFF	; 255
     f72:	08 95       	ret

00000f74 <hd44780::ioread(hd44780::iotype)>:
ioread():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:389
	uint8_t _currow;	// current LCD row if doing char & line processing
	uint8_t _wraplines;	// set to nonzero if wrapping long lines

	// i/o subclass functions
	virtual int ioinit() {return 0;}	// optional - successful if not implemented
	virtual int ioread(hd44780::iotype type) {if(type) return(RV_ENOTSUP);else return(RV_ENOTSUP);}	// optional, return fail if not implemented
     f74:	8d ef       	ldi	r24, 0xFD	; 253
     f76:	9f ef       	ldi	r25, 0xFF	; 255
     f78:	08 95       	ret

00000f7a <Print::availableForWrite()>:
availableForWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:58
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	80 e0       	ldi	r24, 0x00	; 0
     f7e:	08 95       	ret

00000f80 <getPalleteNumber()>:
getPalleteNumber():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:728
  } else {
    return 3 * currentValueRight[1];
  }
}
byte getPalleteNumber() {
  if (currentMode == 4) {
     f80:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
     f84:	84 30       	cpi	r24, 0x04	; 4
     f86:	19 f0       	breq	.+6      	; 0xf8e <getPalleteNumber()+0xe>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:731
    return 0;
  } else {
    return currentValueLeft[0];
     f88:	80 91 79 47 	lds	r24, 0x4779	; 0x804779 <currentValueLeft>
     f8c:	08 95       	ret
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:729
    return 3 * currentValueRight[1];
  }
}
byte getPalleteNumber() {
  if (currentMode == 4) {
    return 0;
     f8e:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:733
  } else {
    return currentValueLeft[0];
  }
}
     f90:	08 95       	ret

00000f92 <getTransitionFrames()>:
getTransitionFrames():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:719
    return 2 + (4 * currentValueRight[2]);
  }
  return 0; //TO DO
}
unsigned int getTransitionFrames() {
  if (currentMode == 4) {
     f92:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
     f96:	84 30       	cpi	r24, 0x04	; 4
     f98:	41 f4       	brne	.+16     	; 0xfaa <getTransitionFrames()+0x18>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:720
    return 9 + (6 * currentValueRight[1]);
     f9a:	80 91 82 47 	lds	r24, 0x4782	; 0x804782 <currentValueRight+0x1>
     f9e:	26 e0       	ldi	r18, 0x06	; 6
     fa0:	82 9f       	mul	r24, r18
     fa2:	c0 01       	movw	r24, r0
     fa4:	11 24       	eor	r1, r1
     fa6:	09 96       	adiw	r24, 0x09	; 9
     fa8:	08 95       	ret
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:721
  } else if (currentMode == 8) {
     faa:	88 30       	cpi	r24, 0x08	; 8
     fac:	39 f0       	breq	.+14     	; 0xfbc <getTransitionFrames()+0x2a>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:724
    return 255;
  } else {
    return 3 * currentValueRight[1];
     fae:	80 91 82 47 	lds	r24, 0x4782	; 0x804782 <currentValueRight+0x1>
     fb2:	23 e0       	ldi	r18, 0x03	; 3
     fb4:	82 9f       	mul	r24, r18
     fb6:	c0 01       	movw	r24, r0
     fb8:	11 24       	eor	r1, r1
     fba:	08 95       	ret
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:722
}
unsigned int getTransitionFrames() {
  if (currentMode == 4) {
    return 9 + (6 * currentValueRight[1]);
  } else if (currentMode == 8) {
    return 255;
     fbc:	8f ef       	ldi	r24, 0xFF	; 255
     fbe:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:726
  } else {
    return 3 * currentValueRight[1];
  }
}
     fc0:	08 95       	ret

00000fc2 <getDwellFrames()>:
getDwellFrames():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:711
    pixels[2] = b;
  }
}

unsigned int getDwellFrames() {
  if (currentMode == 4 || currentMode == 8) {
     fc2:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
     fc6:	84 30       	cpi	r24, 0x04	; 4
     fc8:	51 f0       	breq	.+20     	; 0xfde <getDwellFrames()+0x1c>
     fca:	88 30       	cpi	r24, 0x08	; 8
     fcc:	41 f0       	breq	.+16     	; 0xfde <getDwellFrames()+0x1c>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:714
    return 2;
  } else {
    return 2 + (4 * currentValueRight[2]);
     fce:	80 91 83 47 	lds	r24, 0x4783	; 0x804783 <currentValueRight+0x2>
     fd2:	24 e0       	ldi	r18, 0x04	; 4
     fd4:	82 9f       	mul	r24, r18
     fd6:	c0 01       	movw	r24, r0
     fd8:	11 24       	eor	r1, r1
     fda:	02 96       	adiw	r24, 0x02	; 2
     fdc:	08 95       	ret
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:712
  }
}

unsigned int getDwellFrames() {
  if (currentMode == 4 || currentMode == 8) {
    return 2;
     fde:	82 e0       	ldi	r24, 0x02	; 2
     fe0:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:717
  } else {
    return 2 + (4 * currentValueRight[2]);
  }
  return 0; //TO DO
}
     fe2:	08 95       	ret

00000fe4 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)>:
getDrift2Colors():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:829

    return (byte)(ratio * 255.5);
  }
}

void getDrift2Colors(byte * r, byte * g, byte * b, unsigned long fnumber) {
     fe4:	2f 92       	push	r2
     fe6:	3f 92       	push	r3
     fe8:	4f 92       	push	r4
     fea:	5f 92       	push	r5
     fec:	6f 92       	push	r6
     fee:	7f 92       	push	r7
     ff0:	8f 92       	push	r8
     ff2:	9f 92       	push	r9
     ff4:	af 92       	push	r10
     ff6:	bf 92       	push	r11
     ff8:	cf 92       	push	r12
     ffa:	df 92       	push	r13
     ffc:	ef 92       	push	r14
     ffe:	ff 92       	push	r15
    1000:	0f 93       	push	r16
    1002:	1f 93       	push	r17
    1004:	cf 93       	push	r28
    1006:	df 93       	push	r29
    1008:	1c 01       	movw	r2, r24
    100a:	3b 01       	movw	r6, r22
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:830
  unsigned int dwellFrames = getDwellFrames();
    100c:	2a 01       	movw	r4, r20
    100e:	48 01       	movw	r8, r16
    1010:	59 01       	movw	r10, r18
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:831
  unsigned int transitionFrames = getTransitionFrames();
    1012:	d7 df       	rcall	.-82     	; 0xfc2 <getDwellFrames()>
    1014:	6c 01       	movw	r12, r24
    1016:	bd df       	rcall	.-134    	; 0xf92 <getTransitionFrames()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:832
  byte colors = getPalleteNumber();
    1018:	7c 01       	movw	r14, r24
    101a:	b2 df       	rcall	.-156    	; 0xf80 <getPalleteNumber()>
    101c:	18 2f       	mov	r17, r24
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:833
  unsigned long tem = ((currentValueRight[currentMode == 4 ? 2 : 3] ? 0 : LENGTH) + fnumber) % (pgm_read_byte_near(&colorCount[colors]) * (dwellFrames + transitionFrames));
    101e:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    1022:	84 30       	cpi	r24, 0x04	; 4
    1024:	09 f0       	breq	.+2      	; 0x1028 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x44>
    1026:	5d c0       	rjmp	.+186    	; 0x10e2 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0xfe>
    1028:	82 e0       	ldi	r24, 0x02	; 2
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	8f 57       	subi	r24, 0x7F	; 127
    102e:	98 4b       	sbci	r25, 0xB8	; 184
    1030:	ec 01       	movw	r28, r24
    1032:	88 81       	ld	r24, Y
    1034:	88 23       	and	r24, r24
    1036:	09 f4       	brne	.+2      	; 0x103a <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x56>
    1038:	57 c0       	rjmp	.+174    	; 0x10e8 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x104>
    103a:	80 e0       	ldi	r24, 0x00	; 0
    103c:	90 e0       	ldi	r25, 0x00	; 0
    103e:	dc 01       	movw	r26, r24
    1040:	c1 2f       	mov	r28, r17
    1042:	d0 e0       	ldi	r29, 0x00	; 0
    1044:	c7 5b       	subi	r28, 0xB7	; 183
    1046:	d8 4f       	sbci	r29, 0xF8	; 248
    1048:	fe 01       	movw	r30, r28
    104a:	44 91       	lpm	r20, Z
    104c:	ec 0c       	add	r14, r12
    104e:	fd 1c       	adc	r15, r13
    1050:	bc 01       	movw	r22, r24
    1052:	cd 01       	movw	r24, r26
    1054:	68 0d       	add	r22, r8
    1056:	79 1d       	adc	r23, r9
    1058:	8a 1d       	adc	r24, r10
    105a:	9b 1d       	adc	r25, r11
    105c:	4e 9d       	mul	r20, r14
    105e:	90 01       	movw	r18, r0
    1060:	4f 9d       	mul	r20, r15
    1062:	30 0d       	add	r19, r0
    1064:	11 24       	eor	r1, r1
    1066:	50 e0       	ldi	r21, 0x00	; 0
    1068:	40 e0       	ldi	r20, 0x00	; 0
    106a:	0e 94 42 21 	call	0x4284	; 0x4284 <__udivmodsi4>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:834
  unsigned int cyclepos = tem % (dwellFrames + transitionFrames);
    106e:	97 01       	movw	r18, r14
    1070:	50 e0       	ldi	r21, 0x00	; 0
    1072:	40 e0       	ldi	r20, 0x00	; 0
    1074:	0e 94 42 21 	call	0x4284	; 0x4284 <__udivmodsi4>
    1078:	e2 2e       	mov	r14, r18
    107a:	f1 2c       	mov	r15, r1
    107c:	f8 e1       	ldi	r31, 0x18	; 24
    107e:	1f 9f       	mul	r17, r31
    1080:	50 01       	movw	r10, r0
    1082:	11 24       	eor	r1, r1
    1084:	f5 01       	movw	r30, r10
    1086:	03 e0       	ldi	r16, 0x03	; 3
    1088:	20 9f       	mul	r18, r16
    108a:	e0 0d       	add	r30, r0
    108c:	f1 1d       	adc	r31, r1
    108e:	11 24       	eor	r1, r1
    1090:	df 01       	movw	r26, r30
    1092:	ac 5c       	subi	r26, 0xCC	; 204
    1094:	bc 4f       	sbci	r27, 0xFC	; 252
    1096:	af 01       	movw	r20, r30
    1098:	4b 5c       	subi	r20, 0xCB	; 203
    109a:	5c 4f       	sbci	r21, 0xFC	; 252
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:836
  byte cyclenum = tem / (dwellFrames + transitionFrames);
  if (cyclepos < dwellFrames) {
    109c:	6c 15       	cp	r22, r12
    109e:	7d 05       	cpc	r23, r13
    10a0:	40 f5       	brcc	.+80     	; 0x10f2 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x10e>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:837
    *r = pgm_read_byte_near(&colorPallete[colors][cyclenum][0]);
    10a2:	ed 5c       	subi	r30, 0xCD	; 205
    10a4:	fc 4f       	sbci	r31, 0xFC	; 252
    10a6:	e4 91       	lpm	r30, Z
    10a8:	e1 01       	movw	r28, r2
    10aa:	e8 83       	st	Y, r30
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:838
    *g = pgm_read_byte_near(&colorPallete[colors][cyclenum][1]);
    10ac:	fd 01       	movw	r30, r26
    10ae:	a4 91       	lpm	r26, Z
    10b0:	e3 01       	movw	r28, r6
    10b2:	a8 83       	st	Y, r26
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:839
    *b = pgm_read_byte_near(&colorPallete[colors][cyclenum][2]);
    10b4:	fa 01       	movw	r30, r20
    10b6:	44 91       	lpm	r20, Z
    10b8:	e2 01       	movw	r28, r4
    10ba:	48 83       	st	Y, r20
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:849
    unsigned int start = (LENGTH * 3 + 1) >> 1 ;
    byte ratio = scratch[start + cyclepos];
    *g = (((unsigned int)(pgm_read_byte_near(&colorPallete[colors][m][1]) * ratio)) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][1]) * (255 - ratio))) >> 8;
    *b = (((unsigned int)(pgm_read_byte_near(&colorPallete[colors][m][2]) * ratio)) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][2]) * (255 - ratio))) >> 8;
  }
}
    10bc:	df 91       	pop	r29
    10be:	cf 91       	pop	r28
    10c0:	1f 91       	pop	r17
    10c2:	0f 91       	pop	r16
    10c4:	ff 90       	pop	r15
    10c6:	ef 90       	pop	r14
    10c8:	df 90       	pop	r13
    10ca:	cf 90       	pop	r12
    10cc:	bf 90       	pop	r11
    10ce:	af 90       	pop	r10
    10d0:	9f 90       	pop	r9
    10d2:	8f 90       	pop	r8
    10d4:	7f 90       	pop	r7
    10d6:	6f 90       	pop	r6
    10d8:	5f 90       	pop	r5
    10da:	4f 90       	pop	r4
    10dc:	3f 90       	pop	r3
    10de:	2f 90       	pop	r2
    10e0:	08 95       	ret
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:833

void getDrift2Colors(byte * r, byte * g, byte * b, unsigned long fnumber) {
  unsigned int dwellFrames = getDwellFrames();
  unsigned int transitionFrames = getTransitionFrames();
  byte colors = getPalleteNumber();
  unsigned long tem = ((currentValueRight[currentMode == 4 ? 2 : 3] ? 0 : LENGTH) + fnumber) % (pgm_read_byte_near(&colorCount[colors]) * (dwellFrames + transitionFrames));
    10e2:	83 e0       	ldi	r24, 0x03	; 3
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	a2 cf       	rjmp	.-188    	; 0x102c <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x48>
    10e8:	84 ef       	ldi	r24, 0xF4	; 244
    10ea:	91 e0       	ldi	r25, 0x01	; 1
    10ec:	a0 e0       	ldi	r26, 0x00	; 0
    10ee:	b0 e0       	ldi	r27, 0x00	; 0
    10f0:	a7 cf       	rjmp	.-178    	; 0x1040 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x5c>
    10f2:	ee ee       	ldi	r30, 0xEE	; 238
    10f4:	f2 e0       	ldi	r31, 0x02	; 2
    10f6:	8f 01       	movw	r16, r30
    10f8:	0c 19       	sub	r16, r12
    10fa:	1d 09       	sbc	r17, r13
    10fc:	68 01       	movw	r12, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:843
    *g = pgm_read_byte_near(&colorPallete[colors][cyclenum][1]);
    *b = pgm_read_byte_near(&colorPallete[colors][cyclenum][2]);
    return;
  } else {
    cyclepos -= dwellFrames;
    byte m = ((cyclenum + 1) >= pgm_read_byte_near(&colorCount[colors])) ? 0 : cyclenum + 1;
    10fe:	fe 01       	movw	r30, r28
    1100:	c4 91       	lpm	r28, Z
    1102:	ff ef       	ldi	r31, 0xFF	; 255
    1104:	ef 1a       	sub	r14, r31
    1106:	ff 0a       	sbc	r15, r31
    1108:	2f 5f       	subi	r18, 0xFF	; 255
    110a:	ce 15       	cp	r28, r14
    110c:	1f 04       	cpc	r1, r15
    110e:	09 f0       	breq	.+2      	; 0x1112 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x12e>
    1110:	0c f4       	brge	.+2      	; 0x1114 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x130>
    1112:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:845
    unsigned int start = (LENGTH * 3 + 1) >> 1 ;
    byte ratio = scratch[start + cyclepos];
    1114:	8b 01       	movw	r16, r22
    1116:	07 56       	subi	r16, 0x67	; 103
    1118:	1e 4b       	sbci	r17, 0xBE	; 190
    111a:	48 01       	movw	r8, r16
    111c:	8c 0c       	add	r8, r12
    111e:	9d 1c       	adc	r9, r13
    1120:	f4 01       	movw	r30, r8
    1122:	c0 81       	ld	r28, Z
    1124:	c5 01       	movw	r24, r10
    1126:	f3 e0       	ldi	r31, 0x03	; 3
    1128:	2f 9f       	mul	r18, r31
    112a:	80 0d       	add	r24, r0
    112c:	91 1d       	adc	r25, r1
    112e:	11 24       	eor	r1, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:846
    *g = (((unsigned int)(pgm_read_byte_near(&colorPallete[colors][m][1]) * ratio)) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][1]) * (255 - ratio))) >> 8;
    1130:	fc 01       	movw	r30, r24
    1132:	ec 5c       	subi	r30, 0xCC	; 204
    1134:	fc 4f       	sbci	r31, 0xFC	; 252
    1136:	d4 91       	lpm	r29, Z
    1138:	fd 01       	movw	r30, r26
    113a:	a4 91       	lpm	r26, Z
    113c:	2f ef       	ldi	r18, 0xFF	; 255
    113e:	30 e0       	ldi	r19, 0x00	; 0
    1140:	2c 1b       	sub	r18, r28
    1142:	31 09       	sbc	r19, r1
    1144:	a2 9f       	mul	r26, r18
    1146:	b0 01       	movw	r22, r0
    1148:	a3 9f       	mul	r26, r19
    114a:	70 0d       	add	r23, r0
    114c:	11 24       	eor	r1, r1
    114e:	dc 9f       	mul	r29, r28
    1150:	60 0d       	add	r22, r0
    1152:	71 1d       	adc	r23, r1
    1154:	11 24       	eor	r1, r1
    1156:	f3 01       	movw	r30, r6
    1158:	70 83       	st	Z, r23
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:847
    *b = (((unsigned int)(pgm_read_byte_near(&colorPallete[colors][m][2]) * ratio)) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][2]) * (255 - ratio))) >> 8;
    115a:	8b 5c       	subi	r24, 0xCB	; 203
    115c:	9c 4f       	sbci	r25, 0xFC	; 252
    115e:	fc 01       	movw	r30, r24
    1160:	84 91       	lpm	r24, Z
    1162:	fa 01       	movw	r30, r20
    1164:	44 91       	lpm	r20, Z
    1166:	42 9f       	mul	r20, r18
    1168:	b0 01       	movw	r22, r0
    116a:	43 9f       	mul	r20, r19
    116c:	70 0d       	add	r23, r0
    116e:	11 24       	eor	r1, r1
    1170:	c8 9f       	mul	r28, r24
    1172:	60 0d       	add	r22, r0
    1174:	71 1d       	adc	r23, r1
    1176:	11 24       	eor	r1, r1
    1178:	e2 01       	movw	r28, r4
    117a:	78 83       	st	Y, r23
    117c:	9f cf       	rjmp	.-194    	; 0x10bc <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0xd8>

0000117e <pushPixel(unsigned char, unsigned char, unsigned char, unsigned char)>:
pushPixel():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:693
    pixels[i + 2] = b;
  }
}

void pushPixel(byte r, byte g, byte b, byte dir) {
  if (dir) { //reverse
    117e:	22 23       	and	r18, r18
    1180:	81 f0       	breq	.+32     	; 0x11a2 <pushPixel(unsigned char, unsigned char, unsigned char, unsigned char)+0x24>
    1182:	e6 e2       	ldi	r30, 0x26	; 38
    1184:	f8 e4       	ldi	r31, 0x48	; 72
    1186:	2f ef       	ldi	r18, 0xFF	; 255
    1188:	3d e4       	ldi	r19, 0x4D	; 77
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:695
    for (unsigned int i = 0; i < ((LENGTH - 1) * 3); i++) {
      pixels [i] = pixels[i + 3];
    118a:	93 81       	ldd	r25, Z+3	; 0x03
    118c:	91 93       	st	Z+, r25
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:694
  }
}

void pushPixel(byte r, byte g, byte b, byte dir) {
  if (dir) { //reverse
    for (unsigned int i = 0; i < ((LENGTH - 1) * 3); i++) {
    118e:	2e 17       	cp	r18, r30
    1190:	3f 07       	cpc	r19, r31
    1192:	d9 f7       	brne	.-10     	; 0x118a <pushPixel(unsigned char, unsigned char, unsigned char, unsigned char)+0xc>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:697
      pixels [i] = pixels[i + 3];
    }
    pixels[(LENGTH * 3) - 3] = r;
    1194:	80 93 ff 4d 	sts	0x4DFF, r24	; 0x804dff <pixels+0x5d9>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:698
    pixels[(LENGTH * 3) - 2] = g;
    1198:	60 93 00 4e 	sts	0x4E00, r22	; 0x804e00 <pixels+0x5da>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:699
    pixels[(LENGTH * 3) - 1] = b;
    119c:	40 93 01 4e 	sts	0x4E01, r20	; 0x804e01 <pixels+0x5db>
    11a0:	08 95       	ret
    11a2:	ef ef       	ldi	r30, 0xFF	; 255
    11a4:	fd e4       	ldi	r31, 0x4D	; 77
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:702
  } else {//forward
    for (unsigned int i = ((LENGTH) * 3) - 1; i > 2; i--) {
      pixels [i] = pixels[i - 3];
    11a6:	92 91       	ld	r25, -Z
    11a8:	93 83       	std	Z+3, r25	; 0x03
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:701
    }
    pixels[(LENGTH * 3) - 3] = r;
    pixels[(LENGTH * 3) - 2] = g;
    pixels[(LENGTH * 3) - 1] = b;
  } else {//forward
    for (unsigned int i = ((LENGTH) * 3) - 1; i > 2; i--) {
    11aa:	98 e4       	ldi	r25, 0x48	; 72
    11ac:	e6 32       	cpi	r30, 0x26	; 38
    11ae:	f9 07       	cpc	r31, r25
    11b0:	d1 f7       	brne	.-12     	; 0x11a6 <pushPixel(unsigned char, unsigned char, unsigned char, unsigned char)+0x28>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:704
      pixels [i] = pixels[i - 3];
    }
    pixels[0] = r;
    11b2:	80 93 26 48 	sts	0x4826, r24	; 0x804826 <pixels>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:705
    pixels[1] = g;
    11b6:	60 93 27 48 	sts	0x4827, r22	; 0x804827 <pixels+0x1>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:706
    pixels[2] = b;
    11ba:	40 93 28 48 	sts	0x4828, r20	; 0x804828 <pixels+0x2>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:708
  }
}
    11be:	08 95       	ret

000011c0 <getLeftVal(unsigned char)>:
getLeftVal():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:461
    }
  }
}

byte getLeftVal(byte t) {
  if (pgm_read_byte_near(&maxValueLeft[currentMode][currentSettingLeft]) == COLORTABLEMAX) {
    11c0:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    11c4:	20 91 89 47 	lds	r18, 0x4789	; 0x804789 <currentMode>
    11c8:	98 e0       	ldi	r25, 0x08	; 8
    11ca:	29 9f       	mul	r18, r25
    11cc:	90 01       	movw	r18, r0
    11ce:	11 24       	eor	r1, r1
    11d0:	e2 0f       	add	r30, r18
    11d2:	f3 2f       	mov	r31, r19
    11d4:	f1 1d       	adc	r31, r1
    11d6:	e5 5c       	subi	r30, 0xC5	; 197
    11d8:	fb 4f       	sbci	r31, 0xFB	; 251
    11da:	e4 91       	lpm	r30, Z
    11dc:	ef 31       	cpi	r30, 0x1F	; 31
    11de:	41 f4       	brne	.+16     	; 0x11f0 <getLeftVal(unsigned char)+0x30>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:463
    if (t > COLORTABLEMAX) t = COLORTABLEMAX;
    return pgm_read_byte_near(&leftValues[t]);
    11e0:	80 32       	cpi	r24, 0x20	; 32
    11e2:	08 f0       	brcs	.+2      	; 0x11e6 <getLeftVal(unsigned char)+0x26>
    11e4:	8f e1       	ldi	r24, 0x1F	; 31
    11e6:	e8 2f       	mov	r30, r24
    11e8:	f0 e0       	ldi	r31, 0x00	; 0
    11ea:	e7 50       	subi	r30, 0x07	; 7
    11ec:	fd 4f       	sbci	r31, 0xFD	; 253
    11ee:	84 91       	lpm	r24, Z
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:466
  }
  return t;
}
    11f0:	08 95       	ret

000011f2 <EERef::operator=(unsigned char)>:
operator=():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:83
      :"+d"(in)           // take the value we are writing in any upper register as read/write,
      : "x"(adr)          // and the address (not the index) in X
      : "r30", "r31", "r18");      // clobber Z and r18. We needed an upper register for the temporary value to andi it. I wonder if this will fix the eeprom bugs too?
    return *this;
    #else
    uint8_t oldSREG = SREG;
    11f2:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:84
    while (NVMCTRL.STATUS & NVMCTRL_EEBUSY_bm);
    11f4:	20 91 02 10 	lds	r18, 0x1002	; 0x801002 <__TEXT_REGION_LENGTH__+0x7e1002>
    11f8:	42 2f       	mov	r20, r18
    11fa:	42 70       	andi	r20, 0x02	; 2
    11fc:	21 fd       	sbrc	r18, 1
    11fe:	fa cf       	rjmp	.-12     	; 0x11f4 <EERef::operator=(unsigned char)+0x2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:92
    // during which we *start* the write, not for the while loop, and we save SREG
    // before the while loop. That way there is only a 1 clock window where an
    // interrupt that starts a write will cause this write to halt the CPU
    // which would cause millis() to lose time.
    // Note that writing more than 1 byte in an ISR will **always** cause millis to lose time.
    cli();
    1200:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:94

    _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_NONE_gc);
    1202:	2d e9       	ldi	r18, 0x9D	; 157
    1204:	24 bf       	out	0x34, r18	; 52
    1206:	40 93 00 10 	sts	0x1000, r20	; 0x801000 <__TEXT_REGION_LENGTH__+0x7e1000>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:95
    _PROTECTED_WRITE_SPM(NVMCTRL.CTRLA, NVMCTRL_CMD_EEERWR_gc);
    120a:	43 e1       	ldi	r20, 0x13	; 19
    120c:	24 bf       	out	0x34, r18	; 52
    120e:	40 93 00 10 	sts	0x1000, r20	; 0x801000 <__TEXT_REGION_LENGTH__+0x7e1000>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:96
    *(uint8_t *)(MAPPED_EEPROM_START + (index & EEPROM_INDEX_MASK)) = in;
    1212:	dc 01       	movw	r26, r24
    1214:	ec 91       	ld	r30, X
    1216:	f0 e0       	ldi	r31, 0x00	; 0
    1218:	fc 5e       	subi	r31, 0xEC	; 236
    121a:	60 83       	st	Z, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:98

    SREG = oldSREG; //restore SREG and interrupts
    121c:	3f bf       	out	0x3f, r19	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:101
    return *this;
    #endif
  }
    121e:	08 95       	ret

00001220 <UartClass::begin(unsigned long)>:
begin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.h:97
    volatile uint8_t _rx_buffer[SERIAL_RX_BUFFER_SIZE];
    volatile uint8_t _tx_buffer[SERIAL_TX_BUFFER_SIZE];

 public:
    inline UartClass(volatile USART_t *hwserial_module, uint8_t *usart_pins, uint8_t mux_count, uint8_t mux_defualt);
    void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
    1220:	dc 01       	movw	r26, r24
    1222:	ed 91       	ld	r30, X+
    1224:	fc 91       	ld	r31, X
    1226:	00 88       	ldd	r0, Z+16	; 0x10
    1228:	f1 89       	ldd	r31, Z+17	; 0x11
    122a:	e0 2d       	mov	r30, r0
    122c:	23 e0       	ldi	r18, 0x03	; 3
    122e:	30 e1       	ldi	r19, 0x10	; 16
    1230:	09 94       	ijmp

00001232 <Print::flush()>:
flush():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:88
    size_t println(void);

    int16_t printf(const char *format, ...);
    int16_t printf(const __FlashStringHelper *format, ...);

    virtual void flush() { /* Empty implementation for backward compatibility */ }
    1232:	08 95       	ret

00001234 <digitalRead>:
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    1234:	28 2f       	mov	r18, r24
    1236:	30 e0       	ldi	r19, 0x00	; 0
digitalRead():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:451
}

int8_t digitalRead(uint8_t pin) {
  check_valid_digital_pin(pin);
  /* Get bit mask and check valid pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1238:	89 32       	cpi	r24, 0x29	; 41
    123a:	a8 f4       	brcc	.+42     	; 0x1266 <digitalRead+0x32>
    123c:	f9 01       	movw	r30, r18
    123e:	e9 58       	subi	r30, 0x89	; 137
    1240:	ff 4b       	sbci	r31, 0xBF	; 191
    1242:	80 81       	ld	r24, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:452
  if (bit_mask == NOT_A_PIN) {
    1244:	8f 3f       	cpi	r24, 0xFF	; 255
    1246:	79 f0       	breq	.+30     	; 0x1266 <digitalRead+0x32>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:465
  // high bar for stuff that would make it even slower than it already is.
  //
  // turnOffPWM(pin);

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);
    1248:	20 56       	subi	r18, 0x60	; 96
    124a:	3f 4b       	sbci	r19, 0xBF	; 191
    124c:	d9 01       	movw	r26, r18
    124e:	ec 91       	ld	r30, X
    1250:	b0 e2       	ldi	r27, 0x20	; 32
    1252:	eb 9f       	mul	r30, r27
    1254:	f0 01       	movw	r30, r0
    1256:	11 24       	eor	r1, r1
    1258:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:468

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
    125a:	90 85       	ldd	r25, Z+8	; 0x08
    125c:	98 23       	and	r25, r24
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	19 f4       	brne	.+6      	; 0x1268 <digitalRead+0x34>
    1262:	80 e0       	ldi	r24, 0x00	; 0
    1264:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:453
int8_t digitalRead(uint8_t pin) {
  check_valid_digital_pin(pin);
  /* Get bit mask and check valid pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
  if (bit_mask == NOT_A_PIN) {
    return -1;
    1266:	8f ef       	ldi	r24, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:473
  if (port->IN & bit_mask) {
    return HIGH;
  } else {
    return LOW;
  }
}
    1268:	08 95       	ret

0000126a <digitalWrite>:
digitalWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:348
  default:
    break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
    126a:	0f 93       	push	r16
    126c:	1f 93       	push	r17
    126e:	cf 93       	push	r28
    1270:	df 93       	push	r29
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:351
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1272:	89 32       	cpi	r24, 0x29	; 41
    1274:	08 f0       	brcs	.+2      	; 0x1278 <digitalWrite+0xe>
    1276:	7c c0       	rjmp	.+248    	; 0x1370 <digitalWrite+0x106>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    1278:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:351
}

void digitalWrite(uint8_t pin, uint8_t val) {
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
    127a:	dc 01       	movw	r26, r24
    127c:	a9 58       	subi	r26, 0x89	; 137
    127e:	bf 4b       	sbci	r27, 0xBF	; 191
    1280:	2c 91       	ld	r18, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:352
  if (bit_mask == NOT_A_PIN) {
    1282:	2f 3f       	cpi	r18, 0xFF	; 255
    1284:	09 f4       	brne	.+2      	; 0x1288 <digitalWrite+0x1e>
    1286:	74 c0       	rjmp	.+232    	; 0x1370 <digitalWrite+0x106>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:357
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
    1288:	8c 01       	movw	r16, r24
    128a:	00 56       	subi	r16, 0x60	; 96
    128c:	1f 4b       	sbci	r17, 0xBF	; 191
    128e:	e8 01       	movw	r28, r16
    1290:	e8 81       	ld	r30, Y
    1292:	d0 e2       	ldi	r29, 0x20	; 32
    1294:	ed 9f       	mul	r30, r29
    1296:	f0 01       	movw	r30, r0
    1298:	11 24       	eor	r1, r1
    129a:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:365
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    129c:	61 11       	cpse	r22, r1
    129e:	33 c0       	rjmp	.+102    	; 0x1306 <digitalWrite+0x9c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:366
    port->OUTCLR = bit_mask;
    12a0:	26 83       	std	Z+6, r18	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:381
    // val will now be 0 (LOW) if the toggling made it LOW
    // or 1 (HIGH) otherwise.
  } else { /* If HIGH OR  > TOGGLE  */
    port->OUTSET = bit_mask;
  }
  if (!(port->DIR & bit_mask)) { /* Input direction */
    12a2:	30 81       	ld	r19, Z
    12a4:	23 23       	and	r18, r19
    12a6:	ac 01       	movw	r20, r24
    12a8:	4c 5c       	subi	r20, 0xCC	; 204
    12aa:	5f 4b       	sbci	r21, 0xBF	; 191
    12ac:	21 11       	cpse	r18, r1
    12ae:	11 c0       	rjmp	.+34     	; 0x12d2 <digitalWrite+0x68>
    12b0:	ea 01       	movw	r28, r20
    12b2:	28 81       	ld	r18, Y
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:392
     *
     * Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
    12b4:	30 97       	sbiw	r30, 0x00	; 0
    12b6:	49 f1       	breq	.+82     	; 0x130a <digitalWrite+0xa0>
    12b8:	2f 3f       	cpi	r18, 0xFF	; 255
    12ba:	39 f1       	breq	.+78     	; 0x130a <digitalWrite+0xa0>
    12bc:	70 96       	adiw	r30, 0x10	; 16
    12be:	e2 0f       	add	r30, r18
    12c0:	f1 1d       	adc	r31, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:394

    uint8_t status = SREG;                /* Save system status and disable interrupts */
    12c2:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:395
    cli();
    12c4:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:397
    if (val == LOW) {                     /* We set it LOW so turn them off */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm; /* Disable pull-up */
    12c6:	20 81       	ld	r18, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:396
    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    uint8_t status = SREG;                /* Save system status and disable interrupts */
    cli();
    if (val == LOW) {                     /* We set it LOW so turn them off */
    12c8:	61 11       	cpse	r22, r1
    12ca:	22 c0       	rjmp	.+68     	; 0x1310 <digitalWrite+0xa6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:397
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm; /* Disable pull-up */
    12cc:	27 7f       	andi	r18, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:399
    } else {                              /* We set it HIGH so turn them on */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;  /* Enable pull-up  */
    12ce:	20 83       	st	Z, r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:402
    }

    SREG = status; /* Restore system status */
    12d0:	3f bf       	out	0x3f, r19	; 63
digitalPinToTimerNow():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:739
  badCall("Resuming core control of type D timer not supported.");
}


uint8_t digitalPinToTimerNow(uint8_t p) {
  uint8_t bit_pos = digitalPinToBitPosition(p);
    12d2:	fa 01       	movw	r30, r20
    12d4:	30 81       	ld	r19, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:740
  if (bit_pos == NOT_A_PIN) return NOT_ON_TIMER;     /* Use bit position to check for invalid pins */
    12d6:	3f 3f       	cpi	r19, 0xFF	; 255
    12d8:	09 f4       	brne	.+2      	; 0x12dc <digitalWrite+0x72>
    12da:	4a c0       	rjmp	.+148    	; 0x1370 <digitalWrite+0x106>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:741
  uint8_t port = digitalPinToPort(p);                /* If bit_pos is valid, port will be too      */
    12dc:	e8 01       	movw	r28, r16
    12de:	28 81       	ld	r18, Y
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:742
  if ( bit_pos < 6) {                                /* SPLIT MODE TCA output is on pins 0-5       */
    12e0:	36 30       	cpi	r19, 0x06	; 6
    12e2:	58 f5       	brcc	.+86     	; 0x133a <digitalWrite+0xd0>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:744
  #if defined(TCA1)
    uint8_t tcamux = PORTMUX.TCAROUTEA;
    12e4:	30 91 e6 05 	lds	r19, 0x05E6	; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:746
    if ( PeripheralControl & TIMERA0) {              /* make sure user hasn't taken over TCA0      */
      if (((tcamux & PORTMUX_TCA0_gm) == port)) {    /* TCA0 mux is EASY - same as the port number */
    12e8:	43 2f       	mov	r20, r19
    12ea:	47 70       	andi	r20, 0x07	; 7
    12ec:	24 13       	cpse	r18, r20
    12ee:	12 c0       	rjmp	.+36     	; 0x1314 <digitalWrite+0xaa>
turnOffPWM():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:262
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  //uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    12f0:	ec 91       	ld	r30, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:271
  switch (timer) {

  /* TCA0 */
  case TIMERA0:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; //there's a blank bit in the middle
    12f2:	e5 30       	cpi	r30, 0x05	; 5
    12f4:	08 f0       	brcs	.+2      	; 0x12f8 <digitalWrite+0x8e>
    12f6:	ee 0f       	add	r30, r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:273
    /* Disable corresponding channel */
    TCA0.SPLIT.CTRLB &= ~bit_mask;
    12f8:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7e0a01>
    12fc:	e0 95       	com	r30
    12fe:	e8 23       	and	r30, r24
    1300:	e0 93 01 0a 	sts	0x0A01, r30	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7e0a01>
    1304:	35 c0       	rjmp	.+106    	; 0x1370 <digitalWrite+0x106>
digitalWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:379
    val = !(port->OUT & bit_mask);
    port->OUTTGL = bit_mask;
    // val will now be 0 (LOW) if the toggling made it LOW
    // or 1 (HIGH) otherwise.
  } else { /* If HIGH OR  > TOGGLE  */
    port->OUTSET = bit_mask;
    1306:	25 83       	std	Z+5, r18	; 0x05
    1308:	cc cf       	rjmp	.-104    	; 0x12a2 <digitalWrite+0x38>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:392
     *
     * Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
    130a:	f0 e0       	ldi	r31, 0x00	; 0
    130c:	e0 e0       	ldi	r30, 0x00	; 0
    130e:	d9 cf       	rjmp	.-78     	; 0x12c2 <digitalWrite+0x58>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:399
    uint8_t status = SREG;                /* Save system status and disable interrupts */
    cli();
    if (val == LOW) {                     /* We set it LOW so turn them off */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm; /* Disable pull-up */
    } else {                              /* We set it HIGH so turn them on */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;  /* Enable pull-up  */
    1310:	28 60       	ori	r18, 0x08	; 8
    1312:	dd cf       	rjmp	.-70     	; 0x12ce <digitalWrite+0x64>
digitalPinToTimerNow():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:750
        return TIMERA0;
      }
    }
    tcamux &= 0x18;
    1314:	38 71       	andi	r19, 0x18	; 24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:752
    if (PeripheralControl & TIMERA1) {               /* make sure user hasn't taken over TCA0      */
      if ((tcamux == 0 && port == PB ) || (tcamux == 0x18 && port == PG)) { /* supports only 6-ch  */
    1316:	69 f4       	brne	.+26     	; 0x1332 <digitalWrite+0xc8>
    1318:	21 30       	cpi	r18, 0x01	; 1
    131a:	79 f4       	brne	.+30     	; 0x133a <digitalWrite+0xd0>
turnOffPWM():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:262
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  //uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    131c:	ec 91       	ld	r30, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:278
    TCA0.SPLIT.CTRLB &= ~bit_mask;
    break;
  #ifdef TCA1
  case TIMERA1:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; //there's a blank bit in the middle
    131e:	e5 30       	cpi	r30, 0x05	; 5
    1320:	08 f0       	brcs	.+2      	; 0x1324 <digitalWrite+0xba>
    1322:	ee 0f       	add	r30, r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:280
    /* Disable corresponding channel */
    TCA1.SPLIT.CTRLB &= ~bit_mask;
    1324:	80 91 41 0a 	lds	r24, 0x0A41	; 0x800a41 <__TEXT_REGION_LENGTH__+0x7e0a41>
    1328:	e0 95       	com	r30
    132a:	e8 23       	and	r30, r24
    132c:	e0 93 41 0a 	sts	0x0A41, r30	; 0x800a41 <__TEXT_REGION_LENGTH__+0x7e0a41>
    1330:	1f c0       	rjmp	.+62     	; 0x1370 <digitalWrite+0x106>
digitalPinToTimerNow():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:752
    1332:	38 31       	cpi	r19, 0x18	; 24
    1334:	11 f4       	brne	.+4      	; 0x133a <digitalWrite+0xd0>
    1336:	26 30       	cpi	r18, 0x06	; 6
    1338:	89 f3       	breq	.-30     	; 0x131c <digitalWrite+0xb2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:764
        return TIMERA0;
      }
    }
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);
    133a:	85 5f       	subi	r24, 0xF5	; 245
    133c:	9f 4b       	sbci	r25, 0xBF	; 191
    133e:	fc 01       	movw	r30, r24
    1340:	80 81       	ld	r24, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:775
        return TIMERD0;
      }

  }
  */
  if (timer & TIMERB0) { /* Finally check TCBn, if we made it here w/out returning */
    1342:	85 ff       	sbrs	r24, 5
    1344:	13 c0       	rjmp	.+38     	; 0x136c <digitalWrite+0x102>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:777
    TCB_t* timer_B;
    timer_B = ((TCB_t *)&TCB0 + (timer - TIMERB0)); /* get timer struct */
    1346:	30 e1       	ldi	r19, 0x10	; 16
    1348:	83 9f       	mul	r24, r19
    134a:	f0 01       	movw	r30, r0
    134c:	11 24       	eor	r1, r1
    134e:	f7 5f       	subi	r31, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:778
    if (((timer_B->CTRLB) &  TCB_CNTMODE_gm) != TCB_CNTMODE_PWM8_gc )
    1350:	91 81       	ldd	r25, Z+1	; 0x01
    1352:	97 70       	andi	r25, 0x07	; 7
    1354:	97 30       	cpi	r25, 0x07	; 7
    1356:	61 f4       	brne	.+24     	; 0x1370 <digitalWrite+0x106>
turnOffPWM():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:262
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  //uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1358:	ec 91       	ld	r30, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:266
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
    135a:	85 32       	cpi	r24, 0x25	; 37
    135c:	70 f4       	brcc	.+28     	; 0x137a <digitalWrite+0x110>
    135e:	80 32       	cpi	r24, 0x20	; 32
    1360:	98 f4       	brcc	.+38     	; 0x1388 <digitalWrite+0x11e>
    1362:	88 30       	cpi	r24, 0x08	; 8
    1364:	e1 f2       	breq	.-72     	; 0x131e <digitalWrite+0xb4>
    1366:	80 31       	cpi	r24, 0x10	; 16
    1368:	21 f2       	breq	.-120    	; 0x12f2 <digitalWrite+0x88>
    136a:	02 c0       	rjmp	.+4      	; 0x1370 <digitalWrite+0x106>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:259
{
  /* Actually turn off compare channel, not the timer */

  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;
    136c:	81 11       	cpse	r24, r1
    136e:	f4 cf       	rjmp	.-24     	; 0x1358 <digitalWrite+0xee>
digitalWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:416
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to?
   */
  turnOffPWM(pin);
}
    1370:	df 91       	pop	r29
    1372:	cf 91       	pop	r28
    1374:	1f 91       	pop	r17
    1376:	0f 91       	pop	r16
    1378:	08 95       	ret
turnOffPWM():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:266
  //uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
    137a:	80 34       	cpi	r24, 0x40	; 64
    137c:	71 f0       	breq	.+28     	; 0x139a <digitalWrite+0x130>
    137e:	80 38       	cpi	r24, 0x80	; 128
    1380:	b9 f7       	brne	.-18     	; 0x1370 <digitalWrite+0x106>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:298
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);

    break;
  #if defined(DAC0)
  case DACOUT:
    DAC0.CTRLA = 0x00;
    1382:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7e06a0>
    1386:	f4 cf       	rjmp	.-24     	; 0x1370 <digitalWrite+0x106>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:290
  case TIMERB1:
  case TIMERB2:
  case TIMERB3:
  case TIMERB4:

    timerB = (TCB_t *) &TCB0 + (timer - TIMERB0);
    1388:	90 e1       	ldi	r25, 0x10	; 16
    138a:	89 9f       	mul	r24, r25
    138c:	f0 01       	movw	r30, r0
    138e:	11 24       	eor	r1, r1
    1390:	f7 5f       	subi	r31, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:293

     //Disable TCB compare channel
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);
    1392:	81 81       	ldd	r24, Z+1	; 0x01
    1394:	8f 7e       	andi	r24, 0xEF	; 239
    1396:	81 83       	std	Z+1, r24	; 0x01
    1398:	eb cf       	rjmp	.-42     	; 0x1370 <digitalWrite+0x106>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:313
      #else
        // on the DA series, it could be any of them
        #ifndef ERRATA_TCD_PORTMUX
          uint8_t fcset = TCD0.FAULTCTRL & (bit_mask > 0x0F ? bit_mask : bit_mask << 4 ); //hopefully that gets rendereed as swap, not 4 leftshifts
        #else
          uint8_t fcset = TCD0.FAULTCTRL & bit_mask;
    139a:	80 91 92 0b 	lds	r24, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
    139e:	8e 23       	and	r24, r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:316
        #endif
      #endif
      if (fcset) {
    13a0:	39 f3       	breq	.-50     	; 0x1370 <digitalWrite+0x106>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:321
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
    13a2:	c0 e2       	ldi	r28, 0x20	; 32
    13a4:	2c 9f       	mul	r18, r28
    13a6:	90 01       	movw	r18, r0
    13a8:	11 24       	eor	r1, r1
    13aa:	3c 5f       	subi	r19, 0xFC	; 252
    13ac:	ef 3f       	cpi	r30, 0xFF	; 255
    13ae:	31 f1       	breq	.+76     	; 0x13fc <digitalWrite+0x192>
    13b0:	20 5f       	subi	r18, 0xF0	; 240
    13b2:	3f 4f       	sbci	r19, 0xFF	; 255
    13b4:	e2 0f       	add	r30, r18
    13b6:	f3 2f       	mov	r31, r19
    13b8:	f1 1d       	adc	r31, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:327
          // at least get it before disablling interrupts.
        #endif
        // This is slightly dangerous - if the timer isn't running, it will start the timer. But it will only do any of that if
        // it was currently set to output PWM, so it's very hard to imagine triggering it with just innocent calls to digitalWrite
        // in a constructor - we do not promise core functions will behave if users are reconfiguring peripherals in arbitrary ways.
        uint8_t oldSREG = SREG;
    13ba:	4f b7       	in	r20, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:328
        cli();
    13bc:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:329
        TCD0.CTRLA &= ~TCD_ENABLE_bm; // stop the timer
    13be:	90 91 80 0b 	lds	r25, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
    13c2:	9e 7f       	andi	r25, 0xFE	; 254
    13c4:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:331
        // Experimentally found ENRDY must be set set to configure FAULTCTRL
        while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
    13c8:	90 91 8e 0b 	lds	r25, 0x0B8E	; 0x800b8e <__TEXT_REGION_LENGTH__+0x7e0b8e>
    13cc:	90 ff       	sbrs	r25, 0
    13ce:	fc cf       	rjmp	.-8      	; 0x13c8 <digitalWrite+0x15e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:332
        _PROTECTED_WRITE(TCD0.FAULTCTRL,TCD0.FAULTCTRL & ~fcset);
    13d0:	20 91 92 0b 	lds	r18, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	80 95       	com	r24
    13d8:	90 95       	com	r25
    13da:	30 e0       	ldi	r19, 0x00	; 0
    13dc:	82 23       	and	r24, r18
    13de:	93 23       	and	r25, r19
    13e0:	28 ed       	ldi	r18, 0xD8	; 216
    13e2:	24 bf       	out	0x34, r18	; 52
    13e4:	80 93 92 0b 	sts	0x0B92, r24	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:334
        //while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
        TCD0.CTRLA |= TCD_ENABLE_bm;  // re-enable it
    13e8:	80 91 80 0b 	lds	r24, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
    13ec:	81 60       	ori	r24, 0x01	; 1
    13ee:	80 93 80 0b 	sts	0x0B80, r24	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:336
        #if defined(NO_GLITCH_TIMERD0)
          *pin_ctrl_reg &= ~(PORT_INVEN_bm);
    13f2:	80 81       	ld	r24, Z
    13f4:	8f 77       	andi	r24, 0x7F	; 127
    13f6:	80 83       	st	Z, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:338
        #endif
        SREG = oldSREG;
    13f8:	4f bf       	out	0x3f, r20	; 63
    13fa:	ba cf       	rjmp	.-140    	; 0x1370 <digitalWrite+0x106>
digitalWrite():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:321
      if (fcset) {
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
    13fc:	f0 e0       	ldi	r31, 0x00	; 0
    13fe:	e0 e0       	ldi	r30, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:418
// ================================
// === internal class functions ===
// ================================

// write4bits() - set the 4 hd44780 data lines
void write4bits(uint8_t value)
    1400:	dc cf       	rjmp	.-72     	; 0x13ba <digitalWrite+0x150>

00001402 <hd44780_pinIO::write4bits(unsigned char)>:
write4bits():
    1402:	0f 93       	push	r16
    1404:	1f 93       	push	r17
    1406:	cf 93       	push	r28
    1408:	8c 01       	movw	r16, r24
    140a:	c6 2f       	mov	r28, r22
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:422
{
	// write the bits on the LCD data lines but don't send the data
	if(value & 1)
		digitalWrite(_d4, HIGH);
    140c:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:421

// write4bits() - set the 4 hd44780 data lines
void write4bits(uint8_t value)
{
	// write the bits on the LCD data lines but don't send the data
	if(value & 1)
    140e:	83 a1       	ldd	r24, Z+35	; 0x23
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:424
		digitalWrite(_d4, HIGH);
	else
		digitalWrite(_d4, LOW);
    1410:	61 e0       	ldi	r22, 0x01	; 1
    1412:	c0 ff       	sbrs	r28, 0
    1414:	60 e0       	ldi	r22, 0x00	; 0
    1416:	29 df       	rcall	.-430    	; 0x126a <digitalWrite>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:427

	if(value & 2)
		digitalWrite(_d5, HIGH);
    1418:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:426
	if(value & 1)
		digitalWrite(_d4, HIGH);
	else
		digitalWrite(_d4, LOW);

	if(value & 2)
    141a:	84 a1       	ldd	r24, Z+36	; 0x24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:429
		digitalWrite(_d5, HIGH);
	else
		digitalWrite(_d5, LOW);
    141c:	61 e0       	ldi	r22, 0x01	; 1
    141e:	c1 ff       	sbrs	r28, 1
    1420:	60 e0       	ldi	r22, 0x00	; 0
    1422:	23 df       	rcall	.-442    	; 0x126a <digitalWrite>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:432

	if(value & 4)
		digitalWrite(_d6, HIGH);
    1424:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:431
	if(value & 2)
		digitalWrite(_d5, HIGH);
	else
		digitalWrite(_d5, LOW);

	if(value & 4)
    1426:	85 a1       	ldd	r24, Z+37	; 0x25
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:434
		digitalWrite(_d6, HIGH);
	else
		digitalWrite(_d6, LOW);
    1428:	61 e0       	ldi	r22, 0x01	; 1
    142a:	c2 ff       	sbrs	r28, 2
    142c:	60 e0       	ldi	r22, 0x00	; 0
    142e:	1d df       	rcall	.-454    	; 0x126a <digitalWrite>
    1430:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:437

	if(value & 8)
		digitalWrite(_d7, HIGH);
    1432:	86 a1       	ldd	r24, Z+38	; 0x26
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:436
	if(value & 4)
		digitalWrite(_d6, HIGH);
	else
		digitalWrite(_d6, LOW);

	if(value & 8)
    1434:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:439
		digitalWrite(_d7, HIGH);
	else
		digitalWrite(_d7, LOW);
    1436:	c3 ff       	sbrs	r28, 3
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:440
}
    1438:	60 e0       	ldi	r22, 0x00	; 0
    143a:	cf 91       	pop	r28
    143c:	1f 91       	pop	r17
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:439
		digitalWrite(_d6, LOW);

	if(value & 8)
		digitalWrite(_d7, HIGH);
	else
		digitalWrite(_d7, LOW);
    143e:	0f 91       	pop	r16
    1440:	14 cf       	rjmp	.-472    	; 0x126a <digitalWrite>

00001442 <hd44780_pinIO::iowrite(hd44780::iotype, unsigned char)>:
iowrite():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:307
}


// iowrite(type, value) - send either a command or data byte to lcd
// returns zero on success, non zero on failure
int iowrite(hd44780::iotype type, uint8_t value)
    1442:	4f 92       	push	r4
    1444:	5f 92       	push	r5
    1446:	6f 92       	push	r6
    1448:	7f 92       	push	r7
    144a:	8f 92       	push	r8
    144c:	9f 92       	push	r9
    144e:	af 92       	push	r10
    1450:	bf 92       	push	r11
    1452:	ef 92       	push	r14
    1454:	ff 92       	push	r15
    1456:	1f 93       	push	r17
    1458:	cf 93       	push	r28
    145a:	df 93       	push	r29
    145c:	ec 01       	movw	r28, r24
    145e:	7b 01       	movw	r14, r22
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:310
{
	if(type == hd44780::HD44780_IOdata)
  		digitalWrite(_rs, HIGH);
    1460:	14 2f       	mov	r17, r20
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:309

// iowrite(type, value) - send either a command or data byte to lcd
// returns zero on success, non zero on failure
int iowrite(hd44780::iotype type, uint8_t value)
{
	if(type == hd44780::HD44780_IOdata)
    1462:	88 a1       	ldd	r24, Y+32	; 0x20
    1464:	61 e0       	ldi	r22, 0x01	; 1
    1466:	91 e0       	ldi	r25, 0x01	; 1
    1468:	e9 16       	cp	r14, r25
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:312
  		digitalWrite(_rs, HIGH);
	else
  		digitalWrite(_rs, LOW);
    146a:	f1 04       	cpc	r15, r1
    146c:	09 f0       	breq	.+2      	; 0x1470 <hd44780_pinIO::iowrite(hd44780::iotype, unsigned char)+0x2e>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:326
	// note:
	// waitReady() is explicitly called as late as possible *after* the Arduino
	// pins for the LCD control and data signals are set to allow
	// overhead of the digitalWrite() calls to be hidden under execution time.
	
	write4bits(value>>4);	// setup uppper nibble d4-d7 lcd pins
    146e:	60 e0       	ldi	r22, 0x00	; 0
    1470:	fc de       	rcall	.-520    	; 0x126a <digitalWrite>
    1472:	61 2f       	mov	r22, r17
    1474:	70 e0       	ldi	r23, 0x00	; 0
    1476:	84 e0       	ldi	r24, 0x04	; 4
    1478:	75 95       	asr	r23
    147a:	67 95       	ror	r22
    147c:	8a 95       	dec	r24
    147e:	e1 f7       	brne	.-8      	; 0x1478 <hd44780_pinIO::iowrite(hd44780::iotype, unsigned char)+0x36>
    1480:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:375
	uint8_t _displaymode;
	uint8_t _cols;
	uint8_t _rows;

	// wait for lcd to be ready
	inline void waitReady() {_waitReady((_startTime), _execTime);}
    1482:	bf df       	rcall	.-130    	; 0x1402 <hd44780_pinIO::write4bits(unsigned char)>
waitReady():
    1484:	8c 8c       	ldd	r8, Y+28	; 0x1c
    1486:	9d 8c       	ldd	r9, Y+29	; 0x1d
    1488:	ae 8c       	ldd	r10, Y+30	; 0x1e
    148a:	bf 8c       	ldd	r11, Y+31	; 0x1f
    148c:	48 8c       	ldd	r4, Y+24	; 0x18
    148e:	59 8c       	ldd	r5, Y+25	; 0x19
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:379
	inline void waitReady(int32_t offsetUs) {_waitReady((_startTime+offsetUs), _execTime);}

	inline void _waitReady(uint32_t _stime, uint32_t _etime)
		{while(( ((uint32_t)micros()) - _stime) < _etime){}}
    1490:	6a 8c       	ldd	r6, Y+26	; 0x1a
    1492:	7b 8c       	ldd	r7, Y+27	; 0x1b
_ZN7hd4478010_waitReadyEmm.isra.0():
    1494:	41 dc       	rcall	.-1918   	; 0xd18 <micros>
    1496:	64 19       	sub	r22, r4
    1498:	75 09       	sbc	r23, r5
    149a:	86 09       	sbc	r24, r6
    149c:	97 09       	sbc	r25, r7
    149e:	68 15       	cp	r22, r8
    14a0:	79 05       	cpc	r23, r9
    14a2:	8a 05       	cpc	r24, r10
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:445
}

// pulseEnable() - toggle en to send data to hd44780 module
void pulseEnable(void)
{
	digitalWrite(_en, HIGH);
    14a4:	9b 05       	cpc	r25, r11
    14a6:	b0 f3       	brcs	.-20     	; 0x1494 <hd44780_pinIO::iowrite(hd44780::iotype, unsigned char)+0x52>
_ZN13hd44780_pinIO11pulseEnableEv.isra.2():
    14a8:	61 e0       	ldi	r22, 0x01	; 1
    14aa:	8a a1       	ldd	r24, Y+34	; 0x22
c:\arduino-1.8.13\hardware\tools\avr\avr\include\util/delay.h:276
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    14ac:	de de       	rcall	.-580    	; 0x126a <digitalWrite>
_delay_us():
    14ae:	88 e0       	ldi	r24, 0x08	; 8
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:458
	// to always do it.
	delayMicroseconds(2);    // enable pulse must be >450ns
#else
	delayMicroseconds(1);    // enable pulse must be >450ns
#endif
	digitalWrite(_en, LOW);
    14b0:	8a 95       	dec	r24
    14b2:	f1 f7       	brne	.-4      	; 0x14b0 <hd44780_pinIO::iowrite(hd44780::iotype, unsigned char)+0x6e>
_ZN13hd44780_pinIO11pulseEnableEv.isra.2():
    14b4:	60 e0       	ldi	r22, 0x00	; 0
    14b6:	8a a1       	ldd	r24, Y+34	; 0x22
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:332
	waitReady();			// ensure previous instruction finished
	pulseEnable();			// send upper nibble to LCD

	// send lower nibble if not a 4 bit command
	// (sends nibble for both data and "normal" commands)
	if (type != hd44780::HD44780_IOcmd4bit )
    14b8:	d8 de       	rcall	.-592    	; 0x126a <digitalWrite>
iowrite():
    14ba:	92 e0       	ldi	r25, 0x02	; 2
    14bc:	e9 16       	cp	r14, r25
    14be:	f1 04       	cpc	r15, r1
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:334
	{
		write4bits((value & 0x0F));// setup lower nibble on d4-d7 lcd pins
    14c0:	69 f0       	breq	.+26     	; 0x14dc <hd44780_pinIO::iowrite(hd44780::iotype, unsigned char)+0x9a>
    14c2:	61 2f       	mov	r22, r17
    14c4:	6f 70       	andi	r22, 0x0F	; 15
    14c6:	ce 01       	movw	r24, r28
    14c8:	9c df       	rcall	.-200    	; 0x1402 <hd44780_pinIO::write4bits(unsigned char)>
_ZN13hd44780_pinIO11pulseEnableEv.isra.2():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:445
}

// pulseEnable() - toggle en to send data to hd44780 module
void pulseEnable(void)
{
	digitalWrite(_en, HIGH);
    14ca:	61 e0       	ldi	r22, 0x01	; 1
    14cc:	8a a1       	ldd	r24, Y+34	; 0x22
    14ce:	cd de       	rcall	.-614    	; 0x126a <digitalWrite>
_delay_us():
    14d0:	88 e0       	ldi	r24, 0x08	; 8
c:\arduino-1.8.13\hardware\tools\avr\avr\include\util/delay.h:276
    14d2:	8a 95       	dec	r24
    14d4:	f1 f7       	brne	.-4      	; 0x14d2 <hd44780_pinIO::iowrite(hd44780::iotype, unsigned char)+0x90>
_ZN13hd44780_pinIO11pulseEnableEv.isra.2():
    14d6:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:458
	// to always do it.
	delayMicroseconds(2);    // enable pulse must be >450ns
#else
	delayMicroseconds(1);    // enable pulse must be >450ns
#endif
	digitalWrite(_en, LOW);
    14d8:	8a a1       	ldd	r24, Y+34	; 0x22
    14da:	c7 de       	rcall	.-626    	; 0x126a <digitalWrite>
iowrite():
    14dc:	90 e0       	ldi	r25, 0x00	; 0
    14de:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:338
	{
		write4bits((value & 0x0F));// setup lower nibble on d4-d7 lcd pins
		pulseEnable();				// send lower nibble to LCD
	}
	return(hd44780::RV_ENOERR); // it never fails
}
    14e0:	df 91       	pop	r29
    14e2:	cf 91       	pop	r28
    14e4:	1f 91       	pop	r17
    14e6:	ff 90       	pop	r15
    14e8:	ef 90       	pop	r14
    14ea:	bf 90       	pop	r11
    14ec:	af 90       	pop	r10
    14ee:	9f 90       	pop	r9
    14f0:	8f 90       	pop	r8
    14f2:	7f 90       	pop	r7
    14f4:	6f 90       	pop	r6
    14f6:	5f 90       	pop	r5
    14f8:	4f 90       	pop	r4
    14fa:	08 95       	ret

000014fc <hd44780::command4bit(unsigned char) [clone .constprop.15]>:
command4bit():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:404
	uint32_t _insExecTime;	// time in Us of execution time for instructions or data
	uint32_t _startTime;	// 'start' time of last thing sent to LCD (cmd or data)
	uint32_t _execTime;		// execution time in Us of last thing sent to LCD (cmd or data)

	// internal API function to send only upper 4 bits of byte on LCD DB4 to DB7 pins
	int command4bit(uint8_t value)
    14fc:	cf 92       	push	r12
    14fe:	df 92       	push	r13
    1500:	ef 92       	push	r14
    1502:	ff 92       	push	r15
    1504:	0f 93       	push	r16
    1506:	1f 93       	push	r17
    1508:	cf 93       	push	r28
    150a:	df 93       	push	r29
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:406
	{
	int status = iowrite(HD44780_IOcmd4bit, value);
    150c:	48 2f       	mov	r20, r24
    150e:	62 e0       	ldi	r22, 0x02	; 2
    1510:	70 e0       	ldi	r23, 0x00	; 0
    1512:	85 e1       	ldi	r24, 0x15	; 21
    1514:	9e e4       	ldi	r25, 0x4E	; 78
    1516:	95 df       	rcall	.-214    	; 0x1442 <hd44780_pinIO::iowrite(hd44780::iotype, unsigned char)>
    1518:	8c 01       	movw	r16, r24
    151a:	c5 e1       	ldi	r28, 0x15	; 21
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:407
		markStart(_insExecTime);
    151c:	de e4       	ldi	r29, 0x4E	; 78
    151e:	cc 88       	ldd	r12, Y+20	; 0x14
    1520:	dd 88       	ldd	r13, Y+21	; 0x15
    1522:	ee 88       	ldd	r14, Y+22	; 0x16
    1524:	ff 88       	ldd	r15, Y+23	; 0x17
markStart():
    1526:	f8 db       	rcall	.-2064   	; 0xd18 <micros>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:397
	virtual int iosetContrast(uint8_t contvalue){if(contvalue) return(RV_ENOTSUP); else return(RV_ENOTSUP);}// optional

	uint8_t _rowOffsets[4]; // memory address of start of each row/line

	// stuff for tracking execution times
	inline void markStart(uint32_t exectime) { _startTime = (uint32_t) micros(); _execTime = exectime;}
    1528:	68 8f       	std	Y+24, r22	; 0x18
    152a:	79 8f       	std	Y+25, r23	; 0x19
    152c:	8a 8f       	std	Y+26, r24	; 0x1a
    152e:	9b 8f       	std	Y+27, r25	; 0x1b
    1530:	cc 8e       	std	Y+28, r12	; 0x1c
    1532:	dd 8e       	std	Y+29, r13	; 0x1d
    1534:	ee 8e       	std	Y+30, r14	; 0x1e
    1536:	ff 8e       	std	Y+31, r15	; 0x1f
command4bit():
    1538:	c8 01       	movw	r24, r16
    153a:	df 91       	pop	r29
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:409
	int command4bit(uint8_t value)
	{
	int status = iowrite(HD44780_IOcmd4bit, value);
		markStart(_insExecTime);
		return(status);
	}
    153c:	cf 91       	pop	r28
    153e:	1f 91       	pop	r17
    1540:	0f 91       	pop	r16
    1542:	ff 90       	pop	r15
    1544:	ef 90       	pop	r14
    1546:	df 90       	pop	r13
    1548:	cf 90       	pop	r12
    154a:	08 95       	ret

0000154c <hd44780_pinIO::ioread(hd44780::iotype)>:
ioread():
    154c:	8f 92       	push	r8
    154e:	9f 92       	push	r9
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:206
//
// returns:
// 	success:  8 bit value read
// 	failure: negative value: reading not supported
//
int ioread(hd44780::iotype type) 
    1550:	af 92       	push	r10
    1552:	bf 92       	push	r11
    1554:	cf 92       	push	r12
    1556:	df 92       	push	r13
    1558:	ef 92       	push	r14
    155a:	ff 92       	push	r15
    155c:	0f 93       	push	r16
    155e:	1f 93       	push	r17
    1560:	cf 93       	push	r28
    1562:	df 93       	push	r29
    1564:	dc 01       	movw	r26, r24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:211
{
uint8_t data = 0;

	// check if r/w control supported
	if(_rw == 0xff)
    1566:	91 96       	adiw	r26, 0x21	; 33
    1568:	2c 91       	ld	r18, X
    156a:	2f 3f       	cpi	r18, 0xFF	; 255
    156c:	09 f4       	brne	.+2      	; 0x1570 <hd44780_pinIO::ioread(hd44780::iotype)+0x24>
    156e:	5e c1       	rjmp	.+700    	; 0x182c <hd44780_pinIO::ioread(hd44780::iotype)+0x2e0>
    1570:	8b 01       	movw	r16, r22
    1572:	ec 01       	movw	r28, r24
waitReady():
    1574:	cc 8c       	ldd	r12, Y+28	; 0x1c
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:375
	uint8_t _displaymode;
	uint8_t _cols;
	uint8_t _rows;

	// wait for lcd to be ready
	inline void waitReady() {_waitReady((_startTime), _execTime);}
    1576:	dd 8c       	ldd	r13, Y+29	; 0x1d
    1578:	ee 8c       	ldd	r14, Y+30	; 0x1e
    157a:	ff 8c       	ldd	r15, Y+31	; 0x1f
    157c:	88 8c       	ldd	r8, Y+24	; 0x18
    157e:	99 8c       	ldd	r9, Y+25	; 0x19
    1580:	aa 8c       	ldd	r10, Y+26	; 0x1a
    1582:	bb 8c       	ldd	r11, Y+27	; 0x1b
_ZN7hd4478010_waitReadyEmm.isra.0():
    1584:	c9 db       	rcall	.-2158   	; 0xd18 <micros>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:379
	inline void waitReady(int32_t offsetUs) {_waitReady((_startTime+offsetUs), _execTime);}

	inline void _waitReady(uint32_t _stime, uint32_t _etime)
		{while(( ((uint32_t)micros()) - _stime) < _etime){}}
    1586:	68 19       	sub	r22, r8
    1588:	79 09       	sbc	r23, r9
    158a:	8a 09       	sbc	r24, r10
    158c:	9b 09       	sbc	r25, r11
    158e:	6c 15       	cp	r22, r12
    1590:	7d 05       	cpc	r23, r13
    1592:	8e 05       	cpc	r24, r14
    1594:	9f 05       	cpc	r25, r15
    1596:	b0 f3       	brcs	.-20     	; 0x1584 <hd44780_pinIO::ioread(hd44780::iotype)+0x38>
ioread():
    1598:	8b a1       	ldd	r24, Y+35	; 0x23
_pinMode():
    159a:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:217
		return(hd44780::RV_ENOTSUP);

	waitReady();		// ensure previous instruction finished

	// put all the LCD data pins into input mode.
	pinMode(_d4, INPUT);
    159c:	28 f5       	brcc	.+74     	; 0x15e8 <hd44780_pinIO::ioread(hd44780::iotype)+0x9c>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    159e:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    15a0:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    15a2:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    15a4:	ff 4b       	sbci	r31, 0xBF	; 191
    15a6:	20 81       	ld	r18, Z
    15a8:	2f 3f       	cpi	r18, 0xFF	; 255
    15aa:	f1 f0       	breq	.+60     	; 0x15e8 <hd44780_pinIO::ioread(hd44780::iotype)+0x9c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    15ac:	fc 01       	movw	r30, r24
    15ae:	e0 56       	subi	r30, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    15b0:	ff 4b       	sbci	r31, 0xBF	; 191
    15b2:	e0 81       	ld	r30, Z
    15b4:	b0 e2       	ldi	r27, 0x20	; 32
    15b6:	eb 9f       	mul	r30, r27
    15b8:	f0 01       	movw	r30, r0
    15ba:	11 24       	eor	r1, r1
    15bc:	fc 5f       	subi	r31, 0xFC	; 252
    15be:	8c 5c       	subi	r24, 0xCC	; 204
    15c0:	9f 4b       	sbci	r25, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    15c2:	dc 01       	movw	r26, r24
    15c4:	3c 91       	ld	r19, X
ioread():
    15c6:	b0 e0       	ldi	r27, 0x00	; 0
    15c8:	a0 e0       	ldi	r26, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    15ca:	3f 3f       	cpi	r19, 0xFF	; 255
    15cc:	29 f0       	breq	.+10     	; 0x15d8 <hd44780_pinIO::ioread(hd44780::iotype)+0x8c>
    15ce:	cf 01       	movw	r24, r30
    15d0:	40 96       	adiw	r24, 0x10	; 16
    15d2:	dc 01       	movw	r26, r24
    15d4:	a3 0f       	add	r26, r19
    15d6:	b1 1d       	adc	r27, r1
    15d8:	9f b7       	in	r25, 0x3f	; 63
    15da:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
    15dc:	22 83       	std	Z+2, r18	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    15de:	8c 91       	ld	r24, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    15e0:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:240
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    15e2:	8c 93       	st	X, r24
    15e4:	26 83       	std	Z+6, r18	; 0x06
    15e6:	9f bf       	out	0x3f, r25	; 63
ioread():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:241
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    15e8:	8c a1       	ldd	r24, Y+36	; 0x24
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    }
    SREG = status;                      /* Restore state */
    15ea:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:218
	pinMode(_d5, INPUT);
    15ec:	28 f5       	brcc	.+74     	; 0x1638 <hd44780_pinIO::ioread(hd44780::iotype)+0xec>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    15ee:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    15f0:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    15f2:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    15f4:	ff 4b       	sbci	r31, 0xBF	; 191
    15f6:	20 81       	ld	r18, Z
    15f8:	2f 3f       	cpi	r18, 0xFF	; 255
    15fa:	f1 f0       	breq	.+60     	; 0x1638 <hd44780_pinIO::ioread(hd44780::iotype)+0xec>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    15fc:	fc 01       	movw	r30, r24
    15fe:	e0 56       	subi	r30, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1600:	ff 4b       	sbci	r31, 0xBF	; 191
    1602:	e0 81       	ld	r30, Z
    1604:	b0 e2       	ldi	r27, 0x20	; 32
    1606:	eb 9f       	mul	r30, r27
    1608:	f0 01       	movw	r30, r0
    160a:	11 24       	eor	r1, r1
    160c:	fc 5f       	subi	r31, 0xFC	; 252
    160e:	8c 5c       	subi	r24, 0xCC	; 204
    1610:	9f 4b       	sbci	r25, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    1612:	dc 01       	movw	r26, r24
    1614:	3c 91       	ld	r19, X
ioread():
    1616:	b0 e0       	ldi	r27, 0x00	; 0
    1618:	a0 e0       	ldi	r26, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    161a:	3f 3f       	cpi	r19, 0xFF	; 255
    161c:	29 f0       	breq	.+10     	; 0x1628 <hd44780_pinIO::ioread(hd44780::iotype)+0xdc>
    161e:	cf 01       	movw	r24, r30
    1620:	40 96       	adiw	r24, 0x10	; 16
    1622:	dc 01       	movw	r26, r24
    1624:	a3 0f       	add	r26, r19
    1626:	b1 1d       	adc	r27, r1
    1628:	9f b7       	in	r25, 0x3f	; 63
    162a:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
    162c:	22 83       	std	Z+2, r18	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    162e:	8c 91       	ld	r24, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    1630:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:240
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    1632:	8c 93       	st	X, r24
    1634:	26 83       	std	Z+6, r18	; 0x06
    1636:	9f bf       	out	0x3f, r25	; 63
ioread():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:241
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    1638:	8d a1       	ldd	r24, Y+37	; 0x25
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    }
    SREG = status;                      /* Restore state */
    163a:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:219
	pinMode(_d6, INPUT);
    163c:	28 f5       	brcc	.+74     	; 0x1688 <hd44780_pinIO::ioread(hd44780::iotype)+0x13c>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    163e:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    1640:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    1642:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1644:	ff 4b       	sbci	r31, 0xBF	; 191
    1646:	20 81       	ld	r18, Z
    1648:	2f 3f       	cpi	r18, 0xFF	; 255
    164a:	f1 f0       	breq	.+60     	; 0x1688 <hd44780_pinIO::ioread(hd44780::iotype)+0x13c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    164c:	fc 01       	movw	r30, r24
    164e:	e0 56       	subi	r30, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1650:	ff 4b       	sbci	r31, 0xBF	; 191
    1652:	e0 81       	ld	r30, Z
    1654:	b0 e2       	ldi	r27, 0x20	; 32
    1656:	eb 9f       	mul	r30, r27
    1658:	f0 01       	movw	r30, r0
    165a:	11 24       	eor	r1, r1
    165c:	fc 5f       	subi	r31, 0xFC	; 252
    165e:	8c 5c       	subi	r24, 0xCC	; 204
    1660:	9f 4b       	sbci	r25, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    1662:	dc 01       	movw	r26, r24
    1664:	3c 91       	ld	r19, X
ioread():
    1666:	b0 e0       	ldi	r27, 0x00	; 0
    1668:	a0 e0       	ldi	r26, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    166a:	3f 3f       	cpi	r19, 0xFF	; 255
    166c:	29 f0       	breq	.+10     	; 0x1678 <hd44780_pinIO::ioread(hd44780::iotype)+0x12c>
    166e:	cf 01       	movw	r24, r30
    1670:	40 96       	adiw	r24, 0x10	; 16
    1672:	dc 01       	movw	r26, r24
    1674:	a3 0f       	add	r26, r19
    1676:	b1 1d       	adc	r27, r1
    1678:	9f b7       	in	r25, 0x3f	; 63
    167a:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
    167c:	22 83       	std	Z+2, r18	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    167e:	8c 91       	ld	r24, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    1680:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:240
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    1682:	8c 93       	st	X, r24
    1684:	26 83       	std	Z+6, r18	; 0x06
    1686:	9f bf       	out	0x3f, r25	; 63
ioread():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:241
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    1688:	8e a1       	ldd	r24, Y+38	; 0x26
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    }
    SREG = status;                      /* Restore state */
    168a:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:220
	pinMode(_d7, INPUT);
    168c:	28 f5       	brcc	.+74     	; 0x16d8 <hd44780_pinIO::ioread(hd44780::iotype)+0x18c>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    168e:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    1690:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    1692:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1694:	ff 4b       	sbci	r31, 0xBF	; 191
    1696:	20 81       	ld	r18, Z
    1698:	2f 3f       	cpi	r18, 0xFF	; 255
    169a:	f1 f0       	breq	.+60     	; 0x16d8 <hd44780_pinIO::ioread(hd44780::iotype)+0x18c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    169c:	fc 01       	movw	r30, r24
    169e:	e0 56       	subi	r30, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    16a0:	ff 4b       	sbci	r31, 0xBF	; 191
    16a2:	e0 81       	ld	r30, Z
    16a4:	b0 e2       	ldi	r27, 0x20	; 32
    16a6:	eb 9f       	mul	r30, r27
    16a8:	f0 01       	movw	r30, r0
    16aa:	11 24       	eor	r1, r1
    16ac:	fc 5f       	subi	r31, 0xFC	; 252
    16ae:	8c 5c       	subi	r24, 0xCC	; 204
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    16b0:	9f 4b       	sbci	r25, 0xBF	; 191
    16b2:	dc 01       	movw	r26, r24
    16b4:	3c 91       	ld	r19, X
ioread():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    16b6:	b0 e0       	ldi	r27, 0x00	; 0
    16b8:	a0 e0       	ldi	r26, 0x00	; 0
_pinMode():
    16ba:	3f 3f       	cpi	r19, 0xFF	; 255
    16bc:	29 f0       	breq	.+10     	; 0x16c8 <hd44780_pinIO::ioread(hd44780::iotype)+0x17c>
    16be:	cf 01       	movw	r24, r30
    16c0:	40 96       	adiw	r24, 0x10	; 16
    16c2:	dc 01       	movw	r26, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
    16c4:	a3 0f       	add	r26, r19
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    16c6:	b1 1d       	adc	r27, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    16c8:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:240
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    16ca:	f8 94       	cli
    16cc:	22 83       	std	Z+2, r18	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:241
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    16ce:	8c 91       	ld	r24, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    }
    SREG = status;                      /* Restore state */
    16d0:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:225

	// set RS based on type of read (data or status/cmd)
	if(type == hd44780::HD44780_IOdata) 
	{
		digitalWrite(_rs, HIGH); // RS high to access data reg
    16d2:	8c 93       	st	X, r24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:223
	pinMode(_d5, INPUT);
	pinMode(_d6, INPUT);
	pinMode(_d7, INPUT);

	// set RS based on type of read (data or status/cmd)
	if(type == hd44780::HD44780_IOdata) 
    16d4:	26 83       	std	Z+6, r18	; 0x06
    16d6:	9f bf       	out	0x3f, r25	; 63
    16d8:	88 a1       	ldd	r24, Y+32	; 0x20
ioread():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:229
	{
		digitalWrite(_rs, HIGH); // RS high to access data reg
	}
	else
	{
		digitalWrite(_rs, LOW); // RS LOW to access status/cmd reg
    16da:	61 e0       	ldi	r22, 0x01	; 1
    16dc:	01 30       	cpi	r16, 0x01	; 1
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:233
	}

	// r/w  HIGH for reading
	digitalWrite(_rw, HIGH);
    16de:	11 05       	cpc	r17, r1
    16e0:	09 f0       	breq	.+2      	; 0x16e4 <hd44780_pinIO::ioread(hd44780::iotype)+0x198>
    16e2:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:236

	// raise E to allow reading the data.
	digitalWrite(_en, HIGH);
    16e4:	c2 dd       	rcall	.-1148   	; 0x126a <digitalWrite>
    16e6:	61 e0       	ldi	r22, 0x01	; 1
    16e8:	89 a1       	ldd	r24, Y+33	; 0x21
    16ea:	bf dd       	rcall	.-1154   	; 0x126a <digitalWrite>
c:\arduino-1.8.13\hardware\tools\avr\avr\include\util/delay.h:276
    16ec:	61 e0       	ldi	r22, 0x01	; 1
    16ee:	8a a1       	ldd	r24, Y+34	; 0x22
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:244
	// this could be much shorter but this is portable for all CPUs.
	// and it will ensure that hd44780 PWEH timing is honored as well.
	delayMicroseconds(1);

	// read pins for d4-d7 into upper nibble of byte
	if(digitalRead(_d4) == HIGH)
    16f0:	bc dd       	rcall	.-1160   	; 0x126a <digitalWrite>
_delay_us():
    16f2:	b8 e0       	ldi	r27, 0x08	; 8
    16f4:	ba 95       	dec	r27
    16f6:	f1 f7       	brne	.-4      	; 0x16f4 <hd44780_pinIO::ioread(hd44780::iotype)+0x1a8>
ioread():
    16f8:	8b a1       	ldd	r24, Y+35	; 0x23
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:245
		data |= (1 << 4);
    16fa:	9c dd       	rcall	.-1224   	; 0x1234 <digitalRead>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:247

	if(digitalRead(_d5) == HIGH)
    16fc:	10 e0       	ldi	r17, 0x00	; 0
    16fe:	81 30       	cpi	r24, 0x01	; 1
    1700:	09 f4       	brne	.+2      	; 0x1704 <hd44780_pinIO::ioread(hd44780::iotype)+0x1b8>
    1702:	10 e1       	ldi	r17, 0x10	; 16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:248
		data |= (1 << 5);
    1704:	8c a1       	ldd	r24, Y+36	; 0x24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:250

	if(digitalRead(_d6) == HIGH)
    1706:	96 dd       	rcall	.-1236   	; 0x1234 <digitalRead>
    1708:	81 30       	cpi	r24, 0x01	; 1
    170a:	09 f4       	brne	.+2      	; 0x170e <hd44780_pinIO::ioread(hd44780::iotype)+0x1c2>
    170c:	10 62       	ori	r17, 0x20	; 32
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:253
		data |= (1 << 6);

	if(digitalRead(_d7) == HIGH)
    170e:	8d a1       	ldd	r24, Y+37	; 0x25
    1710:	91 dd       	rcall	.-1246   	; 0x1234 <digitalRead>
    1712:	81 30       	cpi	r24, 0x01	; 1
    1714:	09 f4       	brne	.+2      	; 0x1718 <hd44780_pinIO::ioread(hd44780::iotype)+0x1cc>
    1716:	10 64       	ori	r17, 0x40	; 64
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:257
		data |= (1 << 7);

	// lower E after reading nibble
	digitalWrite(_en, LOW);
    1718:	8e a1       	ldd	r24, Y+38	; 0x26
    171a:	8c dd       	rcall	.-1256   	; 0x1234 <digitalRead>
    171c:	81 30       	cpi	r24, 0x01	; 1
    171e:	09 f4       	brne	.+2      	; 0x1722 <hd44780_pinIO::ioread(hd44780::iotype)+0x1d6>
c:\arduino-1.8.13\hardware\tools\avr\avr\include\util/delay.h:276
    1720:	10 68       	ori	r17, 0x80	; 128
    1722:	60 e0       	ldi	r22, 0x00	; 0
    1724:	8a a1       	ldd	r24, Y+34	; 0x22
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:264
	// allow for hd44780 1/2 of tcycE (Enable cycle time)
	// this could be much shorter but this is portable for all CPUs.
	delayMicroseconds(1);
	
	// raise E to allow reading the lower nibbly of the byte
	digitalWrite(_en, HIGH);
    1726:	a1 dd       	rcall	.-1214   	; 0x126a <digitalWrite>
_delay_us():
    1728:	e8 e0       	ldi	r30, 0x08	; 8
    172a:	ea 95       	dec	r30
    172c:	f1 f7       	brne	.-4      	; 0x172a <hd44780_pinIO::ioread(hd44780::iotype)+0x1de>
ioread():
c:\arduino-1.8.13\hardware\tools\avr\avr\include\util/delay.h:276
    172e:	61 e0       	ldi	r22, 0x01	; 1
    1730:	8a a1       	ldd	r24, Y+34	; 0x22
    1732:	9b dd       	rcall	.-1226   	; 0x126a <digitalWrite>
_delay_us():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:272
	// this could be shorter but this is portable for all CPUs.
	// and it will ensure that hd44780 PWEH timing is honored as well.
	delayMicroseconds(1);

	// read pins for d4-d7 into upper nibble of byte
	if(digitalRead(_d4) == HIGH)
    1734:	f8 e0       	ldi	r31, 0x08	; 8
    1736:	fa 95       	dec	r31
    1738:	f1 f7       	brne	.-4      	; 0x1736 <hd44780_pinIO::ioread(hd44780::iotype)+0x1ea>
ioread():
    173a:	8b a1       	ldd	r24, Y+35	; 0x23
    173c:	7b dd       	rcall	.-1290   	; 0x1234 <digitalRead>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:273
		data |= (1 << 0);
    173e:	81 30       	cpi	r24, 0x01	; 1
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:275

	if(digitalRead(_d5) == HIGH)
    1740:	09 f4       	brne	.+2      	; 0x1744 <hd44780_pinIO::ioread(hd44780::iotype)+0x1f8>
    1742:	11 60       	ori	r17, 0x01	; 1
    1744:	8c a1       	ldd	r24, Y+36	; 0x24
    1746:	76 dd       	rcall	.-1300   	; 0x1234 <digitalRead>
    1748:	81 30       	cpi	r24, 0x01	; 1
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:276
		data |= (1 << 1);
    174a:	09 f4       	brne	.+2      	; 0x174e <hd44780_pinIO::ioread(hd44780::iotype)+0x202>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:278

	if(digitalRead(_d6) == HIGH)
    174c:	12 60       	ori	r17, 0x02	; 2
    174e:	8d a1       	ldd	r24, Y+37	; 0x25
    1750:	71 dd       	rcall	.-1310   	; 0x1234 <digitalRead>
    1752:	81 30       	cpi	r24, 0x01	; 1
    1754:	09 f4       	brne	.+2      	; 0x1758 <hd44780_pinIO::ioread(hd44780::iotype)+0x20c>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:279
		data |= (1 << 2);
    1756:	14 60       	ori	r17, 0x04	; 4
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:281

	if(digitalRead(_d7) == HIGH)
    1758:	8e a1       	ldd	r24, Y+38	; 0x26
    175a:	6c dd       	rcall	.-1320   	; 0x1234 <digitalRead>
    175c:	81 30       	cpi	r24, 0x01	; 1
    175e:	09 f4       	brne	.+2      	; 0x1762 <hd44780_pinIO::ioread(hd44780::iotype)+0x216>
    1760:	18 60       	ori	r17, 0x08	; 8
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:282
		data |= (1 << 3);
    1762:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:286

   
	// lower E after reading nibble
	digitalWrite(_en, LOW);
    1764:	8a a1       	ldd	r24, Y+34	; 0x22
    1766:	81 dd       	rcall	.-1278   	; 0x126a <digitalWrite>
    1768:	8b a1       	ldd	r24, Y+35	; 0x23
_pinMode():
    176a:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:293
	//
	// put all pins back into state for writing to LCD
	//

	// put all the LCD data pins into input mode.
	pinMode(_d4, OUTPUT);
    176c:	88 f4       	brcc	.+34     	; 0x1790 <hd44780_pinIO::ioread(hd44780::iotype)+0x244>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    176e:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    1770:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    1772:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1774:	ff 4b       	sbci	r31, 0xBF	; 191
    1776:	20 81       	ld	r18, Z
    1778:	2f 3f       	cpi	r18, 0xFF	; 255
    177a:	51 f0       	breq	.+20     	; 0x1790 <hd44780_pinIO::ioread(hd44780::iotype)+0x244>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    177c:	80 56       	subi	r24, 0x60	; 96
    177e:	9f 4b       	sbci	r25, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1780:	dc 01       	movw	r26, r24
    1782:	ec 91       	ld	r30, X
    1784:	b0 e2       	ldi	r27, 0x20	; 32
    1786:	eb 9f       	mul	r30, r27
    1788:	f0 01       	movw	r30, r0
    178a:	11 24       	eor	r1, r1
    178c:	fc 5f       	subi	r31, 0xFC	; 252
    178e:	21 83       	std	Z+1, r18	; 0x01
ioread():
    1790:	8c a1       	ldd	r24, Y+36	; 0x24
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1792:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:294
	pinMode(_d5, OUTPUT);
    1794:	88 f4       	brcc	.+34     	; 0x17b8 <hd44780_pinIO::ioread(hd44780::iotype)+0x26c>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1796:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    1798:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    179a:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    179c:	ff 4b       	sbci	r31, 0xBF	; 191
    179e:	20 81       	ld	r18, Z
    17a0:	2f 3f       	cpi	r18, 0xFF	; 255
    17a2:	51 f0       	breq	.+20     	; 0x17b8 <hd44780_pinIO::ioread(hd44780::iotype)+0x26c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    17a4:	80 56       	subi	r24, 0x60	; 96
    17a6:	9f 4b       	sbci	r25, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    17a8:	dc 01       	movw	r26, r24
    17aa:	ec 91       	ld	r30, X
    17ac:	b0 e2       	ldi	r27, 0x20	; 32
    17ae:	eb 9f       	mul	r30, r27
    17b0:	f0 01       	movw	r30, r0
    17b2:	11 24       	eor	r1, r1
    17b4:	fc 5f       	subi	r31, 0xFC	; 252
    17b6:	21 83       	std	Z+1, r18	; 0x01
ioread():
    17b8:	8d a1       	ldd	r24, Y+37	; 0x25
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    17ba:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    17bc:	88 f4       	brcc	.+34     	; 0x17e0 <hd44780_pinIO::ioread(hd44780::iotype)+0x294>
check_valid_digital_pin():
    17be:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    17c0:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    17c2:	e9 58       	subi	r30, 0x89	; 137
    17c4:	ff 4b       	sbci	r31, 0xBF	; 191
    17c6:	20 81       	ld	r18, Z
    17c8:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    17ca:	51 f0       	breq	.+20     	; 0x17e0 <hd44780_pinIO::ioread(hd44780::iotype)+0x294>
    17cc:	80 56       	subi	r24, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    17ce:	9f 4b       	sbci	r25, 0xBF	; 191
    17d0:	dc 01       	movw	r26, r24
    17d2:	ec 91       	ld	r30, X
    17d4:	b0 e2       	ldi	r27, 0x20	; 32
    17d6:	eb 9f       	mul	r30, r27
    17d8:	f0 01       	movw	r30, r0
    17da:	11 24       	eor	r1, r1
    17dc:	fc 5f       	subi	r31, 0xFC	; 252
    17de:	21 83       	std	Z+1, r18	; 0x01
ioread():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    17e0:	8e a1       	ldd	r24, Y+38	; 0x26
_pinMode():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:296
	pinMode(_d6, OUTPUT);
	pinMode(_d7, OUTPUT);
    17e2:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    17e4:	88 f4       	brcc	.+34     	; 0x1808 <hd44780_pinIO::ioread(hd44780::iotype)+0x2bc>
check_valid_digital_pin():
    17e6:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    17e8:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    17ea:	e9 58       	subi	r30, 0x89	; 137
    17ec:	ff 4b       	sbci	r31, 0xBF	; 191
    17ee:	20 81       	ld	r18, Z
    17f0:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    17f2:	51 f0       	breq	.+20     	; 0x1808 <hd44780_pinIO::ioread(hd44780::iotype)+0x2bc>
    17f4:	80 56       	subi	r24, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    17f6:	9f 4b       	sbci	r25, 0xBF	; 191
    17f8:	dc 01       	movw	r26, r24
    17fa:	ec 91       	ld	r30, X
    17fc:	b0 e2       	ldi	r27, 0x20	; 32
    17fe:	eb 9f       	mul	r30, r27
    1800:	f0 01       	movw	r30, r0
    1802:	11 24       	eor	r1, r1
    1804:	fc 5f       	subi	r31, 0xFC	; 252
    1806:	21 83       	std	Z+1, r18	; 0x01
ioread():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1808:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:299

	// r/w  LOW for Writing
	digitalWrite(_rw, LOW);
    180a:	89 a1       	ldd	r24, Y+33	; 0x21
    180c:	2e dd       	rcall	.-1444   	; 0x126a <digitalWrite>
    180e:	81 2f       	mov	r24, r17
    1810:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:301

	return(data);
    1812:	df 91       	pop	r29
    1814:	cf 91       	pop	r28
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:302
}
    1816:	1f 91       	pop	r17
    1818:	0f 91       	pop	r16
    181a:	ff 90       	pop	r15
    181c:	ef 90       	pop	r14
    181e:	df 90       	pop	r13
    1820:	cf 90       	pop	r12
    1822:	bf 90       	pop	r11
    1824:	af 90       	pop	r10
    1826:	9f 90       	pop	r9
    1828:	8f 90       	pop	r8
    182a:	08 95       	ret
    182c:	8d ef       	ldi	r24, 0xFD	; 253
    182e:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:212
{
uint8_t data = 0;

	// check if r/w control supported
	if(_rw == 0xff)
		return(hd44780::RV_ENOTSUP);
    1830:	f0 cf       	rjmp	.-32     	; 0x1812 <hd44780_pinIO::ioread(hd44780::iotype)+0x2c6>

00001832 <hd44780_pinIO::ioinit()>:
ioinit():
    1832:	cf 92       	push	r12
    1834:	df 92       	push	r13
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:154
// ==================================================
// === hd44780 i/o subclass virtual i/o functions ===
// ==================================================

// ioinit() - initialize the h/w
int ioinit()
    1836:	ef 92       	push	r14
    1838:	ff 92       	push	r15
    183a:	0f 93       	push	r16
    183c:	1f 93       	push	r17
    183e:	cf 93       	push	r28
    1840:	df 93       	push	r29
    1842:	8c 01       	movw	r16, r24
    1844:	dc 01       	movw	r26, r24
    1846:	90 96       	adiw	r26, 0x20	; 32
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:165
	// the reason is it is possible initilization is called without
	// without resetting the processor. In that case the state of the
	// bit in the port register would be unknown, so it is safest to set
	// to the desired state (LOW).

	pinMode(_rs, OUTPUT);
    1848:	8c 91       	ld	r24, X
_pinMode():
    184a:	89 32       	cpi	r24, 0x29	; 41
    184c:	88 f4       	brcc	.+34     	; 0x1870 <hd44780_pinIO::ioinit()+0x3e>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    184e:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    1850:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1852:	e9 58       	subi	r30, 0x89	; 137
    1854:	ff 4b       	sbci	r31, 0xBF	; 191
    1856:	20 81       	ld	r18, Z
    1858:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    185a:	51 f0       	breq	.+20     	; 0x1870 <hd44780_pinIO::ioinit()+0x3e>
    185c:	80 56       	subi	r24, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    185e:	9f 4b       	sbci	r25, 0xBF	; 191
    1860:	dc 01       	movw	r26, r24
    1862:	ec 91       	ld	r30, X
    1864:	b0 e2       	ldi	r27, 0x20	; 32
    1866:	eb 9f       	mul	r30, r27
    1868:	f0 01       	movw	r30, r0
    186a:	11 24       	eor	r1, r1
    186c:	fc 5f       	subi	r31, 0xFC	; 252
    186e:	21 83       	std	Z+1, r18	; 0x01
ioinit():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1870:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:167

	if(_rw != 0xff)
    1872:	81 a1       	ldd	r24, Z+33	; 0x21
    1874:	8f 3f       	cpi	r24, 0xFF	; 255
    1876:	b1 f0       	breq	.+44     	; 0x18a4 <hd44780_pinIO::ioinit()+0x72>
_pinMode():
    1878:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    187a:	90 f4       	brcc	.+36     	; 0x18a0 <hd44780_pinIO::ioinit()+0x6e>
check_valid_digital_pin():
    187c:	28 2f       	mov	r18, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    187e:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1880:	f9 01       	movw	r30, r18
    1882:	e9 58       	subi	r30, 0x89	; 137
    1884:	ff 4b       	sbci	r31, 0xBF	; 191
    1886:	90 81       	ld	r25, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1888:	9f 3f       	cpi	r25, 0xFF	; 255
    188a:	51 f0       	breq	.+20     	; 0x18a0 <hd44780_pinIO::ioinit()+0x6e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    188c:	20 56       	subi	r18, 0x60	; 96
    188e:	3f 4b       	sbci	r19, 0xBF	; 191
    1890:	d9 01       	movw	r26, r18
    1892:	ec 91       	ld	r30, X
    1894:	b0 e2       	ldi	r27, 0x20	; 32
    1896:	eb 9f       	mul	r30, r27
    1898:	f0 01       	movw	r30, r0
    189a:	11 24       	eor	r1, r1
    189c:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    189e:	91 83       	std	Z+1, r25	; 0x01
ioinit():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:174
		pinMode(_rw, OUTPUT);
		// if r/w is used it be will set to be low,
		// it will only be turned hi during a read and
		// then set back to low. This offers a slight boost
		// for writes since normally reads are not done very often
		digitalWrite(_rw, LOW);
    18a0:	60 e0       	ldi	r22, 0x00	; 0
    18a2:	e3 dc       	rcall	.-1594   	; 0x126a <digitalWrite>
    18a4:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:177
	}

	pinMode(_en, OUTPUT);
    18a6:	82 a1       	ldd	r24, Z+34	; 0x22
_pinMode():
    18a8:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    18aa:	90 f4       	brcc	.+36     	; 0x18d0 <hd44780_pinIO::ioinit()+0x9e>
check_valid_digital_pin():
    18ac:	28 2f       	mov	r18, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    18ae:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
    18b0:	f9 01       	movw	r30, r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    18b2:	e9 58       	subi	r30, 0x89	; 137
    18b4:	ff 4b       	sbci	r31, 0xBF	; 191
    18b6:	90 81       	ld	r25, Z
    18b8:	9f 3f       	cpi	r25, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    18ba:	51 f0       	breq	.+20     	; 0x18d0 <hd44780_pinIO::ioinit()+0x9e>
    18bc:	20 56       	subi	r18, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    18be:	3f 4b       	sbci	r19, 0xBF	; 191
    18c0:	d9 01       	movw	r26, r18
    18c2:	ec 91       	ld	r30, X
    18c4:	b0 e2       	ldi	r27, 0x20	; 32
    18c6:	eb 9f       	mul	r30, r27
    18c8:	f0 01       	movw	r30, r0
    18ca:	11 24       	eor	r1, r1
    18cc:	fc 5f       	subi	r31, 0xFC	; 252
    18ce:	91 83       	std	Z+1, r25	; 0x01
ioinit():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    18d0:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:178
	digitalWrite(_en, LOW);
    18d2:	cb dc       	rcall	.-1642   	; 0x126a <digitalWrite>
    18d4:	f8 01       	movw	r30, r16
    18d6:	83 a1       	ldd	r24, Z+35	; 0x23
_pinMode():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:180

	pinMode(_d4, OUTPUT);
    18d8:	89 32       	cpi	r24, 0x29	; 41
    18da:	88 f4       	brcc	.+34     	; 0x18fe <hd44780_pinIO::ioinit()+0xcc>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    18dc:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    18de:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    18e0:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    18e2:	ff 4b       	sbci	r31, 0xBF	; 191
    18e4:	20 81       	ld	r18, Z
    18e6:	2f 3f       	cpi	r18, 0xFF	; 255
    18e8:	51 f0       	breq	.+20     	; 0x18fe <hd44780_pinIO::ioinit()+0xcc>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    18ea:	80 56       	subi	r24, 0x60	; 96
    18ec:	9f 4b       	sbci	r25, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    18ee:	dc 01       	movw	r26, r24
    18f0:	ec 91       	ld	r30, X
    18f2:	b0 e2       	ldi	r27, 0x20	; 32
    18f4:	eb 9f       	mul	r30, r27
    18f6:	f0 01       	movw	r30, r0
    18f8:	11 24       	eor	r1, r1
    18fa:	fc 5f       	subi	r31, 0xFC	; 252
    18fc:	21 83       	std	Z+1, r18	; 0x01
ioinit():
    18fe:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1900:	84 a1       	ldd	r24, Z+36	; 0x24
_pinMode():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:181
	pinMode(_d5, OUTPUT);
    1902:	89 32       	cpi	r24, 0x29	; 41
    1904:	88 f4       	brcc	.+34     	; 0x1928 <hd44780_pinIO::ioinit()+0xf6>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1906:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    1908:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    190a:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    190c:	ff 4b       	sbci	r31, 0xBF	; 191
    190e:	20 81       	ld	r18, Z
    1910:	2f 3f       	cpi	r18, 0xFF	; 255
    1912:	51 f0       	breq	.+20     	; 0x1928 <hd44780_pinIO::ioinit()+0xf6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1914:	80 56       	subi	r24, 0x60	; 96
    1916:	9f 4b       	sbci	r25, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1918:	dc 01       	movw	r26, r24
    191a:	ec 91       	ld	r30, X
    191c:	b0 e2       	ldi	r27, 0x20	; 32
    191e:	eb 9f       	mul	r30, r27
    1920:	f0 01       	movw	r30, r0
    1922:	11 24       	eor	r1, r1
    1924:	fc 5f       	subi	r31, 0xFC	; 252
    1926:	21 83       	std	Z+1, r18	; 0x01
ioinit():
    1928:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    192a:	85 a1       	ldd	r24, Z+37	; 0x25
_pinMode():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:182
	pinMode(_d6, OUTPUT);
    192c:	89 32       	cpi	r24, 0x29	; 41
    192e:	88 f4       	brcc	.+34     	; 0x1952 <hd44780_pinIO::ioinit()+0x120>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1930:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    1932:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    1934:	e9 58       	subi	r30, 0x89	; 137
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1936:	ff 4b       	sbci	r31, 0xBF	; 191
    1938:	20 81       	ld	r18, Z
    193a:	2f 3f       	cpi	r18, 0xFF	; 255
    193c:	51 f0       	breq	.+20     	; 0x1952 <hd44780_pinIO::ioinit()+0x120>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    193e:	80 56       	subi	r24, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1940:	9f 4b       	sbci	r25, 0xBF	; 191
    1942:	dc 01       	movw	r26, r24
    1944:	ec 91       	ld	r30, X
    1946:	b0 e2       	ldi	r27, 0x20	; 32
    1948:	eb 9f       	mul	r30, r27
    194a:	f0 01       	movw	r30, r0
    194c:	11 24       	eor	r1, r1
    194e:	fc 5f       	subi	r31, 0xFC	; 252
    1950:	21 83       	std	Z+1, r18	; 0x01
ioinit():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1952:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:183
	pinMode(_d7, OUTPUT);
    1954:	86 a1       	ldd	r24, Z+38	; 0x26
_pinMode():
    1956:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1958:	88 f4       	brcc	.+34     	; 0x197c <hd44780_pinIO::ioinit()+0x14a>
check_valid_digital_pin():
    195a:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    195c:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    195e:	e9 58       	subi	r30, 0x89	; 137
    1960:	ff 4b       	sbci	r31, 0xBF	; 191
    1962:	20 81       	ld	r18, Z
    1964:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1966:	51 f0       	breq	.+20     	; 0x197c <hd44780_pinIO::ioinit()+0x14a>
    1968:	80 56       	subi	r24, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    196a:	9f 4b       	sbci	r25, 0xBF	; 191
    196c:	dc 01       	movw	r26, r24
    196e:	ec 91       	ld	r30, X
    1970:	b0 e2       	ldi	r27, 0x20	; 32
    1972:	eb 9f       	mul	r30, r27
    1974:	f0 01       	movw	r30, r0
    1976:	11 24       	eor	r1, r1
    1978:	fc 5f       	subi	r31, 0xFC	; 252
    197a:	21 83       	std	Z+1, r18	; 0x01
ioinit():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    197c:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:185
  
	if(_bl != 0xff)
    197e:	c7 a1       	ldd	r28, Z+39	; 0x27
    1980:	cf 3f       	cpi	r28, 0xFF	; 255
    1982:	09 f4       	brne	.+2      	; 0x1986 <hd44780_pinIO::ioinit()+0x154>
    1984:	8a c0       	rjmp	.+276    	; 0x1a9a <hd44780_pinIO::ioinit()+0x268>
    1986:	80 a5       	ldd	r24, Z+40	; 0x28
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:191
	{
		// check for broken backlight circuit on LCDkeypads
		// and protect Arduino if it appears to be broken
		// code will do "safe" backlight control
		
		if((_blLevel == HIGH) && blPinTest(_bl))
    1988:	81 30       	cpi	r24, 0x01	; 1
    198a:	09 f0       	breq	.+2      	; 0x198e <hd44780_pinIO::ioinit()+0x15c>
    198c:	70 c0       	rjmp	.+224    	; 0x1a6e <hd44780_pinIO::ioinit()+0x23c>
    198e:	ec 2e       	mov	r14, r28
    1990:	f1 2c       	mov	r15, r1
_ZN13hd44780_pinIO9blPinTestEi.isra.3():
    1992:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:487
	 * only the newer Arduino cores disable the pullup
	 * when setting the pin to INPUT.
	 * On boards that have a pullup on the transistor base,
	 * this should cause the backlight to be on.
	 */
	digitalWrite(pin, LOW);
    1994:	8c 2f       	mov	r24, r28
    1996:	69 dc       	rcall	.-1838   	; 0x126a <digitalWrite>
_pinMode():
    1998:	c9 32       	cpi	r28, 0x29	; 41
    199a:	08 f0       	brcs	.+2      	; 0x199e <hd44780_pinIO::ioinit()+0x16c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    199c:	8f c0       	rjmp	.+286    	; 0x1abc <hd44780_pinIO::ioinit()+0x28a>
    199e:	c7 01       	movw	r24, r14
    19a0:	89 58       	subi	r24, 0x89	; 137
    19a2:	9f 4b       	sbci	r25, 0xBF	; 191
    19a4:	6c 01       	movw	r12, r24
    19a6:	dc 01       	movw	r26, r24
    19a8:	8c 91       	ld	r24, X
    19aa:	8f 3f       	cpi	r24, 0xFF	; 255
    19ac:	f1 f0       	breq	.+60     	; 0x19ea <hd44780_pinIO::ioinit()+0x1b8>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    19ae:	f7 01       	movw	r30, r14
    19b0:	e0 56       	subi	r30, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    19b2:	ff 4b       	sbci	r31, 0xBF	; 191
    19b4:	e0 81       	ld	r30, Z
    19b6:	b0 e2       	ldi	r27, 0x20	; 32
    19b8:	eb 9f       	mul	r30, r27
    19ba:	f0 01       	movw	r30, r0
    19bc:	11 24       	eor	r1, r1
    19be:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    19c0:	d7 01       	movw	r26, r14
    19c2:	ac 5c       	subi	r26, 0xCC	; 204
    19c4:	bf 4b       	sbci	r27, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    19c6:	ac 91       	ld	r26, X
    19c8:	af 3f       	cpi	r26, 0xFF	; 255
    19ca:	09 f4       	brne	.+2      	; 0x19ce <hd44780_pinIO::ioinit()+0x19c>
    19cc:	71 c0       	rjmp	.+226    	; 0x1ab0 <hd44780_pinIO::ioinit()+0x27e>
    19ce:	9f 01       	movw	r18, r30
    19d0:	20 5f       	subi	r18, 0xF0	; 240
    19d2:	3f 4f       	sbci	r19, 0xFF	; 255
    19d4:	a2 0f       	add	r26, r18
    19d6:	b3 2f       	mov	r27, r19
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
    19d8:	b1 1d       	adc	r27, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    19da:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    19dc:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:240
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    19de:	82 83       	std	Z+2, r24	; 0x02
    19e0:	9c 91       	ld	r25, X
    19e2:	97 7f       	andi	r25, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:241
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    19e4:	9c 93       	st	X, r25
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    }
    SREG = status;                      /* Restore state */
    19e6:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    19e8:	2f bf       	out	0x3f, r18	; 63
    19ea:	f6 01       	movw	r30, r12
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    19ec:	80 81       	ld	r24, Z
    19ee:	8f 3f       	cpi	r24, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    19f0:	51 f0       	breq	.+20     	; 0x1a06 <hd44780_pinIO::ioinit()+0x1d4>
    19f2:	f7 01       	movw	r30, r14
    19f4:	e0 56       	subi	r30, 0x60	; 96
    19f6:	ff 4b       	sbci	r31, 0xBF	; 191
    19f8:	e0 81       	ld	r30, Z
    19fa:	20 e2       	ldi	r18, 0x20	; 32
    19fc:	e2 9f       	mul	r30, r18
    19fe:	f0 01       	movw	r30, r0
    1a00:	11 24       	eor	r1, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1a02:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:506
	 * NOTE: This is NOT a safe thing to do
	 * on the broken designs. The code will minimize
	 * the time this is done to prevent any potential damage.
	 */

	digitalWrite(pin, HIGH);
    1a04:	81 83       	std	Z+1, r24	; 0x01
_ZN13hd44780_pinIO9blPinTestEi.isra.3():
    1a06:	61 e0       	ldi	r22, 0x01	; 1
    1a08:	8c 2f       	mov	r24, r28
    1a0a:	2f dc       	rcall	.-1954   	; 0x126a <digitalWrite>
_delay_us():
c:\arduino-1.8.13\hardware\tools\avr\avr\include\util/delay.h:276
    1a0c:	88 e2       	ldi	r24, 0x28	; 40
    1a0e:	8a 95       	dec	r24
    1a10:	f1 f7       	brne	.-4      	; 0x1a0e <hd44780_pinIO::ioinit()+0x1dc>
_ZN13hd44780_pinIO9blPinTestEi.isra.3():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:516
	 * See if a short is pulling down the HIGH output.
	 */

	delayMicroseconds(5); // give some time for the signal to droop

	val = digitalRead(pin); // read the level on the pin
    1a12:	8c 2f       	mov	r24, r28
    1a14:	0f dc       	rcall	.-2018   	; 0x1234 <digitalRead>
    1a16:	d8 2f       	mov	r29, r24
    1a18:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:522

	/*
 	 * Restore the pin to a safe state
	 * Input with pullup turned off
	 */
	digitalWrite(pin, LOW);
    1a1a:	8c 2f       	mov	r24, r28
    1a1c:	26 dc       	rcall	.-1972   	; 0x126a <digitalWrite>
_pinMode():
    1a1e:	c9 32       	cpi	r28, 0x29	; 41
    1a20:	08 f5       	brcc	.+66     	; 0x1a64 <hd44780_pinIO::ioinit()+0x232>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1a22:	d6 01       	movw	r26, r12
    1a24:	8c 91       	ld	r24, X
    1a26:	8f 3f       	cpi	r24, 0xFF	; 255
    1a28:	e9 f0       	breq	.+58     	; 0x1a64 <hd44780_pinIO::ioinit()+0x232>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1a2a:	f7 01       	movw	r30, r14
    1a2c:	e0 56       	subi	r30, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1a2e:	ff 4b       	sbci	r31, 0xBF	; 191
    1a30:	e0 81       	ld	r30, Z
    1a32:	b0 e2       	ldi	r27, 0x20	; 32
    1a34:	eb 9f       	mul	r30, r27
    1a36:	f0 01       	movw	r30, r0
    1a38:	11 24       	eor	r1, r1
    1a3a:	fc 5f       	subi	r31, 0xFC	; 252
    1a3c:	d7 01       	movw	r26, r14
    1a3e:	ac 5c       	subi	r26, 0xCC	; 204
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    1a40:	bf 4b       	sbci	r27, 0xBF	; 191
    1a42:	ac 91       	ld	r26, X
    1a44:	af 3f       	cpi	r26, 0xFF	; 255
    1a46:	b9 f1       	breq	.+110    	; 0x1ab6 <hd44780_pinIO::ioinit()+0x284>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    1a48:	9f 01       	movw	r18, r30
    1a4a:	20 5f       	subi	r18, 0xF0	; 240
    1a4c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a4e:	a2 0f       	add	r26, r18
    1a50:	b3 2f       	mov	r27, r19
    1a52:	b1 1d       	adc	r27, r1
    1a54:	2f b7       	in	r18, 0x3f	; 63
    1a56:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
    1a58:	82 83       	std	Z+2, r24	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    1a5a:	9c 91       	ld	r25, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    1a5c:	97 7f       	andi	r25, 0xF7	; 247
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:240
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    1a5e:	9c 93       	st	X, r25
    1a60:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:241
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    1a62:	2f bf       	out	0x3f, r18	; 63
_ZN13hd44780_pinIO9blPinTestEi.isra.3():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    }
    SREG = status;                      /* Restore state */
    1a64:	d1 30       	cpi	r29, 0x01	; 1
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:530
	/*
	 * If the level read back is not HIGH
	 * Then there is a problem because the pin is
	 * being driven HIGH by the AVR.
	 */
	if (val != HIGH)
    1a66:	19 f0       	breq	.+6      	; 0x1a6e <hd44780_pinIO::ioinit()+0x23c>
ioinit():
    1a68:	8e ef       	ldi	r24, 0xFE	; 254
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:192
		// check for broken backlight circuit on LCDkeypads
		// and protect Arduino if it appears to be broken
		// code will do "safe" backlight control
		
		if((_blLevel == HIGH) && blPinTest(_bl))
			_blLevel = HIGHZ;
    1a6a:	f8 01       	movw	r30, r16
    1a6c:	80 a7       	std	Z+40, r24	; 0x28
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:194

		pinMode(_bl, OUTPUT);
    1a6e:	d8 01       	movw	r26, r16
    1a70:	97 96       	adiw	r26, 0x27	; 39
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1a72:	8c 91       	ld	r24, X
_pinMode():
    1a74:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:32
#include "pins_arduino.h"


inline __attribute__((always_inline)) void check_valid_digital_pin(uint8_t pin)
{
  if(__builtin_constant_p(pin)) {
    1a76:	88 f4       	brcc	.+34     	; 0x1a9a <hd44780_pinIO::ioinit()+0x268>
check_valid_digital_pin():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1a78:	90 e0       	ldi	r25, 0x00	; 0
_pinMode():
    1a7a:	fc 01       	movw	r30, r24
    1a7c:	e9 58       	subi	r30, 0x89	; 137
    1a7e:	ff 4b       	sbci	r31, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1a80:	20 81       	ld	r18, Z
    1a82:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1a84:	51 f0       	breq	.+20     	; 0x1a9a <hd44780_pinIO::ioinit()+0x268>
    1a86:	80 56       	subi	r24, 0x60	; 96
    1a88:	9f 4b       	sbci	r25, 0xBF	; 191
    1a8a:	dc 01       	movw	r26, r24
    1a8c:	ec 91       	ld	r30, X
    1a8e:	b0 e2       	ldi	r27, 0x20	; 32
    1a90:	eb 9f       	mul	r30, r27
    1a92:	f0 01       	movw	r30, r0
    1a94:	11 24       	eor	r1, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1a96:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:198
	}

	return(hd44780::RV_ENOERR); // all is good
}
    1a98:	21 83       	std	Z+1, r18	; 0x01
ioinit():
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	80 e0       	ldi	r24, 0x00	; 0
    1a9e:	df 91       	pop	r29
    1aa0:	cf 91       	pop	r28
    1aa2:	1f 91       	pop	r17
    1aa4:	0f 91       	pop	r16
    1aa6:	ff 90       	pop	r15
    1aa8:	ef 90       	pop	r14
    1aaa:	df 90       	pop	r13
    1aac:	cf 90       	pop	r12
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    1aae:	08 95       	ret
    1ab0:	b0 e0       	ldi	r27, 0x00	; 0
    1ab2:	a0 e0       	ldi	r26, 0x00	; 0
    1ab4:	92 cf       	rjmp	.-220    	; 0x19da <hd44780_pinIO::ioinit()+0x1a8>
    1ab6:	b0 e0       	ldi	r27, 0x00	; 0
    1ab8:	a0 e0       	ldi	r26, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:506
	 * NOTE: This is NOT a safe thing to do
	 * on the broken designs. The code will minimize
	 * the time this is done to prevent any potential damage.
	 */

	digitalWrite(pin, HIGH);
    1aba:	cc cf       	rjmp	.-104    	; 0x1a54 <hd44780_pinIO::ioinit()+0x222>
_ZN13hd44780_pinIO9blPinTestEi.isra.3():
    1abc:	61 e0       	ldi	r22, 0x01	; 1
    1abe:	8c 2f       	mov	r24, r28
c:\arduino-1.8.13\hardware\tools\avr\avr\include\util/delay.h:276
    1ac0:	d4 db       	rcall	.-2136   	; 0x126a <digitalWrite>
_delay_us():
    1ac2:	f8 e2       	ldi	r31, 0x28	; 40
    1ac4:	fa 95       	dec	r31
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:516
	 * See if a short is pulling down the HIGH output.
	 */

	delayMicroseconds(5); // give some time for the signal to droop

	val = digitalRead(pin); // read the level on the pin
    1ac6:	f1 f7       	brne	.-4      	; 0x1ac4 <hd44780_pinIO::ioinit()+0x292>
_ZN13hd44780_pinIO9blPinTestEi.isra.3():
    1ac8:	8c 2f       	mov	r24, r28
    1aca:	b4 db       	rcall	.-2200   	; 0x1234 <digitalRead>
    1acc:	d8 2f       	mov	r29, r24
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:522

	/*
 	 * Restore the pin to a safe state
	 * Input with pullup turned off
	 */
	digitalWrite(pin, LOW);
    1ace:	60 e0       	ldi	r22, 0x00	; 0
    1ad0:	8c 2f       	mov	r24, r28
    1ad2:	cb db       	rcall	.-2154   	; 0x126a <digitalWrite>
    1ad4:	c7 cf       	rjmp	.-114    	; 0x1a64 <hd44780_pinIO::ioinit()+0x232>

00001ad6 <analogWrite>:
analogWrite():
    1ad6:	cf 93       	push	r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:401
// for the variant in use. On all other pins, the best we
// can do is output a HIGH or LOW except on PIN_PD6, which
// is the DAC output pin.

void analogWrite(uint8_t pin, int val)
{
    1ad8:	df 93       	push	r29
    1ada:	89 32       	cpi	r24, 0x29	; 41
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:404
  check_valid_digital_pin(pin);   // Compile error if pin is constant and isn't a pin.
  check_valid_duty_cycle(val);    // Compile error if constant duty cycle isn't between 0 and 255, inclusive. If those are generated at runtime, it is truncated to that range.
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1adc:	08 f0       	brcs	.+2      	; 0x1ae0 <analogWrite+0xa>
    1ade:	42 c0       	rjmp	.+132    	; 0x1b64 <analogWrite+0x8e>
check_valid_digital_pin():
    1ae0:	48 2f       	mov	r20, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:36
 * functions) to tell them what kind of mode it's to be used in. This also helps with providing useful and accurate
 * error messages and codes at runtime, since we have no other way to report such.                                 */

#define SINGLE_ENDED 254
inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if(__builtin_constant_p(pin)) {
    1ae2:	50 e0       	ldi	r21, 0x00	; 0
analogWrite():
    1ae4:	fa 01       	movw	r30, r20
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:404

void analogWrite(uint8_t pin, int val)
{
  check_valid_digital_pin(pin);   // Compile error if pin is constant and isn't a pin.
  check_valid_duty_cycle(val);    // Compile error if constant duty cycle isn't between 0 and 255, inclusive. If those are generated at runtime, it is truncated to that range.
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1ae6:	e9 58       	subi	r30, 0x89	; 137
    1ae8:	ff 4b       	sbci	r31, 0xBF	; 191
    1aea:	90 81       	ld	r25, Z
    1aec:	9f 3f       	cpi	r25, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:405
  if(bit_mask == NOT_A_PIN) return;
    1aee:	d1 f1       	breq	.+116    	; 0x1b64 <analogWrite+0x8e>
_pinMode():
    1af0:	fa 01       	movw	r30, r20
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1af2:	e0 56       	subi	r30, 0x60	; 96
    1af4:	ff 4b       	sbci	r31, 0xBF	; 191
    1af6:	30 81       	ld	r19, Z
    1af8:	20 e2       	ldi	r18, 0x20	; 32
    1afa:	32 9f       	mul	r19, r18
    1afc:	d0 01       	movw	r26, r0
    1afe:	11 24       	eor	r1, r1
    1b00:	bc 5f       	subi	r27, 0xFC	; 252
    1b02:	11 96       	adiw	r26, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1b04:	9c 93       	st	X, r25
    1b06:	11 97       	sbiw	r26, 0x01	; 1
analogWrite():
    1b08:	fa 01       	movw	r30, r20
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:416
  //
  // "Uuugh! I hate this kind of crap..." -Spence
  //
  pinMode(pin, OUTPUT);

  uint8_t digital_pin_timer =  digitalPinToTimer(pin); // NON-TCA timer!
    1b0a:	e5 5f       	subi	r30, 0xF5	; 245
    1b0c:	ff 4b       	sbci	r31, 0xBF	; 191
    1b0e:	e0 81       	ld	r30, Z
    1b10:	e0 38       	cpi	r30, 0x80	; 128
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:424
  }
  uint8_t* timer_cmp_out;
  #if defined(NO_GLITCH_TIMERD)
    if (digital_pin_timer != TIMERD0 && digital_pin_timer != DACOUT)
  #else
    if (digital_pin_timer != DACOUT)
    1b12:	09 f4       	brne	.+2      	; 0x1b16 <analogWrite+0x40>
    1b14:	d6 c0       	rjmp	.+428    	; 0x1cc2 <analogWrite+0x1ec>
    1b16:	61 15       	cp	r22, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:427
  #endif
  { /* Opening of body for above */
    if(val <= 0){ /* if zero or negative drive digital low */
    1b18:	71 05       	cpc	r23, r1
    1b1a:	21 f4       	brne	.+8      	; 0x1b24 <analogWrite+0x4e>
    1b1c:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:428
      return digitalWrite(pin, LOW);
    1b1e:	df 91       	pop	r29
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:675
      } else {
        digitalWrite(pin, HIGH);
      }
      break;
  }
}
    1b20:	cf 91       	pop	r28
    1b22:	a3 cb       	rjmp	.-2234   	; 0x126a <digitalWrite>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:430
  #endif
  { /* Opening of body for above */
    if(val <= 0){ /* if zero or negative drive digital low */
      return digitalWrite(pin, LOW);
    } else if(val >= 255){  /* if max or greater drive digital high */
      return digitalWrite(pin, HIGH);
    1b24:	6f 3f       	cpi	r22, 0xFF	; 255
    1b26:	71 05       	cpc	r23, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:429
    if (digital_pin_timer != DACOUT)
  #endif
  { /* Opening of body for above */
    if(val <= 0){ /* if zero or negative drive digital low */
      return digitalWrite(pin, LOW);
    } else if(val >= 255){  /* if max or greater drive digital high */
    1b28:	11 f4       	brne	.+4      	; 0x1b2e <analogWrite+0x58>
    1b2a:	61 e0       	ldi	r22, 0x01	; 1
    1b2c:	f8 cf       	rjmp	.-16     	; 0x1b1e <analogWrite+0x48>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:430
      return digitalWrite(pin, HIGH);
    1b2e:	90 34       	cpi	r25, 0x40	; 64
    1b30:	08 f0       	brcs	.+2      	; 0x1b34 <analogWrite+0x5e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:442
 *switch (digital_pin_timer) {
 *  case TIMERA0:
 */


  if (bit_mask < 0x40 ) { //if could be on a TCA
    1b32:	cb c0       	rjmp	.+406    	; 0x1cca <analogWrite+0x1f4>
    1b34:	20 91 e6 05 	lds	r18, 0x05E6	; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:444
    uint8_t portnum  = digitalPinToPort(pin);
    uint8_t tcaroute = PORTMUX.TCAROUTEA;
    1b38:	f2 2f       	mov	r31, r18
    1b3a:	f7 70       	andi	r31, 0x07	; 7
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:446

    if ((portnum == (tcaroute & (0x07))) && (PeripheralControl & TIMERA0)) {
    1b3c:	f3 13       	cpse	r31, r19
    1b3e:	1a c0       	rjmp	.+52     	; 0x1b74 <analogWrite+0x9e>
    1b40:	e0 e0       	ldi	r30, 0x00	; 0
    1b42:	95 30       	cpi	r25, 0x05	; 5
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:447
      uint8_t offset = 0;
    1b44:	10 f0       	brcs	.+4      	; 0x1b4a <analogWrite+0x74>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:448
      if (bit_mask > 0x04) { //separate high from low timers
    1b46:	99 0f       	add	r25, r25
    1b48:	e1 e0       	ldi	r30, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:449
        bit_mask <<= 1;
    1b4a:	89 2f       	mov	r24, r25
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:450
        offset = 1;
    1b4c:	84 74       	andi	r24, 0x44	; 68
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:453
      }
      /* TCA0 is on this port - it's our timer! */
      if      (bit_mask & 0x44) offset += 4;
    1b4e:	69 f0       	breq	.+26     	; 0x1b6a <analogWrite+0x94>
    1b50:	ec 5f       	subi	r30, 0xFC	; 252
    1b52:	f0 e0       	ldi	r31, 0x00	; 0
    1b54:	e8 5d       	subi	r30, 0xD8	; 216
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:455
      else if (bit_mask & 0x22) offset += 2;
      timer_cmp_out     = ((uint8_t*) (&TCA0.SPLIT.LCMP0)) + offset;
    1b56:	f5 4f       	sbci	r31, 0xF5	; 245
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:456
      (*timer_cmp_out)  = (val);
    1b58:	60 83       	st	Z, r22
    1b5a:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7e0a01>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:457
      TCA0.SPLIT.CTRLB |= bit_mask;
    1b5e:	98 2b       	or	r25, r24
    1b60:	90 93 01 0a 	sts	0x0A01, r25	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7e0a01>
    1b64:	df 91       	pop	r29
    1b66:	cf 91       	pop	r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:675
      } else {
        digitalWrite(pin, HIGH);
      }
      break;
  }
}
    1b68:	08 95       	ret
    1b6a:	89 2f       	mov	r24, r25
    1b6c:	82 72       	andi	r24, 0x22	; 34
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:454
        bit_mask <<= 1;
        offset = 1;
      }
      /* TCA0 is on this port - it's our timer! */
      if      (bit_mask & 0x44) offset += 4;
      else if (bit_mask & 0x22) offset += 2;
    1b6e:	89 f3       	breq	.-30     	; 0x1b52 <analogWrite+0x7c>
    1b70:	ee 5f       	subi	r30, 0xFE	; 254
    1b72:	ef cf       	rjmp	.-34     	; 0x1b52 <analogWrite+0x7c>
    1b74:	28 71       	andi	r18, 0x18	; 24
    1b76:	36 30       	cpi	r19, 0x06	; 6
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:465


    #ifdef TCA1
/*  case TIMERA1:
 */
    tcaroute &= (0x18);
    1b78:	a9 f4       	brne	.+42     	; 0x1ba4 <analogWrite+0xce>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:467
    /*  What about TCA1? */
    if (((portnum == 6 && tcaroute == 0x18) || (portnum == 1 && tcaroute ==0)) && (PeripheralControl & TIMERA1)) {
    1b7a:	28 31       	cpi	r18, 0x18	; 24
    1b7c:	b9 f4       	brne	.+46     	; 0x1bac <analogWrite+0xd6>
    1b7e:	e0 e0       	ldi	r30, 0x00	; 0
    1b80:	95 30       	cpi	r25, 0x05	; 5
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:469
      /* We are on TCA1 - Set pwm and return */
      uint8_t offset = 0;
    1b82:	10 f0       	brcs	.+4      	; 0x1b88 <analogWrite+0xb2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:470
      if (bit_mask > 0x04) { //separate high from low timers
    1b84:	99 0f       	add	r25, r25
    1b86:	e1 e0       	ldi	r30, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:471
        bit_mask <<= 1;
    1b88:	89 2f       	mov	r24, r25
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:472
        offset = 1;
    1b8a:	84 74       	andi	r24, 0x44	; 68
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:475
      }
      /* TCA0 is on this port - it's our timer! */
      if      (bit_mask & 0x44) offset += 4;
    1b8c:	d9 f0       	breq	.+54     	; 0x1bc4 <analogWrite+0xee>
    1b8e:	ec 5f       	subi	r30, 0xFC	; 252
    1b90:	f0 e0       	ldi	r31, 0x00	; 0
    1b92:	e8 59       	subi	r30, 0x98	; 152
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:477
      else if (bit_mask & 0x22) offset += 2;
      timer_cmp_out     = ((uint8_t*) (&TCA1.SPLIT.LCMP0)) + offset;
    1b94:	f5 4f       	sbci	r31, 0xF5	; 245
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:478
      (*timer_cmp_out)  = (val);
    1b96:	60 83       	st	Z, r22
    1b98:	80 91 41 0a 	lds	r24, 0x0A41	; 0x800a41 <__TEXT_REGION_LENGTH__+0x7e0a41>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:479
      TCA1.SPLIT.CTRLB |= bit_mask;
    1b9c:	98 2b       	or	r25, r24
    1b9e:	90 93 41 0a 	sts	0x0A41, r25	; 0x800a41 <__TEXT_REGION_LENGTH__+0x7e0a41>
    1ba2:	e0 cf       	rjmp	.-64     	; 0x1b64 <analogWrite+0x8e>
    1ba4:	31 30       	cpi	r19, 0x01	; 1
    1ba6:	11 f4       	brne	.+4      	; 0x1bac <analogWrite+0xd6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:467
    #ifdef TCA1
/*  case TIMERA1:
 */
    tcaroute &= (0x18);
    /*  What about TCA1? */
    if (((portnum == 6 && tcaroute == 0x18) || (portnum == 1 && tcaroute ==0)) && (PeripheralControl & TIMERA1)) {
    1ba8:	22 23       	and	r18, r18
    1baa:	49 f3       	breq	.-46     	; 0x1b7e <analogWrite+0xa8>
    1bac:	e0 34       	cpi	r30, 0x40	; 64
    1bae:	39 f1       	breq	.+78     	; 0x1bfe <analogWrite+0x128>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:485
      return;
    }
//  break;
  #endif
  }
  switch (digital_pin_timer) {
    1bb0:	70 f4       	brcc	.+28     	; 0x1bce <analogWrite+0xf8>
    1bb2:	90 ee       	ldi	r25, 0xE0	; 224
    1bb4:	9e 0f       	add	r25, r30
    1bb6:	95 30       	cpi	r25, 0x05	; 5
    1bb8:	90 f0       	brcs	.+36     	; 0x1bde <analogWrite+0x108>
    1bba:	60 38       	cpi	r22, 0x80	; 128
    1bbc:	71 05       	cpc	r23, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:668
  #endif
    /* If non timer pin, or unknown timer definition. */
    /* do a digital write */
    case NOT_ON_TIMER:
    default:
      if (val < 128) {
    1bbe:	0c f0       	brlt	.+2      	; 0x1bc2 <analogWrite+0xec>
    1bc0:	b4 cf       	rjmp	.-152    	; 0x1b2a <analogWrite+0x54>
    1bc2:	ac cf       	rjmp	.-168    	; 0x1b1c <analogWrite+0x46>
    1bc4:	89 2f       	mov	r24, r25
    1bc6:	82 72       	andi	r24, 0x22	; 34
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:476
        bit_mask <<= 1;
        offset = 1;
      }
      /* TCA0 is on this port - it's our timer! */
      if      (bit_mask & 0x44) offset += 4;
      else if (bit_mask & 0x22) offset += 2;
    1bc8:	19 f3       	breq	.-58     	; 0x1b90 <analogWrite+0xba>
    1bca:	ee 5f       	subi	r30, 0xFE	; 254
    1bcc:	e1 cf       	rjmp	.-62     	; 0x1b90 <analogWrite+0xba>
    1bce:	e0 38       	cpi	r30, 0x80	; 128
    1bd0:	a1 f7       	brne	.-24     	; 0x1bba <analogWrite+0xe4>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:485
      return;
    }
//  break;
  #endif
  }
  switch (digital_pin_timer) {
    1bd2:	60 93 a3 06 	sts	0x06A3, r22	; 0x8006a3 <__TEXT_REGION_LENGTH__+0x7e06a3>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:523
      break;
  #if defined(DAC0)
    case DACOUT:
      #ifdef DAC0_DATAH
        //DAC0.DATAL = 0xC0;
        DAC0.DATAH = val;
    1bd6:	81 e4       	ldi	r24, 0x41	; 65
    1bd8:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7e06a0>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:527
      #else
        DAC0.DATA = val;
      #endif
      DAC0.CTRLA=0x41; //OUTEN=1, ENABLE=1
    1bdc:	c3 cf       	rjmp	.-122    	; 0x1b64 <analogWrite+0x8e>
    1bde:	90 e1       	ldi	r25, 0x10	; 16
    1be0:	e9 9f       	mul	r30, r25
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:494
    case TIMERB3:
    case TIMERB4:

      /* Get pointer to timer, TIMERB0 order definition in Arduino.h*/
      //assert (((TIMERB0 - TIMERB3) == 2));
      timer_B = ((TCB_t *)&TCB0 + (digital_pin_timer - TIMERB0));
    1be2:	f0 01       	movw	r30, r0
    1be4:	11 24       	eor	r1, r1
    1be6:	f7 5f       	subi	r31, 0xF7	; 247
    1be8:	91 81       	ldd	r25, Z+1	; 0x01
    1bea:	97 70       	andi	r25, 0x07	; 7
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:496
      // make sure the timer is in PWM mode
      if (((timer_B->CTRLB) & TCB_CNTMODE_gm) == TCB_CNTMODE_PWM8_gc ) {
    1bec:	97 30       	cpi	r25, 0x07	; 7
    1bee:	29 f7       	brne	.-54     	; 0x1bba <analogWrite+0xe4>
    1bf0:	84 85       	ldd	r24, Z+12	; 0x0c
    1bf2:	84 87       	std	Z+12, r24	; 0x0c
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:501
        /* set duty cycle */
        #if defined(ERRATA_TCB_CCMP) && ERRATA_TCB_CCMP == 0
          timer_B->CCMPH = val; /* does not yet exist */
        #else
          timer_B->CCMPL = timer_B->CCMPL;   // load temp register with the period, 254 have to first make sure temp register holds 254
    1bf4:	65 87       	std	Z+13, r22	; 0x0d
    1bf6:	81 81       	ldd	r24, Z+1	; 0x01
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:502
          timer_B->CCMPH = val;              /* We can leave interrupts on interrupts - only a read of the count in the ISR would mess things up.
    1bf8:	80 61       	ori	r24, 0x10	; 16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:508
           * That is a wacky corner case. If they have timer in 8-bit PWM mode, and they write the value in with another call
           * Yes that's a race conditions and the outside-of-isr call will win. But no corruption will happen, and it would be the same
           * as if the ISR was called 1 clock cycle sooner. No big deal. */
        #endif
        /* Enable Timer Output */
        timer_B->CTRLB |= (TCB_CCMPEN_bm);
    1bfa:	81 83       	std	Z+1, r24	; 0x01
    1bfc:	b3 cf       	rjmp	.-154    	; 0x1b64 <analogWrite+0x8e>
    1bfe:	61 15       	cp	r22, r1
    1c00:	71 05       	cpc	r23, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:543
        //
        // If this is not defined, then the 0% and 100% cases will instead have been caught by the conditional
        // at the start of analogWrite().

        uint8_t set_inven = 0; // this will be set to 1 if we're setting the pin to a duty cycle of 100%
        if(val <= 0){
    1c02:	19 f0       	breq	.+6      	; 0x1c0a <analogWrite+0x134>
    1c04:	6f 3f       	cpi	r22, 0xFF	; 255
    1c06:	71 05       	cpc	r23, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:545
          val = 0;
        } else if (val >= 255){
    1c08:	11 f0       	breq	.+4      	; 0x1c0e <analogWrite+0x138>
    1c0a:	80 e0       	ldi	r24, 0x00	; 0
    1c0c:	03 c0       	rjmp	.+6      	; 0x1c14 <analogWrite+0x13e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:542
        // will then be inverted.
        //
        // If this is not defined, then the 0% and 100% cases will instead have been caught by the conditional
        // at the start of analogWrite().

        uint8_t set_inven = 0; // this will be set to 1 if we're setting the pin to a duty cycle of 100%
    1c0e:	81 e0       	ldi	r24, 0x01	; 1
    1c10:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:547
        if(val <= 0){
          val = 0;
        } else if (val >= 255){
          val = 0;
          set_inven = 1;
    1c12:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:546

        uint8_t set_inven = 0; // this will be set to 1 if we're setting the pin to a duty cycle of 100%
        if(val <= 0){
          val = 0;
        } else if (val >= 255){
          val = 0;
    1c14:	2f ef       	ldi	r18, 0xFF	; 255
    1c16:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:572
          }
        #else
          bit_mask = (bit_mask == 0x02 ? 0x80 : 0x40);
        #endif
      #endif
      val = 255-val;
    1c18:	26 1b       	sub	r18, r22
    1c1a:	37 0b       	sbc	r19, r23
    1c1c:	60 91 ae 0b 	lds	r22, 0x0BAE	; 0x800bae <__TEXT_REGION_LENGTH__+0x7e0bae>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:573
      uint8_t temp = TCD0.CMPBCLRL;
    1c20:	60 91 af 0b 	lds	r22, 0x0BAF	; 0x800baf <__TEXT_REGION_LENGTH__+0x7e0baf>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:574
      temp = TCD0.CMPBCLRH;
    1c24:	66 23       	and	r22, r22
    1c26:	21 f0       	breq	.+8      	; 0x1c30 <analogWrite+0x15a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:579
      //
      // Read both, only retaining the high byte. Need to read both to see high byte because 16-bit register
      // Reading just high doesn't work. Checking for CMPBCLR = 509, 1019, or at 32 MHz+, 2039 or 4079 for which we need to shift
      // the duty cycle left to match
      if (temp) {   // TOP > 254
    1c28:	63 30       	cpi	r22, 0x03	; 3
    1c2a:	b8 f5       	brcc	.+110    	; 0x1c9a <analogWrite+0x1c4>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:581
        val <<= 1;  // leftshift once is good for 509
        if (temp   >= 0x03) val <<= 1;  // 1019, 2039 or 4079
    1c2c:	22 0f       	add	r18, r18
    1c2e:	33 1f       	adc	r19, r19
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:580
      //
      // Read both, only retaining the high byte. Need to read both to see high byte because 16-bit register
      // Reading just high doesn't work. Checking for CMPBCLR = 509, 1019, or at 32 MHz+, 2039 or 4079 for which we need to shift
      // the duty cycle left to match
      if (temp) {   // TOP > 254
        val <<= 1;  // leftshift once is good for 509
    1c30:	10 97       	sbiw	r26, 0x00	; 0
    1c32:	c1 f1       	breq	.+112    	; 0x1ca4 <analogWrite+0x1ce>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:589
          if (temp == 0x0F) val <<= 1;  // 4079
        #endif
      }

      #if defined(NO_GLITCH_TIMERD0)
        volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitPosition(pin));
    1c34:	4c 5c       	subi	r20, 0xCC	; 204
    1c36:	5f 4b       	sbci	r21, 0xBF	; 191
    1c38:	ea 01       	movw	r28, r20
    1c3a:	e8 81       	ld	r30, Y
    1c3c:	ef 3f       	cpi	r30, 0xFF	; 255
    1c3e:	91 f1       	breq	.+100    	; 0x1ca4 <analogWrite+0x1ce>
    1c40:	50 96       	adiw	r26, 0x10	; 16
    1c42:	ea 0f       	add	r30, r26
    1c44:	fb 2f       	mov	r31, r27
    1c46:	f1 1d       	adc	r31, r1
    1c48:	4f b7       	in	r20, 0x3f	; 63
    1c4a:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:596
        // We had been doing it closer to where we needed it, but there's no need to wait
        // until we have interrupts off to figure this out (though we do need them off when)
        // access it!)
      #endif
      // interrupts off while this runs - we really don't want this interrupted!
      uint8_t oldSREG = SREG;
    1c4c:	21 50       	subi	r18, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:597
      cli();
    1c4e:	31 09       	sbc	r19, r1
    1c50:	59 2f       	mov	r21, r25
    1c52:	5a 7a       	andi	r21, 0xAA	; 170
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:617
       * WOB (now WOB and WOC would output same thing) while WOA, WOB, WOC would not, so
       * WOA and WOC would be the pair outputting the same thing). And then you'd need to
       * decide how to handle the above situation when the user then wrote to WOD.
       * Better to just declare that CMPA shall drive WOC, and CMPB shall drive WOD.
       *-----------------------------------------------------------------------------------------*/
      if (bit_mask & 0xAA) {
    1c54:	51 f1       	breq	.+84     	; 0x1caa <analogWrite+0x1d4>
    1c56:	20 93 ac 0b 	sts	0x0BAC, r18	; 0x800bac <__TEXT_REGION_LENGTH__+0x7e0bac>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:618
        TCD0.CMPBSET= val - 1;
    1c5a:	30 93 ad 0b 	sts	0x0BAD, r19	; 0x800bad <__TEXT_REGION_LENGTH__+0x7e0bad>
    1c5e:	20 91 92 0b 	lds	r18, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:623
      } else {
        TCD0.CMPASET= val - 1;
      }
      /* Check if channel active, if not, have to turn it on */
      if (!(TCD0.FAULTCTRL & bit_mask)) {
    1c62:	29 23       	and	r18, r25
    1c64:	39 f5       	brne	.+78     	; 0x1cb4 <analogWrite+0x1de>
    1c66:	30 91 80 0b 	lds	r19, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:638
         * happen if they are modifying TCD0 registers themselves. Though per core docs, we make
         * no promises in that case, the fact that the fix for a call to analogWrite() in a class
         * constructor (something that is not proscribed by docs) makes that case less bad is an
         * added bonus.
         *---------------------------------------------------------------------------------------*/
        uint8_t temp2 = TCD0.CTRLA;
    1c6a:	23 2f       	mov	r18, r19
    1c6c:	2e 7f       	andi	r18, 0xFE	; 254
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:639
        TCD0.CTRLA = temp2 & (~TCD_ENABLE_bm);
    1c6e:	20 93 80 0b 	sts	0x0B80, r18	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
    1c72:	20 91 8e 0b 	lds	r18, 0x0B8E	; 0x800b8e <__TEXT_REGION_LENGTH__+0x7e0b8e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:640
        while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
    1c76:	20 ff       	sbrs	r18, 0
    1c78:	fc cf       	rjmp	.-8      	; 0x1c72 <analogWrite+0x19c>
    1c7a:	20 91 92 0b 	lds	r18, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:641
        _PROTECTED_WRITE(TCD0.FAULTCTRL, (bit_mask | TCD0.FAULTCTRL));
    1c7e:	92 2b       	or	r25, r18
    1c80:	28 ed       	ldi	r18, 0xD8	; 216
    1c82:	24 bf       	out	0x34, r18	; 52
    1c84:	90 93 92 0b 	sts	0x0B92, r25	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
    1c88:	30 93 80 0b 	sts	0x0B80, r19	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:643
        //while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
        TCD0.CTRLA = temp2; // re-enable it if it was enabled
    1c8c:	81 11       	cpse	r24, r1
    1c8e:	16 c0       	rjmp	.+44     	; 0x1cbc <analogWrite+0x1e6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:651
      }

      #if defined(NO_GLITCH_TIMERD0)
        // In this mode, we need to check set_inven, and set INVEN if it was called with 100% duty cycle
        // and unset that bit otherwise.
        if (set_inven == 0){
    1c90:	80 81       	ld	r24, Z
    1c92:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:654
          // we are not setting invert to make the pin HIGH when not set; either was 0 (just set CMPxSET > CMPxCLR)
          // or somewhere in between.
          *pin_ctrl_reg &= ~PORT_INVEN_bm;
    1c94:	80 83       	st	Z, r24
    1c96:	4f bf       	out	0x3f, r20	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:657
        } else {
          // we *are* turning off PWM while forcing pin high - analogwrite(pin,255) was called on TCD0 PWM pin...
          *pin_ctrl_reg |= PORT_INVEN_bm;
    1c98:	65 cf       	rjmp	.-310    	; 0x1b64 <analogWrite+0x8e>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:660
        }
      #endif
      SREG = oldSREG; // Turn interrupts back on, if they were off.
    1c9a:	22 0f       	add	r18, r18
    1c9c:	33 1f       	adc	r19, r19
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:581
      // Read both, only retaining the high byte. Need to read both to see high byte because 16-bit register
      // Reading just high doesn't work. Checking for CMPBCLR = 509, 1019, or at 32 MHz+, 2039 or 4079 for which we need to shift
      // the duty cycle left to match
      if (temp) {   // TOP > 254
        val <<= 1;  // leftshift once is good for 509
        if (temp   >= 0x03) val <<= 1;  // 1019, 2039 or 4079
    1c9e:	22 0f       	add	r18, r18
    1ca0:	33 1f       	adc	r19, r19
    1ca2:	c6 cf       	rjmp	.-116    	; 0x1c30 <analogWrite+0x15a>
    1ca4:	f0 e0       	ldi	r31, 0x00	; 0
    1ca6:	e0 e0       	ldi	r30, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:589
          if (temp == 0x0F) val <<= 1;  // 4079
        #endif
      }

      #if defined(NO_GLITCH_TIMERD0)
        volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitPosition(pin));
    1ca8:	cf cf       	rjmp	.-98     	; 0x1c48 <analogWrite+0x172>
    1caa:	20 93 a8 0b 	sts	0x0BA8, r18	; 0x800ba8 <__TEXT_REGION_LENGTH__+0x7e0ba8>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:620
       * Better to just declare that CMPA shall drive WOC, and CMPB shall drive WOD.
       *-----------------------------------------------------------------------------------------*/
      if (bit_mask & 0xAA) {
        TCD0.CMPBSET= val - 1;
      } else {
        TCD0.CMPASET= val - 1;
    1cae:	30 93 a9 0b 	sts	0x0BA9, r19	; 0x800ba9 <__TEXT_REGION_LENGTH__+0x7e0ba9>
    1cb2:	d5 cf       	rjmp	.-86     	; 0x1c5e <analogWrite+0x188>
    1cb4:	91 e0       	ldi	r25, 0x01	; 1
    1cb6:	90 93 84 0b 	sts	0x0B84, r25	; 0x800b84 <__TEXT_REGION_LENGTH__+0x7e0b84>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:645
        while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
        _PROTECTED_WRITE(TCD0.FAULTCTRL, (bit_mask | TCD0.FAULTCTRL));
        //while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
        TCD0.CTRLA = temp2; // re-enable it if it was enabled
      } else {
        TCD0.CTRLE = TCD_SYNCEOC_bm; // it was already on - just set new value and set sync flag.
    1cba:	e8 cf       	rjmp	.-48     	; 0x1c8c <analogWrite+0x1b6>
    1cbc:	80 81       	ld	r24, Z
    1cbe:	80 68       	ori	r24, 0x80	; 128
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:657
          // we are not setting invert to make the pin HIGH when not set; either was 0 (just set CMPxSET > CMPxCLR)
          // or somewhere in between.
          *pin_ctrl_reg &= ~PORT_INVEN_bm;
        } else {
          // we *are* turning off PWM while forcing pin high - analogwrite(pin,255) was called on TCD0 PWM pin...
          *pin_ctrl_reg |= PORT_INVEN_bm;
    1cc0:	e9 cf       	rjmp	.-46     	; 0x1c94 <analogWrite+0x1be>
    1cc2:	90 34       	cpi	r25, 0x40	; 64
    1cc4:	08 f4       	brcc	.+2      	; 0x1cc8 <analogWrite+0x1f2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:442
 *switch (digital_pin_timer) {
 *  case TIMERA0:
 */


  if (bit_mask < 0x40 ) { //if could be on a TCA
    1cc6:	36 cf       	rjmp	.-404    	; 0x1b34 <analogWrite+0x5e>
    1cc8:	84 cf       	rjmp	.-248    	; 0x1bd2 <analogWrite+0xfc>
    1cca:	e0 32       	cpi	r30, 0x20	; 32
    1ccc:	08 f4       	brcc	.+2      	; 0x1cd0 <analogWrite+0x1fa>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:485
      return;
    }
//  break;
  #endif
  }
  switch (digital_pin_timer) {
    1cce:	75 cf       	rjmp	.-278    	; 0x1bba <analogWrite+0xe4>
    1cd0:	e5 32       	cpi	r30, 0x25	; 37
    1cd2:	08 f4       	brcc	.+2      	; 0x1cd6 <analogWrite+0x200>
    1cd4:	84 cf       	rjmp	.-248    	; 0x1bde <analogWrite+0x108>
    1cd6:	e0 34       	cpi	r30, 0x40	; 64
    1cd8:	09 f4       	brne	.+2      	; 0x1cdc <analogWrite+0x206>
    1cda:	97 cf       	rjmp	.-210    	; 0x1c0a <analogWrite+0x134>
    1cdc:	6e cf       	rjmp	.-292    	; 0x1bba <analogWrite+0xe4>

00001cde <hd44780_pinIO::iosetBacklight(unsigned char)>:
iosetBacklight():
    1cde:	cf 93       	push	r28
    1ce0:	df 93       	push	r29
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:342
	return(hd44780::RV_ENOERR); // it never fails
}

// iosetBacklight() - set backlight brightness
// if dimming not supported, any non zero dimvalue turns backlight on
int iosetBacklight(uint8_t dimvalue)
    1ce2:	fc 01       	movw	r30, r24
    1ce4:	87 a1       	ldd	r24, Z+39	; 0x27
    1ce6:	8f 3f       	cpi	r24, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:344
{
	if (_bl == 0xff )
    1ce8:	09 f4       	brne	.+2      	; 0x1cec <hd44780_pinIO::iosetBacklight(unsigned char)+0xe>
    1cea:	65 c0       	rjmp	.+202    	; 0x1db6 <hd44780_pinIO::iosetBacklight(unsigned char)+0xd8>
    1cec:	90 a5       	ldd	r25, Z+40	; 0x28
    1cee:	9e 3f       	cpi	r25, 0xFE	; 254
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:353
	// In HIGHZ active level, the output is is never driven high, instead the pin is put
	// into input mode to turn on the backlight.
	// To turn off the backlight, the pin is flipped to output mode.
	// because the pin is never set to HIGH, when the pin is set to output mode it will be LOW.

	if(_blLevel == HIGHZ)
    1cf0:	09 f0       	breq	.+2      	; 0x1cf4 <hd44780_pinIO::iosetBacklight(unsigned char)+0x16>
    1cf2:	42 c0       	rjmp	.+132    	; 0x1d78 <hd44780_pinIO::iosetBacklight(unsigned char)+0x9a>
    1cf4:	28 2f       	mov	r18, r24
    1cf6:	30 e0       	ldi	r19, 0x00	; 0
    1cf8:	66 23       	and	r22, r22
    1cfa:	59 f1       	breq	.+86     	; 0x1d52 <hd44780_pinIO::iosetBacklight(unsigned char)+0x74>
_pinMode():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:355
	{
		if(dimvalue)
    1cfc:	89 32       	cpi	r24, 0x29	; 41
    1cfe:	18 f5       	brcc	.+70     	; 0x1d46 <hd44780_pinIO::iosetBacklight(unsigned char)+0x68>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1d00:	f9 01       	movw	r30, r18
    1d02:	e9 58       	subi	r30, 0x89	; 137
    1d04:	ff 4b       	sbci	r31, 0xBF	; 191
    1d06:	80 81       	ld	r24, Z
    1d08:	8f 3f       	cpi	r24, 0xFF	; 255
    1d0a:	e9 f0       	breq	.+58     	; 0x1d46 <hd44780_pinIO::iosetBacklight(unsigned char)+0x68>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1d0c:	f9 01       	movw	r30, r18
    1d0e:	e0 56       	subi	r30, 0x60	; 96
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1d10:	ff 4b       	sbci	r31, 0xBF	; 191
    1d12:	e0 81       	ld	r30, Z
    1d14:	40 e2       	ldi	r20, 0x20	; 32
    1d16:	e4 9f       	mul	r30, r20
    1d18:	f0 01       	movw	r30, r0
    1d1a:	11 24       	eor	r1, r1
    1d1c:	fc 5f       	subi	r31, 0xFC	; 252
    1d1e:	2c 5c       	subi	r18, 0xCC	; 204
    1d20:	3f 4b       	sbci	r19, 0xBF	; 191
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:231
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    1d22:	e9 01       	movw	r28, r18
    1d24:	a8 81       	ld	r26, Y
    1d26:	af 3f       	cpi	r26, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    1d28:	89 f0       	breq	.+34     	; 0x1d4c <hd44780_pinIO::iosetBacklight(unsigned char)+0x6e>
    1d2a:	9f 01       	movw	r18, r30
    1d2c:	20 5f       	subi	r18, 0xF0	; 240
    1d2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d30:	a2 0f       	add	r26, r18
    1d32:	b3 2f       	mov	r27, r19
    1d34:	b1 1d       	adc	r27, r1
    1d36:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    uint8_t status = SREG;              /* Save state */
    1d38:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    1d3a:	82 83       	std	Z+2, r24	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    1d3c:	9c 91       	ld	r25, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:240
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    1d3e:	97 7f       	andi	r25, 0xF7	; 247
    1d40:	9c 93       	st	X, r25
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:241
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    1d42:	86 83       	std	Z+6, r24	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    }
    SREG = status;                      /* Restore state */
    1d44:	2f bf       	out	0x3f, r18	; 63
iosetBacklight():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:359
			pinMode(_bl, INPUT);
		else
			pinMode(_bl, OUTPUT);
		return(hd44780::RV_ENOERR);
    1d46:	90 e0       	ldi	r25, 0x00	; 0
    1d48:	80 e0       	ldi	r24, 0x00	; 0
    1d4a:	37 c0       	rjmp	.+110    	; 0x1dba <hd44780_pinIO::iosetBacklight(unsigned char)+0xdc>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:232
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    1d4c:	b0 e0       	ldi	r27, 0x00	; 0
    1d4e:	a0 e0       	ldi	r26, 0x00	; 0
    1d50:	f2 cf       	rjmp	.-28     	; 0x1d36 <hd44780_pinIO::iosetBacklight(unsigned char)+0x58>
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:221
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    1d52:	89 32       	cpi	r24, 0x29	; 41
    1d54:	c0 f7       	brcc	.-16     	; 0x1d46 <hd44780_pinIO::iosetBacklight(unsigned char)+0x68>
    1d56:	f9 01       	movw	r30, r18
    1d58:	e9 58       	subi	r30, 0x89	; 137
    1d5a:	ff 4b       	sbci	r31, 0xBF	; 191
    1d5c:	80 81       	ld	r24, Z
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:222
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    1d5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d60:	91 f3       	breq	.-28     	; 0x1d46 <hd44780_pinIO::iosetBacklight(unsigned char)+0x68>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:225
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    1d62:	20 56       	subi	r18, 0x60	; 96
    1d64:	3f 4b       	sbci	r19, 0xBF	; 191
    1d66:	d9 01       	movw	r26, r18
    1d68:	ec 91       	ld	r30, X
    1d6a:	b0 e2       	ldi	r27, 0x20	; 32
    1d6c:	eb 9f       	mul	r30, r27
    1d6e:	f0 01       	movw	r30, r0
    1d70:	11 24       	eor	r1, r1
    1d72:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    1d74:	81 83       	std	Z+1, r24	; 0x01
    1d76:	e7 cf       	rjmp	.-50     	; 0x1d46 <hd44780_pinIO::iosetBacklight(unsigned char)+0x68>
iosetBacklight():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:378
	// so on ESP32 core, all you get is on/off
#if !defined(ARDUINO_ARCH_ESP32)

#if defined(digitalPinHasPWM)
   	// Newer 1.5x Arduino has a macro to check for PWM capability on a pin
	if(digitalPinHasPWM(_bl))
    1d78:	2a ed       	ldi	r18, 0xDA	; 218
    1d7a:	28 0f       	add	r18, r24
    1d7c:	22 30       	cpi	r18, 0x02	; 2
    1d7e:	20 f0       	brcs	.+8      	; 0x1d88 <hd44780_pinIO::iosetBacklight(unsigned char)+0xaa>
    1d80:	2c ef       	ldi	r18, 0xFC	; 252
    1d82:	28 0f       	add	r18, r24
    1d84:	20 31       	cpi	r18, 0x10	; 16
    1d86:	60 f4       	brcc	.+24     	; 0x1da0 <hd44780_pinIO::iosetBacklight(unsigned char)+0xc2>
    1d88:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:387
#else 
	if(0) // no way to tell so assume no PWM
#endif
	{
		// set PWM signal appropriately for active level
		if(_blLevel == HIGH)
    1d8a:	91 30       	cpi	r25, 0x01	; 1
    1d8c:	11 f4       	brne	.+4      	; 0x1d92 <hd44780_pinIO::iosetBacklight(unsigned char)+0xb4>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:393
		{
			analogWrite(_bl, dimvalue);
		}
		else 
		{
			analogWrite(_bl, 255 - dimvalue); // active low is inverse PWM
    1d8e:	a3 de       	rcall	.-698    	; 0x1ad6 <analogWrite>
    1d90:	da cf       	rjmp	.-76     	; 0x1d46 <hd44780_pinIO::iosetBacklight(unsigned char)+0x68>
    1d92:	2f ef       	ldi	r18, 0xFF	; 255
    1d94:	30 e0       	ldi	r19, 0x00	; 0
    1d96:	e9 01       	movw	r28, r18
    1d98:	c6 1b       	sub	r28, r22
    1d9a:	d7 0b       	sbc	r29, r23
    1d9c:	be 01       	movw	r22, r28
    1d9e:	f7 cf       	rjmp	.-18     	; 0x1d8e <hd44780_pinIO::iosetBacklight(unsigned char)+0xb0>
    1da0:	66 23       	and	r22, r22
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:401

	// No PWM support on pin, so
	// dimvalue 0 is off, any other value is on
	else
#endif
	if(((dimvalue) && (_blLevel == HIGH)) ||
    1da2:	29 f0       	breq	.+10     	; 0x1dae <hd44780_pinIO::iosetBacklight(unsigned char)+0xd0>
    1da4:	91 30       	cpi	r25, 0x01	; 1
    1da6:	29 f4       	brne	.+10     	; 0x1db2 <hd44780_pinIO::iosetBacklight(unsigned char)+0xd4>
    1da8:	61 e0       	ldi	r22, 0x01	; 1
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:404
			((dimvalue == 0) && (_blLevel == LOW)))
	{
		digitalWrite(_bl, HIGH);
    1daa:	5f da       	rcall	.-2882   	; 0x126a <digitalWrite>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:408
	}
	else
	{
		digitalWrite(_bl, LOW);
    1dac:	cc cf       	rjmp	.-104    	; 0x1d46 <hd44780_pinIO::iosetBacklight(unsigned char)+0x68>
    1dae:	99 23       	and	r25, r25
    1db0:	d9 f3       	breq	.-10     	; 0x1da8 <hd44780_pinIO::iosetBacklight(unsigned char)+0xca>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:402
	// No PWM support on pin, so
	// dimvalue 0 is off, any other value is on
	else
#endif
	if(((dimvalue) && (_blLevel == HIGH)) ||
			((dimvalue == 0) && (_blLevel == LOW)))
    1db2:	60 e0       	ldi	r22, 0x00	; 0
    1db4:	fa cf       	rjmp	.-12     	; 0x1daa <hd44780_pinIO::iosetBacklight(unsigned char)+0xcc>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:408
	{
		digitalWrite(_bl, HIGH);
	}
	else
	{
		digitalWrite(_bl, LOW);
    1db6:	8d ef       	ldi	r24, 0xFD	; 253
    1db8:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:345
// iosetBacklight() - set backlight brightness
// if dimming not supported, any non zero dimvalue turns backlight on
int iosetBacklight(uint8_t dimvalue)
{
	if (_bl == 0xff )
		return(hd44780::RV_ENOTSUP); // no backlight pin so nothing to do
    1dba:	df 91       	pop	r29
    1dbc:	cf 91       	pop	r28
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780ioClass/hd44780_pinIO.h:411
	else
	{
		digitalWrite(_bl, LOW);
	}
	return(hd44780::RV_ENOERR);
}
    1dbe:	08 95       	ret

00001dc0 <random(long, long)>:
random():
    1dc0:	8f 92       	push	r8
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:44
  }
  return random() % howbig;
}

long random(long howsmall, long howbig)
{
    1dc2:	9f 92       	push	r9
    1dc4:	af 92       	push	r10
    1dc6:	bf 92       	push	r11
    1dc8:	cf 92       	push	r12
    1dca:	df 92       	push	r13
    1dcc:	ef 92       	push	r14
    1dce:	ff 92       	push	r15
    1dd0:	4b 01       	movw	r8, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:45
  if (howsmall >= howbig) {
    1dd2:	5c 01       	movw	r10, r24
    1dd4:	82 16       	cp	r8, r18
    1dd6:	93 06       	cpc	r9, r19
    1dd8:	a4 06       	cpc	r10, r20
    1dda:	b5 06       	cpc	r11, r21
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:48
    return howsmall;
  }
  long diff = howbig - howsmall;
    1ddc:	9c f4       	brge	.+38     	; 0x1e04 <random(long, long)+0x44>
    1dde:	69 01       	movw	r12, r18
    1de0:	7a 01       	movw	r14, r20
    1de2:	c8 18       	sub	r12, r8
    1de4:	d9 08       	sbc	r13, r9
    1de6:	ea 08       	sbc	r14, r10
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:37
  }
}

long random(long howbig)
{
  if (howbig == 0) {
    1de8:	fb 08       	sbc	r15, r11
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:40
    return 0;
  }
  return random() % howbig;
    1dea:	41 f0       	breq	.+16     	; 0x1dfc <random(long, long)+0x3c>
    1dec:	0e 94 c1 20 	call	0x4182	; 0x4182 <random>
    1df0:	a7 01       	movw	r20, r14
    1df2:	96 01       	movw	r18, r12
    1df4:	0e 94 16 21 	call	0x422c	; 0x422c <__divmodsi4>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:49
{
  if (howsmall >= howbig) {
    return howsmall;
  }
  long diff = howbig - howsmall;
  return random(diff) + howsmall;
    1df8:	6b 01       	movw	r12, r22
    1dfa:	7c 01       	movw	r14, r24
    1dfc:	8c 0c       	add	r8, r12
    1dfe:	9d 1c       	adc	r9, r13
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:50
}
    1e00:	ae 1c       	adc	r10, r14
    1e02:	bf 1c       	adc	r11, r15
    1e04:	c5 01       	movw	r24, r10
    1e06:	b4 01       	movw	r22, r8
    1e08:	ff 90       	pop	r15
    1e0a:	ef 90       	pop	r14
    1e0c:	df 90       	pop	r13
    1e0e:	cf 90       	pop	r12
    1e10:	bf 90       	pop	r11
    1e12:	af 90       	pop	r10
    1e14:	9f 90       	pop	r9
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:342
  frameNumber = 0;
  currentSettingLeft = 0;
  currentSettingRight = 0;
}

void initColorsDrift2() {
    1e16:	8f 90       	pop	r8
    1e18:	08 95       	ret

00001e1a <initColorsDrift2()>:
initColorsDrift2():
    1e1a:	cf 92       	push	r12
    1e1c:	df 92       	push	r13
    1e1e:	ef 92       	push	r14
    1e20:	ff 92       	push	r15
    1e22:	0f 93       	push	r16
    1e24:	1f 93       	push	r17
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:343
  int len = (pgm_read_byte_near(&colorCount[getPalleteNumber()]) * (getDwellFrames() + getTransitionFrames()));
    1e26:	cf 93       	push	r28
    1e28:	df 93       	push	r29
    1e2a:	aa d8       	rcall	.-3756   	; 0xf80 <getPalleteNumber()>
    1e2c:	e8 2f       	mov	r30, r24
    1e2e:	f0 e0       	ldi	r31, 0x00	; 0
    1e30:	e7 5b       	subi	r30, 0xB7	; 183
    1e32:	f8 4f       	sbci	r31, 0xF8	; 248
    1e34:	c4 91       	lpm	r28, Z
    1e36:	c5 d8       	rcall	.-3702   	; 0xfc2 <getDwellFrames()>
    1e38:	8c 01       	movw	r16, r24
    1e3a:	ab d8       	rcall	.-3754   	; 0xf92 <getTransitionFrames()>
    1e3c:	80 0f       	add	r24, r16
    1e3e:	91 1f       	adc	r25, r17
    1e40:	c8 9f       	mul	r28, r24
    1e42:	60 01       	movw	r12, r0
    1e44:	c9 9f       	mul	r28, r25
    1e46:	d0 0c       	add	r13, r0
    1e48:	11 24       	eor	r1, r1
    1e4a:	10 e0       	ldi	r17, 0x00	; 0
    1e4c:	00 e0       	ldi	r16, 0x00	; 0
    1e4e:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:344
  for (int j = 0; j < LENGTH; j++) {
    1e50:	c0 e0       	ldi	r28, 0x00	; 0
    1e52:	0d 2c       	mov	r0, r13
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:345
    unsigned int r = random(0, len);
    1e54:	00 0c       	add	r0, r0
    1e56:	ee 08       	sbc	r14, r14
    1e58:	ff 08       	sbc	r15, r15
    1e5a:	a7 01       	movw	r20, r14
    1e5c:	96 01       	movw	r18, r12
    1e5e:	60 e0       	ldi	r22, 0x00	; 0
    1e60:	70 e0       	ldi	r23, 0x00	; 0
    1e62:	cb 01       	movw	r24, r22
    1e64:	ad df       	rcall	.-166    	; 0x1dc0 <random(long, long)>
    1e66:	cb 01       	movw	r24, r22
    1e68:	f8 01       	movw	r30, r16
    1e6a:	f5 95       	asr	r31
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:346
    scratch[((j * 3) / 2)] = r & 0xFF;
    1e6c:	e7 95       	ror	r30
    1e6e:	e7 56       	subi	r30, 0x67	; 103
    1e70:	fe 4b       	sbci	r31, 0xBE	; 190
    1e72:	60 83       	st	Z, r22
    1e74:	9e 01       	movw	r18, r28
    1e76:	35 95       	asr	r19
    1e78:	27 95       	ror	r18
    1e7a:	f9 01       	movw	r30, r18
    1e7c:	ee 0f       	add	r30, r30
    1e7e:	ff 1f       	adc	r31, r31
    1e80:	e2 0f       	add	r30, r18
    1e82:	f3 1f       	adc	r31, r19
    1e84:	e5 56       	subi	r30, 0x65	; 101
    1e86:	fe 4b       	sbci	r31, 0xBE	; 190
    1e88:	c0 ff       	sbrs	r28, 0
    1e8a:	19 c0       	rjmp	.+50     	; 0x1ebe <initColorsDrift2()+0xa4>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:347
    if (j & 1) {
    1e8c:	24 e0       	ldi	r18, 0x04	; 4
    1e8e:	96 95       	lsr	r25
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:348
      scratch[(j / 2) * 3 + 2] &= ((r >> 4) & 0xF0);
    1e90:	87 95       	ror	r24
    1e92:	2a 95       	dec	r18
    1e94:	e1 f7       	brne	.-8      	; 0x1e8e <initColorsDrift2()+0x74>
    1e96:	80 7f       	andi	r24, 0xF0	; 240
    1e98:	90 81       	ld	r25, Z
    1e9a:	89 23       	and	r24, r25
    1e9c:	80 83       	st	Z, r24
    1e9e:	21 96       	adiw	r28, 0x01	; 1
    1ea0:	0d 5f       	subi	r16, 0xFD	; 253
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:344
  currentSettingRight = 0;
}

void initColorsDrift2() {
  int len = (pgm_read_byte_near(&colorCount[getPalleteNumber()]) * (getDwellFrames() + getTransitionFrames()));
  for (int j = 0; j < LENGTH; j++) {
    1ea2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ea4:	c4 3f       	cpi	r28, 0xF4	; 244
    1ea6:	81 e0       	ldi	r24, 0x01	; 1
    1ea8:	d8 07       	cpc	r29, r24
    1eaa:	b9 f6       	brne	.-82     	; 0x1e5a <initColorsDrift2()+0x40>
    1eac:	df 91       	pop	r29
    1eae:	cf 91       	pop	r28
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:353
      scratch[(j / 2) * 3 + 2] &= ((r >> 4) & 0xF0);
    } else {
      scratch[(j / 2) * 3 + 2] = r >> 8;
    }
  }
}
    1eb0:	1f 91       	pop	r17
    1eb2:	0f 91       	pop	r16
    1eb4:	ff 90       	pop	r15
    1eb6:	ef 90       	pop	r14
    1eb8:	df 90       	pop	r13
    1eba:	cf 90       	pop	r12
    1ebc:	08 95       	ret
    1ebe:	70 83       	st	Z, r23
    1ec0:	ee cf       	rjmp	.-36     	; 0x1e9e <initColorsDrift2()+0x84>

00001ec2 <Print::write(char const*) [clone .part.2]>:
_ZN5Print5writeEPKc.part.2():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:350
    unsigned int r = random(0, len);
    scratch[((j * 3) / 2)] = r & 0xFF;
    if (j & 1) {
      scratch[(j / 2) * 3 + 2] &= ((r >> 4) & 0xF0);
    } else {
      scratch[(j / 2) * 3 + 2] = r >> 8;
    1ec2:	fb 01       	movw	r30, r22
    1ec4:	01 90       	ld	r0, Z+
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:49
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
    1ec6:	00 20       	and	r0, r0
    1ec8:	e9 f7       	brne	.-6      	; 0x1ec4 <Print::write(char const*) [clone .part.2]+0x2>
    1eca:	31 97       	sbiw	r30, 0x01	; 1
    1ecc:	af 01       	movw	r20, r30
    1ece:	46 1b       	sub	r20, r22
    1ed0:	57 0b       	sbc	r21, r23
    1ed2:	dc 01       	movw	r26, r24
    1ed4:	ed 91       	ld	r30, X+
    1ed6:	fc 91       	ld	r31, X
    1ed8:	02 80       	ldd	r0, Z+2	; 0x02
    1eda:	f3 81       	ldd	r31, Z+3	; 0x03
    1edc:	e0 2d       	mov	r30, r0
    1ede:	09 94       	ijmp

00001ee0 <Print::printNumber(unsigned long, unsigned char)>:
printNumber():
    1ee0:	8f 92       	push	r8
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:232
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base)
{
    1ee2:	9f 92       	push	r9
    1ee4:	af 92       	push	r10
    1ee6:	bf 92       	push	r11
    1ee8:	ef 92       	push	r14
    1eea:	ff 92       	push	r15
    1eec:	0f 93       	push	r16
    1eee:	1f 93       	push	r17
    1ef0:	cf 93       	push	r28
    1ef2:	df 93       	push	r29
    1ef4:	cd b7       	in	r28, 0x3d	; 61
    1ef6:	de b7       	in	r29, 0x3e	; 62
    1ef8:	a1 97       	sbiw	r28, 0x21	; 33
    1efa:	cd bf       	out	0x3d, r28	; 61
    1efc:	de bf       	out	0x3e, r29	; 62
    1efe:	7c 01       	movw	r14, r24
    1f00:	fa 01       	movw	r30, r20
    1f02:	cb 01       	movw	r24, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:236
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
    1f04:	19 a2       	std	Y+33, r1	; 0x21
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:239

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
    1f06:	22 30       	cpi	r18, 0x02	; 2
    1f08:	08 f4       	brcc	.+2      	; 0x1f0c <Print::printNumber(unsigned long, unsigned char)+0x2c>
    1f0a:	2a e0       	ldi	r18, 0x0A	; 10
    1f0c:	8e 01       	movw	r16, r28
    1f0e:	0f 5d       	subi	r16, 0xDF	; 223
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:242

  do {
    char c = n % base;
    1f10:	1f 4f       	sbci	r17, 0xFF	; 255
    1f12:	82 2e       	mov	r8, r18
    1f14:	91 2c       	mov	r9, r1
    1f16:	b1 2c       	mov	r11, r1
    1f18:	a1 2c       	mov	r10, r1
    1f1a:	bf 01       	movw	r22, r30
    1f1c:	a5 01       	movw	r20, r10
    1f1e:	94 01       	movw	r18, r8
    1f20:	0e 94 42 21 	call	0x4284	; 0x4284 <__udivmodsi4>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:243
    n /= base;
    1f24:	f9 01       	movw	r30, r18
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:245

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    1f26:	ca 01       	movw	r24, r20
    1f28:	6a 30       	cpi	r22, 0x0A	; 10
    1f2a:	ec f4       	brge	.+58     	; 0x1f66 <Print::printNumber(unsigned long, unsigned char)+0x86>
    1f2c:	60 5d       	subi	r22, 0xD0	; 208
    1f2e:	d8 01       	movw	r26, r16
    1f30:	6e 93       	st	-X, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:246
  } while(n);
    1f32:	8d 01       	movw	r16, r26
    1f34:	23 2b       	or	r18, r19
    1f36:	24 2b       	or	r18, r20
    1f38:	25 2b       	or	r18, r21
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.h:48
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
    1f3a:	79 f7       	brne	.-34     	; 0x1f1a <Print::printNumber(unsigned long, unsigned char)+0x3a>
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	80 e0       	ldi	r24, 0x00	; 0
write():
    1f40:	10 97       	sbiw	r26, 0x00	; 0
    1f42:	19 f0       	breq	.+6      	; 0x1f4a <Print::printNumber(unsigned long, unsigned char)+0x6a>
    1f44:	bd 01       	movw	r22, r26
    1f46:	c7 01       	movw	r24, r14
    1f48:	bc df       	rcall	.-136    	; 0x1ec2 <Print::write(char const*) [clone .part.2]>
printNumber():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:249

  return write(str);
}
    1f4a:	a1 96       	adiw	r28, 0x21	; 33
    1f4c:	cd bf       	out	0x3d, r28	; 61
    1f4e:	de bf       	out	0x3e, r29	; 62
    1f50:	df 91       	pop	r29
    1f52:	cf 91       	pop	r28
    1f54:	1f 91       	pop	r17
    1f56:	0f 91       	pop	r16
    1f58:	ff 90       	pop	r15
    1f5a:	ef 90       	pop	r14
    1f5c:	bf 90       	pop	r11
    1f5e:	af 90       	pop	r10
    1f60:	9f 90       	pop	r9
    1f62:	8f 90       	pop	r8
    1f64:	08 95       	ret
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:245

  do {
    char c = n % base;
    n /= base;

    *--str = c < 10 ? c + '0' : c + 'A' - 10;
    1f66:	69 5c       	subi	r22, 0xC9	; 201
    1f68:	e2 cf       	rjmp	.-60     	; 0x1f2e <Print::printNumber(unsigned long, unsigned char)+0x4e>

00001f6a <Print::println(char const*) [clone .constprop.25]>:
println():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:137
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
    1f6a:	cf 93       	push	r28
    1f6c:	df 93       	push	r29
write():
    1f6e:	bc 01       	movw	r22, r24
    1f70:	8f e8       	ldi	r24, 0x8F	; 143
    1f72:	97 e4       	ldi	r25, 0x47	; 71
    1f74:	a6 df       	rcall	.-180    	; 0x1ec2 <Print::write(char const*) [clone .part.2]>
    1f76:	ec 01       	movw	r28, r24
    1f78:	65 ef       	ldi	r22, 0xF5	; 245
    1f7a:	70 e4       	ldi	r23, 0x40	; 64
    1f7c:	8f e8       	ldi	r24, 0x8F	; 143
    1f7e:	97 e4       	ldi	r25, 0x47	; 71
    1f80:	a0 df       	rcall	.-192    	; 0x1ec2 <Print::write(char const*) [clone .part.2]>
println():
    1f82:	8c 0f       	add	r24, r28
    1f84:	9d 1f       	adc	r25, r29
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:142
{
  size_t n = print(c);
  n += println();
  return n;
}
    1f86:	df 91       	pop	r29
    1f88:	cf 91       	pop	r28
    1f8a:	08 95       	ret

00001f8c <Print::printFloat(double, unsigned char) [clone .constprop.8]>:
printFloat():
    1f8c:	4f 92       	push	r4
    1f8e:	5f 92       	push	r5
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:251
  } while(n);

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
    1f90:	6f 92       	push	r6
    1f92:	7f 92       	push	r7
    1f94:	8f 92       	push	r8
    1f96:	9f 92       	push	r9
    1f98:	af 92       	push	r10
    1f9a:	bf 92       	push	r11
    1f9c:	cf 92       	push	r12
    1f9e:	df 92       	push	r13
    1fa0:	ef 92       	push	r14
    1fa2:	ff 92       	push	r15
    1fa4:	0f 93       	push	r16
    1fa6:	1f 93       	push	r17
    1fa8:	cf 93       	push	r28
    1faa:	6b 01       	movw	r12, r22
    1fac:	7c 01       	movw	r14, r24
    1fae:	74 2e       	mov	r7, r20
    1fb0:	ac 01       	movw	r20, r24
    1fb2:	9b 01       	movw	r18, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:255
{
  size_t n = 0;

  if (isnan(number)) return print("nan");
    1fb4:	0e 94 89 23 	call	0x4712	; 0x4712 <__unordsf2>
write():
    1fb8:	68 ef       	ldi	r22, 0xF8	; 248
    1fba:	70 e4       	ldi	r23, 0x40	; 64
printFloat():
    1fbc:	81 11       	cpse	r24, r1
    1fbe:	26 c0       	rjmp	.+76     	; 0x200c <Print::printFloat(double, unsigned char) [clone .constprop.8]+0x80>
    1fc0:	46 01       	movw	r8, r12
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:256
  if (isinf(number)) return print("inf");
    1fc2:	57 01       	movw	r10, r14
    1fc4:	e8 94       	clt
    1fc6:	b7 f8       	bld	r11, 7
    1fc8:	2f ef       	ldi	r18, 0xFF	; 255
    1fca:	3f ef       	ldi	r19, 0xFF	; 255
    1fcc:	4f e7       	ldi	r20, 0x7F	; 127
    1fce:	5f e7       	ldi	r21, 0x7F	; 127
    1fd0:	c5 01       	movw	r24, r10
    1fd2:	b4 01       	movw	r22, r8
    1fd4:	0e 94 89 23 	call	0x4712	; 0x4712 <__unordsf2>
    1fd8:	81 11       	cpse	r24, r1
    1fda:	0c c0       	rjmp	.+24     	; 0x1ff4 <Print::printFloat(double, unsigned char) [clone .constprop.8]+0x68>
    1fdc:	2f ef       	ldi	r18, 0xFF	; 255
    1fde:	3f ef       	ldi	r19, 0xFF	; 255
    1fe0:	4f e7       	ldi	r20, 0x7F	; 127
    1fe2:	5f e7       	ldi	r21, 0x7F	; 127
    1fe4:	c5 01       	movw	r24, r10
    1fe6:	b4 01       	movw	r22, r8
    1fe8:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <__cmpsf2>
write():
    1fec:	6c ef       	ldi	r22, 0xFC	; 252
    1fee:	70 e4       	ldi	r23, 0x40	; 64
printFloat():
    1ff0:	18 16       	cp	r1, r24
    1ff2:	64 f0       	brlt	.+24     	; 0x200c <Print::printFloat(double, unsigned char) [clone .constprop.8]+0x80>
    1ff4:	2f ef       	ldi	r18, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:257
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
    1ff6:	3f ef       	ldi	r19, 0xFF	; 255
    1ff8:	4f e7       	ldi	r20, 0x7F	; 127
    1ffa:	5f e4       	ldi	r21, 0x4F	; 79
    1ffc:	c7 01       	movw	r24, r14
    1ffe:	b6 01       	movw	r22, r12
    2000:	0e 94 22 23 	call	0x4644	; 0x4644 <__gesf2>
    2004:	18 16       	cp	r1, r24
    2006:	a4 f4       	brge	.+40     	; 0x2030 <Print::printFloat(double, unsigned char) [clone .constprop.8]+0xa4>
write():
    2008:	60 e0       	ldi	r22, 0x00	; 0
    200a:	71 e4       	ldi	r23, 0x41	; 65
    200c:	8f e8       	ldi	r24, 0x8F	; 143
    200e:	97 e4       	ldi	r25, 0x47	; 71
printFloat():
    2010:	cf 91       	pop	r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:294
    n += print(toPrint);
    remainder -= toPrint;
  }

  return n;
}
    2012:	1f 91       	pop	r17
    2014:	0f 91       	pop	r16
    2016:	ff 90       	pop	r15
    2018:	ef 90       	pop	r14
    201a:	df 90       	pop	r13
    201c:	cf 90       	pop	r12
    201e:	bf 90       	pop	r11
    2020:	af 90       	pop	r10
    2022:	9f 90       	pop	r9
    2024:	8f 90       	pop	r8
    2026:	7f 90       	pop	r7
    2028:	6f 90       	pop	r6
    202a:	5f 90       	pop	r5
    202c:	4f 90       	pop	r4
write():
    202e:	49 cf       	rjmp	.-366    	; 0x1ec2 <Print::write(char const*) [clone .part.2]>
printFloat():
    2030:	2f ef       	ldi	r18, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:258
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
    2032:	3f ef       	ldi	r19, 0xFF	; 255
    2034:	4f e7       	ldi	r20, 0x7F	; 127
    2036:	5f ec       	ldi	r21, 0xCF	; 207
    2038:	c7 01       	movw	r24, r14
    203a:	b6 01       	movw	r22, r12
    203c:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <__cmpsf2>
    2040:	87 fd       	sbrc	r24, 7
    2042:	e2 cf       	rjmp	.-60     	; 0x2008 <Print::printFloat(double, unsigned char) [clone .constprop.8]+0x7c>
    2044:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:261

  // Handle negative numbers
  if (number < 0.0)
    2046:	30 e0       	ldi	r19, 0x00	; 0
    2048:	a9 01       	movw	r20, r18
    204a:	c7 01       	movw	r24, r14
    204c:	b6 01       	movw	r22, r12
    204e:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <__cmpsf2>
    2052:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:253
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;
    2054:	00 e0       	ldi	r16, 0x00	; 0
    2056:	87 ff       	sbrs	r24, 7
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:261
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically

  // Handle negative numbers
  if (number < 0.0)
    2058:	0a c0       	rjmp	.+20     	; 0x206e <Print::printFloat(double, unsigned char) [clone .constprop.8]+0xe2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:263
  {
     n += print('-');
    205a:	6d e2       	ldi	r22, 0x2D	; 45
    205c:	8f e8       	ldi	r24, 0x8F	; 143
    205e:	97 e4       	ldi	r25, 0x47	; 71
    2060:	0e 94 10 04 	call	0x820	; 0x820 <Print::print(char)>
    2064:	8c 01       	movw	r16, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:264
     number = -number;
    2066:	f7 fa       	bst	r15, 7
    2068:	f0 94       	com	r15
    206a:	f7 f8       	bld	r15, 7
    206c:	f0 94       	com	r15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:269
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    206e:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:268
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
    2070:	60 e0       	ldi	r22, 0x00	; 0
    2072:	70 e0       	ldi	r23, 0x00	; 0
    2074:	80 e0       	ldi	r24, 0x00	; 0
    2076:	9f e3       	ldi	r25, 0x3F	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:269
  for (uint8_t i=0; i<digits; ++i)
    2078:	7c 16       	cp	r7, r28
    207a:	41 f0       	breq	.+16     	; 0x208c <Print::printFloat(double, unsigned char) [clone .constprop.8]+0x100>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:270
    rounding /= 10.0;
    207c:	20 e0       	ldi	r18, 0x00	; 0
    207e:	30 e0       	ldi	r19, 0x00	; 0
    2080:	40 e2       	ldi	r20, 0x20	; 32
    2082:	51 e4       	ldi	r21, 0x41	; 65
    2084:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <__divsf3>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:269
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    2088:	cf 5f       	subi	r28, 0xFF	; 255
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:272
    rounding /= 10.0;

  number += rounding;
    208a:	f6 cf       	rjmp	.-20     	; 0x2078 <Print::printFloat(double, unsigned char) [clone .constprop.8]+0xec>
    208c:	a7 01       	movw	r20, r14
    208e:	96 01       	movw	r18, r12
    2090:	0e 94 74 21 	call	0x42e8	; 0x42e8 <__addsf3>
    2094:	2b 01       	movw	r4, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:275

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    2096:	3c 01       	movw	r6, r24
    2098:	0e 94 44 22 	call	0x4488	; 0x4488 <__fixunssfsi>
    209c:	4b 01       	movw	r8, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:105
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    209e:	5c 01       	movw	r10, r24
print():
    20a0:	2a e0       	ldi	r18, 0x0A	; 10
    20a2:	bc 01       	movw	r22, r24
    20a4:	a4 01       	movw	r20, r8
    20a6:	8f e8       	ldi	r24, 0x8F	; 143
    20a8:	97 e4       	ldi	r25, 0x47	; 71
    20aa:	1a df       	rcall	.-460    	; 0x1ee0 <Print::printNumber(unsigned long, unsigned char)>
printFloat():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:277
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
    20ac:	7c 01       	movw	r14, r24
    20ae:	e0 0e       	add	r14, r16
    20b0:	f1 1e       	adc	r15, r17
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:280

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    20b2:	cc 23       	and	r28, r28
    20b4:	c9 f1       	breq	.+114    	; 0x2128 <Print::printFloat(double, unsigned char) [clone .constprop.8]+0x19c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:276

  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
    20b6:	c5 01       	movw	r24, r10
    20b8:	b4 01       	movw	r22, r8
    20ba:	0e 94 70 22 	call	0x44e0	; 0x44e0 <__floatunsisf>
    20be:	9b 01       	movw	r18, r22
    20c0:	ac 01       	movw	r20, r24
    20c2:	c3 01       	movw	r24, r6
    20c4:	b2 01       	movw	r22, r4
    20c6:	0e 94 73 21 	call	0x42e6	; 0x42e6 <__subsf3>
    20ca:	4b 01       	movw	r8, r22
    20cc:	5c 01       	movw	r10, r24
write():
    20ce:	64 e0       	ldi	r22, 0x04	; 4
    20d0:	71 e4       	ldi	r23, 0x41	; 65
    20d2:	8f e8       	ldi	r24, 0x8F	; 143
    20d4:	97 e4       	ldi	r25, 0x47	; 71
    20d6:	f5 de       	rcall	.-534    	; 0x1ec2 <Print::write(char const*) [clone .part.2]>
printFloat():
    20d8:	e8 0e       	add	r14, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:281
  n += print(int_part);

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    n += print(".");
    20da:	f9 1e       	adc	r15, r25
    20dc:	c1 50       	subi	r28, 0x01	; 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:285
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    20de:	20 f1       	brcs	.+72     	; 0x2128 <Print::printFloat(double, unsigned char) [clone .constprop.8]+0x19c>
    20e0:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:287
  {
    remainder *= 10.0;
    20e2:	30 e0       	ldi	r19, 0x00	; 0
    20e4:	40 e2       	ldi	r20, 0x20	; 32
    20e6:	51 e4       	ldi	r21, 0x41	; 65
    20e8:	c5 01       	movw	r24, r10
    20ea:	b4 01       	movw	r22, r8
    20ec:	0e 94 26 23 	call	0x464c	; 0x464c <__mulsf3>
    20f0:	2b 01       	movw	r4, r22
    20f2:	3c 01       	movw	r6, r24
    20f4:	0e 94 44 22 	call	0x4488	; 0x4488 <__fixunssfsi>
print():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:288
    unsigned int toPrint = (unsigned int)remainder;
    20f8:	4b 01       	movw	r8, r22
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:83
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long) n, base);
    20fa:	b1 2c       	mov	r11, r1
    20fc:	a1 2c       	mov	r10, r1
    20fe:	2a e0       	ldi	r18, 0x0A	; 10
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:105
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    2100:	b5 01       	movw	r22, r10
    2102:	a4 01       	movw	r20, r8
    2104:	8f e8       	ldi	r24, 0x8F	; 143
    2106:	97 e4       	ldi	r25, 0x47	; 71
    2108:	eb de       	rcall	.-554    	; 0x1ee0 <Print::printNumber(unsigned long, unsigned char)>
printFloat():
    210a:	e8 0e       	add	r14, r24
    210c:	f9 1e       	adc	r15, r25
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:289
  // Extract digits from the remainder one at a time
  while (digits-- > 0)
  {
    remainder *= 10.0;
    unsigned int toPrint = (unsigned int)remainder;
    n += print(toPrint);
    210e:	c5 01       	movw	r24, r10
    2110:	b4 01       	movw	r22, r8
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:290
    remainder -= toPrint;
    2112:	0e 94 70 22 	call	0x44e0	; 0x44e0 <__floatunsisf>
    2116:	9b 01       	movw	r18, r22
    2118:	ac 01       	movw	r20, r24
    211a:	c3 01       	movw	r24, r6
    211c:	b2 01       	movw	r22, r4
    211e:	0e 94 73 21 	call	0x42e6	; 0x42e6 <__subsf3>
    2122:	4b 01       	movw	r8, r22
    2124:	5c 01       	movw	r10, r24
    2126:	da cf       	rjmp	.-76     	; 0x20dc <Print::printFloat(double, unsigned char) [clone .constprop.8]+0x150>
    2128:	c7 01       	movw	r24, r14
    212a:	cf 91       	pop	r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:294
  }

  return n;
}
    212c:	1f 91       	pop	r17
    212e:	0f 91       	pop	r16
    2130:	ff 90       	pop	r15
    2132:	ef 90       	pop	r14
    2134:	df 90       	pop	r13
    2136:	cf 90       	pop	r12
    2138:	bf 90       	pop	r11
    213a:	af 90       	pop	r10
    213c:	9f 90       	pop	r9
    213e:	8f 90       	pop	r8
    2140:	7f 90       	pop	r7
    2142:	6f 90       	pop	r6
    2144:	5f 90       	pop	r5
    2146:	4f 90       	pop	r4
    2148:	08 95       	ret

0000214a <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)>:
getModeColors():
    214a:	2f 92       	push	r2
    214c:	3f 92       	push	r3
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:789
    getDrift2Colors(&pixels[i * 3], &pixels[i * 3] + 1, &pixels[i * 3] + 2, f1);
    getDrift2Colors(&pixels[i * 3] + 3, &pixels[i * 3] + 4, &pixels[i * 3] + 5, f2);
  }
}

void getModeColors(byte * r, byte * g, byte * b, unsigned long fnumber) {
    214e:	4f 92       	push	r4
    2150:	5f 92       	push	r5
    2152:	6f 92       	push	r6
    2154:	7f 92       	push	r7
    2156:	8f 92       	push	r8
    2158:	9f 92       	push	r9
    215a:	af 92       	push	r10
    215c:	bf 92       	push	r11
    215e:	cf 92       	push	r12
    2160:	df 92       	push	r13
    2162:	ef 92       	push	r14
    2164:	ff 92       	push	r15
    2166:	0f 93       	push	r16
    2168:	1f 93       	push	r17
    216a:	cf 93       	push	r28
    216c:	df 93       	push	r29
    216e:	cd b7       	in	r28, 0x3d	; 61
    2170:	de b7       	in	r29, 0x3e	; 62
    2172:	2a 97       	sbiw	r28, 0x0a	; 10
    2174:	cd bf       	out	0x3d, r28	; 61
    2176:	de bf       	out	0x3e, r29	; 62
    2178:	1c 01       	movw	r2, r24
    217a:	6d 83       	std	Y+5, r22	; 0x05
    217c:	7e 83       	std	Y+6, r23	; 0x06
    217e:	4f 83       	std	Y+7, r20	; 0x07
    2180:	58 87       	std	Y+8, r21	; 0x08
    2182:	28 01       	movw	r4, r16
    2184:	39 01       	movw	r6, r18
    2186:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <getDwellFrames()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:790
  unsigned int dwellFrames = getDwellFrames();
    218a:	5c 01       	movw	r10, r24
    218c:	0e 94 c9 07 	call	0xf92	; 0xf92 <getTransitionFrames()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:791
  unsigned int transitionFrames = getTransitionFrames();
    2190:	6c 01       	movw	r12, r24
    2192:	0e 94 c0 07 	call	0xf80	; 0xf80 <getPalleteNumber()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:792
  byte colors = getPalleteNumber();
    2196:	89 83       	std	Y+1, r24	; 0x01
    2198:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:793
  unsigned long tem = ((currentValueRight[currentMode == 4 ? 2 : 3] ? 0 : LENGTH) + fnumber) % (pgm_read_byte_near(&colorCount[colors]) * (dwellFrames + transitionFrames));
    219c:	84 30       	cpi	r24, 0x04	; 4
    219e:	09 f0       	breq	.+2      	; 0x21a2 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x58>
    21a0:	70 c0       	rjmp	.+224    	; 0x2282 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x138>
    21a2:	82 e0       	ldi	r24, 0x02	; 2
    21a4:	90 e0       	ldi	r25, 0x00	; 0
    21a6:	8f 57       	subi	r24, 0x7F	; 127
    21a8:	98 4b       	sbci	r25, 0xB8	; 184
    21aa:	fc 01       	movw	r30, r24
    21ac:	80 81       	ld	r24, Z
    21ae:	88 23       	and	r24, r24
    21b0:	09 f4       	brne	.+2      	; 0x21b4 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x6a>
    21b2:	6a c0       	rjmp	.+212    	; 0x2288 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x13e>
    21b4:	80 e0       	ldi	r24, 0x00	; 0
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	dc 01       	movw	r26, r24
    21ba:	f9 81       	ldd	r31, Y+1	; 0x01
    21bc:	2f 2f       	mov	r18, r31
    21be:	30 e0       	ldi	r19, 0x00	; 0
    21c0:	a9 01       	movw	r20, r18
    21c2:	47 5b       	subi	r20, 0xB7	; 183
    21c4:	58 4f       	sbci	r21, 0xF8	; 248
    21c6:	7a 01       	movw	r14, r20
    21c8:	fa 01       	movw	r30, r20
    21ca:	44 91       	lpm	r20, Z
    21cc:	bc 01       	movw	r22, r24
    21ce:	cd 01       	movw	r24, r26
    21d0:	64 0d       	add	r22, r4
    21d2:	75 1d       	adc	r23, r5
    21d4:	86 1d       	adc	r24, r6
    21d6:	97 1d       	adc	r25, r7
    21d8:	85 01       	movw	r16, r10
    21da:	0c 0d       	add	r16, r12
    21dc:	1d 1d       	adc	r17, r13
    21de:	40 9f       	mul	r20, r16
    21e0:	90 01       	movw	r18, r0
    21e2:	41 9f       	mul	r20, r17
    21e4:	30 0d       	add	r19, r0
    21e6:	11 24       	eor	r1, r1
    21e8:	50 e0       	ldi	r21, 0x00	; 0
    21ea:	40 e0       	ldi	r20, 0x00	; 0
    21ec:	0e 94 42 21 	call	0x4284	; 0x4284 <__udivmodsi4>
    21f0:	98 01       	movw	r18, r16
    21f2:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:794
  unsigned int cyclepos = tem % (dwellFrames + transitionFrames);
    21f4:	40 e0       	ldi	r20, 0x00	; 0
    21f6:	0e 94 42 21 	call	0x4284	; 0x4284 <__udivmodsi4>
    21fa:	a2 2f       	mov	r26, r18
    21fc:	b0 e0       	ldi	r27, 0x00	; 0
    21fe:	49 81       	ldd	r20, Y+1	; 0x01
    2200:	e8 e1       	ldi	r30, 0x18	; 24
    2202:	4e 9f       	mul	r20, r30
    2204:	a0 01       	movw	r20, r0
    2206:	11 24       	eor	r1, r1
    2208:	49 87       	std	Y+9, r20	; 0x09
    220a:	5a 87       	std	Y+10, r21	; 0x0a
    220c:	fa 01       	movw	r30, r20
    220e:	53 e0       	ldi	r21, 0x03	; 3
    2210:	25 9f       	mul	r18, r21
    2212:	e0 0d       	add	r30, r0
    2214:	f1 1d       	adc	r31, r1
    2216:	11 24       	eor	r1, r1
    2218:	8f 01       	movw	r16, r30
    221a:	0d 5c       	subi	r16, 0xCD	; 205
    221c:	1c 4f       	sbci	r17, 0xFC	; 252
    221e:	af 01       	movw	r20, r30
    2220:	4c 5c       	subi	r20, 0xCC	; 204
    2222:	5c 4f       	sbci	r21, 0xFC	; 252
    2224:	49 83       	std	Y+1, r20	; 0x01
    2226:	5a 83       	std	Y+2, r21	; 0x02
    2228:	af 01       	movw	r20, r30
    222a:	4b 5c       	subi	r20, 0xCB	; 203
    222c:	5c 4f       	sbci	r21, 0xFC	; 252
    222e:	4b 83       	std	Y+3, r20	; 0x03
    2230:	5c 83       	std	Y+4, r21	; 0x04
    2232:	6a 15       	cp	r22, r10
    2234:	7b 05       	cpc	r23, r11
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:796
  byte cyclenum = tem / (dwellFrames + transitionFrames);
  if (cyclepos < dwellFrames) {
    2236:	68 f5       	brcc	.+90     	; 0x2292 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x148>
    2238:	f8 01       	movw	r30, r16
    223a:	04 91       	lpm	r16, Z
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:797
    *r = pgm_read_byte_near(&colorPallete[colors][cyclenum][0]);
    223c:	f1 01       	movw	r30, r2
    223e:	00 83       	st	Z, r16
    2240:	e9 81       	ldd	r30, Y+1	; 0x01
    2242:	fa 81       	ldd	r31, Y+2	; 0x02
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:798
    *g = pgm_read_byte_near(&colorPallete[colors][cyclenum][1]);
    2244:	14 91       	lpm	r17, Z
    2246:	ed 81       	ldd	r30, Y+5	; 0x05
    2248:	fe 81       	ldd	r31, Y+6	; 0x06
    224a:	10 83       	st	Z, r17
    224c:	fa 01       	movw	r30, r20
    224e:	64 91       	lpm	r22, Z
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:799
    *b = pgm_read_byte_near(&colorPallete[colors][cyclenum][2]);
    2250:	ef 81       	ldd	r30, Y+7	; 0x07
    2252:	f8 85       	ldd	r31, Y+8	; 0x08
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:812
      Serial.println(ratio);
      Serial.flush();
    }
    *r = 0.5 + (pgm_read_byte_near(&colorPallete[colors][m][0]) * ratio) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][0]) * (1 - ratio));
    *g = 0.5 + (pgm_read_byte_near(&colorPallete[colors][m][1]) * ratio) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][1]) * (1 - ratio));
    *b = 0.5 + (pgm_read_byte_near(&colorPallete[colors][m][2]) * ratio) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][2]) * (1 - ratio));
    2254:	60 83       	st	Z, r22
    2256:	2a 96       	adiw	r28, 0x0a	; 10
    2258:	cd bf       	out	0x3d, r28	; 61
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:814
  }
}
    225a:	de bf       	out	0x3e, r29	; 62
    225c:	df 91       	pop	r29
    225e:	cf 91       	pop	r28
    2260:	1f 91       	pop	r17
    2262:	0f 91       	pop	r16
    2264:	ff 90       	pop	r15
    2266:	ef 90       	pop	r14
    2268:	df 90       	pop	r13
    226a:	cf 90       	pop	r12
    226c:	bf 90       	pop	r11
    226e:	af 90       	pop	r10
    2270:	9f 90       	pop	r9
    2272:	8f 90       	pop	r8
    2274:	7f 90       	pop	r7
    2276:	6f 90       	pop	r6
    2278:	5f 90       	pop	r5
    227a:	4f 90       	pop	r4
    227c:	3f 90       	pop	r3
    227e:	2f 90       	pop	r2
    2280:	08 95       	ret
    2282:	83 e0       	ldi	r24, 0x03	; 3
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:793

void getModeColors(byte * r, byte * g, byte * b, unsigned long fnumber) {
  unsigned int dwellFrames = getDwellFrames();
  unsigned int transitionFrames = getTransitionFrames();
  byte colors = getPalleteNumber();
  unsigned long tem = ((currentValueRight[currentMode == 4 ? 2 : 3] ? 0 : LENGTH) + fnumber) % (pgm_read_byte_near(&colorCount[colors]) * (dwellFrames + transitionFrames));
    2284:	90 e0       	ldi	r25, 0x00	; 0
    2286:	8f cf       	rjmp	.-226    	; 0x21a6 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x5c>
    2288:	84 ef       	ldi	r24, 0xF4	; 244
    228a:	91 e0       	ldi	r25, 0x01	; 1
    228c:	a0 e0       	ldi	r26, 0x00	; 0
    228e:	b0 e0       	ldi	r27, 0x00	; 0
    2290:	94 cf       	rjmp	.-216    	; 0x21ba <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x70>
    2292:	ab 01       	movw	r20, r22
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:802
    *r = pgm_read_byte_near(&colorPallete[colors][cyclenum][0]);
    *g = pgm_read_byte_near(&colorPallete[colors][cyclenum][1]);
    *b = pgm_read_byte_near(&colorPallete[colors][cyclenum][2]);
    return;
  } else {
    cyclepos -= dwellFrames;
    2294:	4a 19       	sub	r20, r10
    2296:	5b 09       	sbc	r21, r11
    2298:	f7 01       	movw	r30, r14
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:803
    byte m = ((cyclenum + 1) >= pgm_read_byte_near(&colorCount[colors])) ? 0 : cyclenum + 1;
    229a:	e4 90       	lpm	r14, Z
    229c:	cd 01       	movw	r24, r26
    229e:	01 96       	adiw	r24, 0x01	; 1
    22a0:	bb 24       	eor	r11, r11
    22a2:	b3 94       	inc	r11
    22a4:	b2 0e       	add	r11, r18
    22a6:	e8 16       	cp	r14, r24
    22a8:	19 06       	cpc	r1, r25
    22aa:	09 f0       	breq	.+2      	; 0x22ae <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x164>
    22ac:	0c f4       	brge	.+2      	; 0x22b0 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x166>
    22ae:	b1 2c       	mov	r11, r1
    22b0:	ba 01       	movw	r22, r20
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:804
    float ratio = ((float)cyclepos) / transitionFrames;
    22b2:	90 e0       	ldi	r25, 0x00	; 0
    22b4:	80 e0       	ldi	r24, 0x00	; 0
    22b6:	0e 94 70 22 	call	0x44e0	; 0x44e0 <__floatunsisf>
    22ba:	2b 01       	movw	r4, r22
    22bc:	3c 01       	movw	r6, r24
    22be:	b6 01       	movw	r22, r12
    22c0:	90 e0       	ldi	r25, 0x00	; 0
    22c2:	80 e0       	ldi	r24, 0x00	; 0
    22c4:	0e 94 70 22 	call	0x44e0	; 0x44e0 <__floatunsisf>
    22c8:	9b 01       	movw	r18, r22
    22ca:	ac 01       	movw	r20, r24
    22cc:	c3 01       	movw	r24, r6
    22ce:	b2 01       	movw	r22, r4
    22d0:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <__divsf3>
    22d4:	6b 01       	movw	r12, r22
    22d6:	7c 01       	movw	r14, r24
    22d8:	25 ec       	ldi	r18, 0xC5	; 197
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:805
    if (ratio > 1.001 || ratio < 0.0) {
    22da:	30 e2       	ldi	r19, 0x20	; 32
    22dc:	40 e8       	ldi	r20, 0x80	; 128
    22de:	5f e3       	ldi	r21, 0x3F	; 63
    22e0:	0e 94 22 23 	call	0x4644	; 0x4644 <__gesf2>
    22e4:	18 16       	cp	r1, r24
    22e6:	9c f4       	brge	.+38     	; 0x230e <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x1c4>
    22e8:	69 e1       	ldi	r22, 0x19	; 25
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:806
      Serial.print(F("ERROR: ratio out of range"));
    22ea:	73 e0       	ldi	r23, 0x03	; 3
    22ec:	8f e8       	ldi	r24, 0x8F	; 143
    22ee:	97 e4       	ldi	r25, 0x47	; 71
    22f0:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
print():
    22f4:	42 e0       	ldi	r20, 0x02	; 2
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:110
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    22f6:	c7 01       	movw	r24, r14
    22f8:	b6 01       	movw	r22, r12
    22fa:	48 de       	rcall	.-880    	; 0x1f8c <Print::printFloat(double, unsigned char) [clone .constprop.8]>
write():
    22fc:	65 ef       	ldi	r22, 0xF5	; 245
    22fe:	70 e4       	ldi	r23, 0x40	; 64
    2300:	8f e8       	ldi	r24, 0x8F	; 143
    2302:	97 e4       	ldi	r25, 0x47	; 71
    2304:	de dd       	rcall	.-1092   	; 0x1ec2 <Print::write(char const*) [clone .part.2]>
getModeColors():
    2306:	8f e8       	ldi	r24, 0x8F	; 143
    2308:	97 e4       	ldi	r25, 0x47	; 71
    230a:	0e 94 76 06 	call	0xcec	; 0xcec <UartClass::flush()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:808
      Serial.println(ratio);
      Serial.flush();
    230e:	29 85       	ldd	r18, Y+9	; 0x09
    2310:	3a 85       	ldd	r19, Y+10	; 0x0a
    2312:	43 e0       	ldi	r20, 0x03	; 3
    2314:	b4 9e       	mul	r11, r20
    2316:	20 0d       	add	r18, r0
    2318:	31 1d       	adc	r19, r1
    231a:	11 24       	eor	r1, r1
    231c:	29 87       	std	Y+9, r18	; 0x09
    231e:	3a 87       	std	Y+10, r19	; 0x0a
    2320:	f9 01       	movw	r30, r18
    2322:	ed 5c       	subi	r30, 0xCD	; 205
    2324:	fc 4f       	sbci	r31, 0xFC	; 252
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:810
    }
    *r = 0.5 + (pgm_read_byte_near(&colorPallete[colors][m][0]) * ratio) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][0]) * (1 - ratio));
    2326:	74 90       	lpm	r7, Z
    2328:	f8 01       	movw	r30, r16
    232a:	04 91       	lpm	r16, Z
    232c:	a7 01       	movw	r20, r14
    232e:	96 01       	movw	r18, r12
    2330:	60 e0       	ldi	r22, 0x00	; 0
    2332:	70 e0       	ldi	r23, 0x00	; 0
    2334:	80 e8       	ldi	r24, 0x80	; 128
    2336:	9f e3       	ldi	r25, 0x3F	; 63
    2338:	0e 94 73 21 	call	0x42e6	; 0x42e6 <__subsf3>
    233c:	4b 01       	movw	r8, r22
    233e:	5c 01       	movw	r10, r24
    2340:	67 2d       	mov	r22, r7
    2342:	70 e0       	ldi	r23, 0x00	; 0
    2344:	90 e0       	ldi	r25, 0x00	; 0
    2346:	80 e0       	ldi	r24, 0x00	; 0
    2348:	0e 94 72 22 	call	0x44e4	; 0x44e4 <__floatsisf>
    234c:	a7 01       	movw	r20, r14
    234e:	96 01       	movw	r18, r12
    2350:	0e 94 26 23 	call	0x464c	; 0x464c <__mulsf3>
    2354:	20 e0       	ldi	r18, 0x00	; 0
    2356:	30 e0       	ldi	r19, 0x00	; 0
    2358:	40 e0       	ldi	r20, 0x00	; 0
    235a:	5f e3       	ldi	r21, 0x3F	; 63
    235c:	0e 94 74 21 	call	0x42e8	; 0x42e8 <__addsf3>
    2360:	2b 01       	movw	r4, r22
    2362:	3c 01       	movw	r6, r24
    2364:	60 2f       	mov	r22, r16
    2366:	70 e0       	ldi	r23, 0x00	; 0
    2368:	90 e0       	ldi	r25, 0x00	; 0
    236a:	80 e0       	ldi	r24, 0x00	; 0
    236c:	0e 94 72 22 	call	0x44e4	; 0x44e4 <__floatsisf>
    2370:	a5 01       	movw	r20, r10
    2372:	94 01       	movw	r18, r8
    2374:	0e 94 26 23 	call	0x464c	; 0x464c <__mulsf3>
    2378:	9b 01       	movw	r18, r22
    237a:	ac 01       	movw	r20, r24
    237c:	c3 01       	movw	r24, r6
    237e:	b2 01       	movw	r22, r4
    2380:	0e 94 74 21 	call	0x42e8	; 0x42e8 <__addsf3>
    2384:	0e 94 44 22 	call	0x4488	; 0x4488 <__fixunssfsi>
    2388:	f1 01       	movw	r30, r2
    238a:	60 83       	st	Z, r22
    238c:	e9 85       	ldd	r30, Y+9	; 0x09
    238e:	fa 85       	ldd	r31, Y+10	; 0x0a
    2390:	ec 5c       	subi	r30, 0xCC	; 204
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:811
    *g = 0.5 + (pgm_read_byte_near(&colorPallete[colors][m][1]) * ratio) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][1]) * (1 - ratio));
    2392:	fc 4f       	sbci	r31, 0xFC	; 252
    2394:	64 91       	lpm	r22, Z
    2396:	e9 81       	ldd	r30, Y+1	; 0x01
    2398:	fa 81       	ldd	r31, Y+2	; 0x02
    239a:	14 91       	lpm	r17, Z
    239c:	70 e0       	ldi	r23, 0x00	; 0
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	80 e0       	ldi	r24, 0x00	; 0
    23a2:	0e 94 72 22 	call	0x44e4	; 0x44e4 <__floatsisf>
    23a6:	a7 01       	movw	r20, r14
    23a8:	96 01       	movw	r18, r12
    23aa:	0e 94 26 23 	call	0x464c	; 0x464c <__mulsf3>
    23ae:	20 e0       	ldi	r18, 0x00	; 0
    23b0:	30 e0       	ldi	r19, 0x00	; 0
    23b2:	40 e0       	ldi	r20, 0x00	; 0
    23b4:	5f e3       	ldi	r21, 0x3F	; 63
    23b6:	0e 94 74 21 	call	0x42e8	; 0x42e8 <__addsf3>
    23ba:	2b 01       	movw	r4, r22
    23bc:	3c 01       	movw	r6, r24
    23be:	61 2f       	mov	r22, r17
    23c0:	70 e0       	ldi	r23, 0x00	; 0
    23c2:	90 e0       	ldi	r25, 0x00	; 0
    23c4:	80 e0       	ldi	r24, 0x00	; 0
    23c6:	0e 94 72 22 	call	0x44e4	; 0x44e4 <__floatsisf>
    23ca:	a5 01       	movw	r20, r10
    23cc:	94 01       	movw	r18, r8
    23ce:	0e 94 26 23 	call	0x464c	; 0x464c <__mulsf3>
    23d2:	9b 01       	movw	r18, r22
    23d4:	ac 01       	movw	r20, r24
    23d6:	c3 01       	movw	r24, r6
    23d8:	b2 01       	movw	r22, r4
    23da:	0e 94 74 21 	call	0x42e8	; 0x42e8 <__addsf3>
    23de:	0e 94 44 22 	call	0x4488	; 0x4488 <__fixunssfsi>
    23e2:	ed 81       	ldd	r30, Y+5	; 0x05
    23e4:	fe 81       	ldd	r31, Y+6	; 0x06
    23e6:	60 83       	st	Z, r22
    23e8:	29 85       	ldd	r18, Y+9	; 0x09
    23ea:	3a 85       	ldd	r19, Y+10	; 0x0a
    23ec:	2b 5c       	subi	r18, 0xCB	; 203
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:812
    *b = 0.5 + (pgm_read_byte_near(&colorPallete[colors][m][2]) * ratio) + (pgm_read_byte_near(&colorPallete[colors][cyclenum][2]) * (1 - ratio));
    23ee:	3c 4f       	sbci	r19, 0xFC	; 252
    23f0:	f9 01       	movw	r30, r18
    23f2:	f4 91       	lpm	r31, Z
    23f4:	f9 83       	std	Y+1, r31	; 0x01
    23f6:	eb 81       	ldd	r30, Y+3	; 0x03
    23f8:	fc 81       	ldd	r31, Y+4	; 0x04
    23fa:	f4 91       	lpm	r31, Z
    23fc:	fb 83       	std	Y+3, r31	; 0x03
    23fe:	29 81       	ldd	r18, Y+1	; 0x01
    2400:	62 2f       	mov	r22, r18
    2402:	70 e0       	ldi	r23, 0x00	; 0
    2404:	90 e0       	ldi	r25, 0x00	; 0
    2406:	80 e0       	ldi	r24, 0x00	; 0
    2408:	0e 94 72 22 	call	0x44e4	; 0x44e4 <__floatsisf>
    240c:	a7 01       	movw	r20, r14
    240e:	96 01       	movw	r18, r12
    2410:	0e 94 26 23 	call	0x464c	; 0x464c <__mulsf3>
    2414:	20 e0       	ldi	r18, 0x00	; 0
    2416:	30 e0       	ldi	r19, 0x00	; 0
    2418:	40 e0       	ldi	r20, 0x00	; 0
    241a:	5f e3       	ldi	r21, 0x3F	; 63
    241c:	0e 94 74 21 	call	0x42e8	; 0x42e8 <__addsf3>
    2420:	6b 01       	movw	r12, r22
    2422:	7c 01       	movw	r14, r24
    2424:	3b 81       	ldd	r19, Y+3	; 0x03
    2426:	63 2f       	mov	r22, r19
    2428:	70 e0       	ldi	r23, 0x00	; 0
    242a:	90 e0       	ldi	r25, 0x00	; 0
    242c:	80 e0       	ldi	r24, 0x00	; 0
    242e:	0e 94 72 22 	call	0x44e4	; 0x44e4 <__floatsisf>
    2432:	a5 01       	movw	r20, r10
    2434:	94 01       	movw	r18, r8
    2436:	0e 94 26 23 	call	0x464c	; 0x464c <__mulsf3>
    243a:	9b 01       	movw	r18, r22
    243c:	ac 01       	movw	r20, r24
    243e:	c7 01       	movw	r24, r14
    2440:	b6 01       	movw	r22, r12
    2442:	0e 94 74 21 	call	0x42e8	; 0x42e8 <__addsf3>
    2446:	0e 94 44 22 	call	0x4488	; 0x4488 <__fixunssfsi>
    244a:	02 cf       	rjmp	.-508    	; 0x2250 <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)+0x106>

0000244c <updatePatternWave()>:
updatePatternWave():
    244c:	0f 93       	push	r16
    244e:	1f 93       	push	r17
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:677
  getModeColors(&r, &g, &b, frameNumber);
  setAll(r, g, b);
}


void updatePatternWave() {
    2450:	cf 93       	push	r28
    2452:	df 93       	push	r29
    2454:	00 d0       	rcall	.+0      	; 0x2456 <updatePatternWave()+0xa>
    2456:	1f 92       	push	r1
    2458:	cd b7       	in	r28, 0x3d	; 61
    245a:	de b7       	in	r29, 0x3e	; 62
    245c:	00 91 75 47 	lds	r16, 0x4775	; 0x804775 <frameNumber>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:679
  byte r, g, b;
  getModeColors(&r, &g, &b, frameNumber);
    2460:	10 91 76 47 	lds	r17, 0x4776	; 0x804776 <frameNumber+0x1>
    2464:	20 91 77 47 	lds	r18, 0x4777	; 0x804777 <frameNumber+0x2>
    2468:	30 91 78 47 	lds	r19, 0x4778	; 0x804778 <frameNumber+0x3>
    246c:	ae 01       	movw	r20, r28
    246e:	4d 5f       	subi	r20, 0xFD	; 253
    2470:	5f 4f       	sbci	r21, 0xFF	; 255
    2472:	be 01       	movw	r22, r28
    2474:	6e 5f       	subi	r22, 0xFE	; 254
    2476:	7f 4f       	sbci	r23, 0xFF	; 255
    2478:	ce 01       	movw	r24, r28
    247a:	01 96       	adiw	r24, 0x01	; 1
    247c:	66 de       	rcall	.-820    	; 0x214a <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)>
    247e:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    2482:	84 30       	cpi	r24, 0x04	; 4
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:680
  pushPixel(r, g, b, currentValueRight[currentMode == 4 ? 2 : 3]);
    2484:	99 f0       	breq	.+38     	; 0x24ac <updatePatternWave()+0x60>
    2486:	83 e0       	ldi	r24, 0x03	; 3
    2488:	90 e0       	ldi	r25, 0x00	; 0
    248a:	8f 57       	subi	r24, 0x7F	; 127
    248c:	98 4b       	sbci	r25, 0xB8	; 184
    248e:	fc 01       	movw	r30, r24
    2490:	20 81       	ld	r18, Z
    2492:	4b 81       	ldd	r20, Y+3	; 0x03
    2494:	6a 81       	ldd	r22, Y+2	; 0x02
    2496:	89 81       	ldd	r24, Y+1	; 0x01
    2498:	0e 94 bf 08 	call	0x117e	; 0x117e <pushPixel(unsigned char, unsigned char, unsigned char, unsigned char)>
    249c:	23 96       	adiw	r28, 0x03	; 3
    249e:	cd bf       	out	0x3d, r28	; 61
    24a0:	de bf       	out	0x3e, r29	; 62
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:681
}
    24a2:	df 91       	pop	r29
    24a4:	cf 91       	pop	r28
    24a6:	1f 91       	pop	r17
    24a8:	0f 91       	pop	r16
    24aa:	08 95       	ret
    24ac:	82 e0       	ldi	r24, 0x02	; 2
    24ae:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:680


void updatePatternWave() {
  byte r, g, b;
  getModeColors(&r, &g, &b, frameNumber);
  pushPixel(r, g, b, currentValueRight[currentMode == 4 ? 2 : 3]);
    24b0:	ec cf       	rjmp	.-40     	; 0x248a <updatePatternWave()+0x3e>

000024b2 <initLookupDrift2()>:
initLookupDrift2():
    24b2:	8f 92       	push	r8
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:355
      scratch[(j / 2) * 3 + 2] = r >> 8;
    }
  }
}

void initLookupDrift2() {
    24b4:	9f 92       	push	r9
    24b6:	af 92       	push	r10
    24b8:	bf 92       	push	r11
    24ba:	cf 92       	push	r12
    24bc:	df 92       	push	r13
    24be:	ef 92       	push	r14
    24c0:	ff 92       	push	r15
    24c2:	0f 93       	push	r16
    24c4:	1f 93       	push	r17
    24c6:	cf 93       	push	r28
    24c8:	df 93       	push	r29
    24ca:	07 e8       	ldi	r16, 0x87	; 135
    24cc:	14 e4       	ldi	r17, 0x44	; 68
    24ce:	d0 e0       	ldi	r29, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:357
  unsigned int start = (LENGTH * 3 + 1) / 2;
  for (unsigned int i = 0; i < getTransitionFrames(); i++) {
    24d0:	c0 e0       	ldi	r28, 0x00	; 0
    24d2:	0e 94 c9 07 	call	0xf92	; 0xf92 <getTransitionFrames()>
    24d6:	c8 17       	cp	r28, r24
    24d8:	d9 07       	cpc	r29, r25
    24da:	08 f0       	brcs	.+2      	; 0x24de <initLookupDrift2()+0x2c>
    24dc:	41 c0       	rjmp	.+130    	; 0x2560 <initLookupDrift2()+0xae>
getModeRatio():
    24de:	0e 94 c9 07 	call	0xf92	; 0xf92 <getTransitionFrames()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:818
  }
}

byte getModeRatio(unsigned int fnumber) {
  {
    float ratio = ((float)fnumber) / getTransitionFrames();
    24e2:	7c 01       	movw	r14, r24
    24e4:	be 01       	movw	r22, r28
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    24e8:	80 e0       	ldi	r24, 0x00	; 0
    24ea:	0e 94 70 22 	call	0x44e0	; 0x44e0 <__floatunsisf>
    24ee:	4b 01       	movw	r8, r22
    24f0:	5c 01       	movw	r10, r24
    24f2:	b7 01       	movw	r22, r14
    24f4:	90 e0       	ldi	r25, 0x00	; 0
    24f6:	80 e0       	ldi	r24, 0x00	; 0
    24f8:	0e 94 70 22 	call	0x44e0	; 0x44e0 <__floatunsisf>
    24fc:	9b 01       	movw	r18, r22
    24fe:	ac 01       	movw	r20, r24
    2500:	c5 01       	movw	r24, r10
    2502:	b4 01       	movw	r22, r8
    2504:	0e 94 dc 21 	call	0x43b8	; 0x43b8 <__divsf3>
    2508:	6b 01       	movw	r12, r22
    250a:	7c 01       	movw	r14, r24
    250c:	25 ec       	ldi	r18, 0xC5	; 197
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:819
    if (ratio > 1.001 || ratio < 0.0) {
    250e:	30 e2       	ldi	r19, 0x20	; 32
    2510:	40 e8       	ldi	r20, 0x80	; 128
    2512:	5f e3       	ldi	r21, 0x3F	; 63
    2514:	0e 94 22 23 	call	0x4644	; 0x4644 <__gesf2>
    2518:	18 16       	cp	r1, r24
    251a:	9c f4       	brge	.+38     	; 0x2542 <initLookupDrift2()+0x90>
    251c:	6f ed       	ldi	r22, 0xDF	; 223
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:820
      Serial.print(F("ERROR: ratio out of range"));
    251e:	72 e0       	ldi	r23, 0x02	; 2
    2520:	8f e8       	ldi	r24, 0x8F	; 143
    2522:	97 e4       	ldi	r25, 0x47	; 71
    2524:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
print():
    2528:	42 e0       	ldi	r20, 0x02	; 2
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:110
    252a:	c7 01       	movw	r24, r14
    252c:	b6 01       	movw	r22, r12
    252e:	2e dd       	rcall	.-1444   	; 0x1f8c <Print::printFloat(double, unsigned char) [clone .constprop.8]>
write():
    2530:	65 ef       	ldi	r22, 0xF5	; 245
    2532:	70 e4       	ldi	r23, 0x40	; 64
    2534:	8f e8       	ldi	r24, 0x8F	; 143
    2536:	97 e4       	ldi	r25, 0x47	; 71
    2538:	c4 dc       	rcall	.-1656   	; 0x1ec2 <Print::write(char const*) [clone .part.2]>
getModeRatio():
    253a:	8f e8       	ldi	r24, 0x8F	; 143
    253c:	97 e4       	ldi	r25, 0x47	; 71
    253e:	0e 94 76 06 	call	0xcec	; 0xcec <UartClass::flush()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:822
      Serial.println(ratio);
      Serial.flush();
    2542:	20 e0       	ldi	r18, 0x00	; 0
    2544:	30 e8       	ldi	r19, 0x80	; 128
    2546:	4f e7       	ldi	r20, 0x7F	; 127
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:825
    }

    return (byte)(ratio * 255.5);
    2548:	53 e4       	ldi	r21, 0x43	; 67
    254a:	c7 01       	movw	r24, r14
    254c:	b6 01       	movw	r22, r12
    254e:	0e 94 26 23 	call	0x464c	; 0x464c <__mulsf3>
    2552:	0e 94 44 22 	call	0x4488	; 0x4488 <__fixunssfsi>
    2556:	f8 01       	movw	r30, r16
    2558:	61 93       	st	Z+, r22
    255a:	8f 01       	movw	r16, r30
initLookupDrift2():
    255c:	21 96       	adiw	r28, 0x01	; 1
    255e:	b9 cf       	rjmp	.-142    	; 0x24d2 <initLookupDrift2()+0x20>
    2560:	df 91       	pop	r29
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:357
  }
}

void initLookupDrift2() {
  unsigned int start = (LENGTH * 3 + 1) / 2;
  for (unsigned int i = 0; i < getTransitionFrames(); i++) {
    2562:	cf 91       	pop	r28
    2564:	1f 91       	pop	r17
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:360
    scratch[start + i] = getModeRatio(i);
  }
}
    2566:	0f 91       	pop	r16
    2568:	ff 90       	pop	r15
    256a:	ef 90       	pop	r14
    256c:	df 90       	pop	r13
    256e:	cf 90       	pop	r12
    2570:	bf 90       	pop	r11
    2572:	af 90       	pop	r10
    2574:	9f 90       	pop	r9
    2576:	8f 90       	pop	r8
    2578:	08 95       	ret

0000257a <__cxa_pure_virtual>:
__cxa_pure_virtual():
    257a:	0e 94 b9 23 	call	0x4772	; 0x4772 <abort>

0000257e <setMode(unsigned char)>:
setMode():
    257e:	af 92       	push	r10
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/abi.cpp:27
extern "C" void __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));

void __cxa_pure_virtual(void) {
  // We might want to write some diagnostics to uart in this case
  //std::terminate();
  abort();
    2580:	bf 92       	push	r11
    2582:	cf 92       	push	r12
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:316
    if (currentMode == 1) currentMode++;
    setMode(currentMode + 1);
  }
}

void setMode(byte mode) {
    2584:	df 92       	push	r13
    2586:	ef 92       	push	r14
    2588:	ff 92       	push	r15
    258a:	0f 93       	push	r16
    258c:	1f 93       	push	r17
    258e:	cf 93       	push	r28
    2590:	df 93       	push	r29
    2592:	80 93 89 47 	sts	0x4789, r24	; 0x804789 <currentMode>
    2596:	8c ed       	ldi	r24, 0xDC	; 220
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:317
  currentMode = mode;
    2598:	95 e0       	ldi	r25, 0x05	; 5
    259a:	e9 e9       	ldi	r30, 0x99	; 153
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:318
  memset(scratch, 0, 3*LENGTH);
    259c:	f1 e4       	ldi	r31, 0x41	; 65
    259e:	df 01       	movw	r26, r30
    25a0:	9c 01       	movw	r18, r24
    25a2:	1d 92       	st	X+, r1
    25a4:	21 50       	subi	r18, 0x01	; 1
    25a6:	30 40       	sbci	r19, 0x00	; 0
    25a8:	e1 f7       	brne	.-8      	; 0x25a2 <setMode(unsigned char)+0x24>
    25aa:	e6 e2       	ldi	r30, 0x26	; 38
    25ac:	f8 e4       	ldi	r31, 0x48	; 72
    25ae:	df 01       	movw	r26, r30
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:319
  memset(pixels, 0, 3*LENGTH);
    25b0:	9c 01       	movw	r18, r24
    25b2:	1d 92       	st	X+, r1
    25b4:	21 50       	subi	r18, 0x01	; 1
    25b6:	30 40       	sbci	r19, 0x00	; 0
    25b8:	e1 f7       	brne	.-8      	; 0x25b2 <setMode(unsigned char)+0x34>
    25ba:	81 e8       	ldi	r24, 0x81	; 129
    25bc:	a8 2e       	mov	r10, r24
    25be:	87 e4       	ldi	r24, 0x47	; 71
    25c0:	b8 2e       	mov	r11, r24
    25c2:	09 e7       	ldi	r16, 0x79	; 121
    25c4:	17 e4       	ldi	r17, 0x47	; 71
    25c6:	d0 e0       	ldi	r29, 0x00	; 0
    25c8:	c0 e0       	ldi	r28, 0x00	; 0
    25ca:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    25ce:	38 e0       	ldi	r19, 0x08	; 8
    25d0:	83 9f       	mul	r24, r19
    25d2:	c0 01       	movw	r24, r0
    25d4:	11 24       	eor	r1, r1
    25d6:	8c 0f       	add	r24, r28
    25d8:	9d 1f       	adc	r25, r29
    25da:	fc 01       	movw	r30, r24
    25dc:	e9 57       	subi	r30, 0x79	; 121
    25de:	fd 4f       	sbci	r31, 0xFD	; 253
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:321
  for (byte i = 0; i < 8; i++) { //set the current setting values to defaults
    if (pgm_read_byte_near(&defaultValueLeft[currentMode][i]) == 255) {
    25e0:	24 91       	lpm	r18, Z
    25e2:	2f 3f       	cpi	r18, 0xFF	; 255
    25e4:	09 f0       	breq	.+2      	; 0x25e8 <setMode(unsigned char)+0x6a>
    25e6:	66 c0       	rjmp	.+204    	; 0x26b4 <setMode(unsigned char)+0x136>
    25e8:	fc 01       	movw	r30, r24
    25ea:	e5 5c       	subi	r30, 0xC5	; 197
    25ec:	fb 4f       	sbci	r31, 0xFB	; 251
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:322
      currentValueLeft[i] = random(pgm_read_byte_near(&maxValueLeft[currentMode][i]));
    25ee:	e4 91       	lpm	r30, Z
    25f0:	ce 2e       	mov	r12, r30
    25f2:	d1 2c       	mov	r13, r1
    25f4:	f1 2c       	mov	r15, r1
    25f6:	e1 2c       	mov	r14, r1
random():
    25f8:	c1 14       	cp	r12, r1
    25fa:	d1 04       	cpc	r13, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:37
  }
}

long random(long howbig)
{
  if (howbig == 0) {
    25fc:	e1 04       	cpc	r14, r1
    25fe:	f1 04       	cpc	r15, r1
    2600:	39 f0       	breq	.+14     	; 0x2610 <setMode(unsigned char)+0x92>
    2602:	0e 94 c1 20 	call	0x4182	; 0x4182 <random>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:40
    return 0;
  }
  return random() % howbig;
    2606:	a7 01       	movw	r20, r14
    2608:	96 01       	movw	r18, r12
    260a:	0e 94 16 21 	call	0x422c	; 0x422c <__divmodsi4>
    260e:	6b 01       	movw	r12, r22
setMode():
    2610:	fe 01       	movw	r30, r28
    2612:	e7 58       	subi	r30, 0x87	; 135
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:322
    2614:	f8 4b       	sbci	r31, 0xB8	; 184
    2616:	c0 82       	st	Z, r12
    2618:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    261c:	b8 e0       	ldi	r27, 0x08	; 8
    261e:	8b 9f       	mul	r24, r27
    2620:	c0 01       	movw	r24, r0
    2622:	11 24       	eor	r1, r1
    2624:	8c 0f       	add	r24, r28
    2626:	9d 1f       	adc	r25, r29
    2628:	fc 01       	movw	r30, r24
    262a:	e9 57       	subi	r30, 0x79	; 121
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:326
    } else {
      currentValueLeft[i] = pgm_read_byte_near(&defaultValueLeft[currentMode][i]);
    }
    if (pgm_read_byte_near(&defaultValueLeft[currentMode][i]) == 255) {
    262c:	fd 4f       	sbci	r31, 0xFD	; 253
    262e:	e4 91       	lpm	r30, Z
    2630:	ef 3f       	cpi	r30, 0xFF	; 255
    2632:	09 f0       	breq	.+2      	; 0x2636 <setMode(unsigned char)+0xb8>
    2634:	43 c0       	rjmp	.+134    	; 0x26bc <setMode(unsigned char)+0x13e>
    2636:	fc 01       	movw	r30, r24
    2638:	ec 5a       	subi	r30, 0xAC	; 172
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:327
      currentValueRight[i] = random(pgm_read_byte_near(&maxValueRight[currentMode][i]));
    263a:	f8 4f       	sbci	r31, 0xF8	; 248
    263c:	e4 91       	lpm	r30, Z
    263e:	ce 2e       	mov	r12, r30
    2640:	d1 2c       	mov	r13, r1
    2642:	f1 2c       	mov	r15, r1
    2644:	e1 2c       	mov	r14, r1
random():
    2646:	c1 14       	cp	r12, r1
    2648:	d1 04       	cpc	r13, r1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:37
  }
}

long random(long howbig)
{
  if (howbig == 0) {
    264a:	e1 04       	cpc	r14, r1
    264c:	f1 04       	cpc	r15, r1
    264e:	39 f0       	breq	.+14     	; 0x265e <setMode(unsigned char)+0xe0>
    2650:	0e 94 c1 20 	call	0x4182	; 0x4182 <random>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:40
    return 0;
  }
  return random() % howbig;
    2654:	a7 01       	movw	r20, r14
    2656:	96 01       	movw	r18, r12
    2658:	0e 94 16 21 	call	0x422c	; 0x422c <__divmodsi4>
    265c:	6b 01       	movw	r12, r22
setMode():
    265e:	fe 01       	movw	r30, r28
    2660:	ef 57       	subi	r30, 0x7F	; 127
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:327
    2662:	f8 4b       	sbci	r31, 0xB8	; 184
    2664:	c0 82       	st	Z, r12
    2666:	21 96       	adiw	r28, 0x01	; 1
    2668:	bf ef       	ldi	r27, 0xFF	; 255
    266a:	ab 1a       	sub	r10, r27
    266c:	bb 0a       	sbc	r11, r27
    266e:	0f 5f       	subi	r16, 0xFF	; 255
    2670:	1f 4f       	sbci	r17, 0xFF	; 255
    2672:	c8 30       	cpi	r28, 0x08	; 8
    2674:	d1 05       	cpc	r29, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:320

void setMode(byte mode) {
  currentMode = mode;
  memset(scratch, 0, 3*LENGTH);
  memset(pixels, 0, 3*LENGTH);
  for (byte i = 0; i < 8; i++) { //set the current setting values to defaults
    2676:	09 f0       	breq	.+2      	; 0x267a <setMode(unsigned char)+0xfc>
    2678:	a8 cf       	rjmp	.-176    	; 0x25ca <setMode(unsigned char)+0x4c>
    267a:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:332
      currentValueRight[i] = random(pgm_read_byte_near(&maxValueRight[currentMode][i]));
    } else {
      currentValueRight[i] = pgm_read_byte_near(&defaultValueRight[currentMode][i]);
    }
  }
  if (currentMode == 10) {
    267e:	8a 30       	cpi	r24, 0x0A	; 10
    2680:	11 f4       	brne	.+4      	; 0x2686 <setMode(unsigned char)+0x108>
    2682:	17 df       	rcall	.-466    	; 0x24b2 <initLookupDrift2()>
    2684:	ca db       	rcall	.-2156   	; 0x1e1a <initColorsDrift2()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:333
    initLookupDrift2();
    2686:	10 92 75 47 	sts	0x4775, r1	; 0x804775 <frameNumber>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:334
    initColorsDrift2();
    268a:	10 92 76 47 	sts	0x4776, r1	; 0x804776 <frameNumber+0x1>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:337
  }
  // start with the first setting selected, in case we had a setting now out of index.
  frameNumber = 0;
    268e:	10 92 77 47 	sts	0x4777, r1	; 0x804777 <frameNumber+0x2>
    2692:	10 92 78 47 	sts	0x4778, r1	; 0x804778 <frameNumber+0x3>
    2696:	10 92 8b 41 	sts	0x418B, r1	; 0x80418b <currentSettingLeft>
    269a:	10 92 8a 41 	sts	0x418A, r1	; 0x80418a <currentSettingRight>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:338
  currentSettingLeft = 0;
    269e:	df 91       	pop	r29
    26a0:	cf 91       	pop	r28
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:339
  currentSettingRight = 0;
    26a2:	1f 91       	pop	r17
    26a4:	0f 91       	pop	r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:340
}
    26a6:	ff 90       	pop	r15
    26a8:	ef 90       	pop	r14
    26aa:	df 90       	pop	r13
    26ac:	cf 90       	pop	r12
    26ae:	bf 90       	pop	r11
    26b0:	af 90       	pop	r10
    26b2:	08 95       	ret
    26b4:	e4 91       	lpm	r30, Z
    26b6:	d8 01       	movw	r26, r16
    26b8:	ec 93       	st	X, r30
    26ba:	ae cf       	rjmp	.-164    	; 0x2618 <setMode(unsigned char)+0x9a>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:324
  memset(pixels, 0, 3*LENGTH);
  for (byte i = 0; i < 8; i++) { //set the current setting values to defaults
    if (pgm_read_byte_near(&defaultValueLeft[currentMode][i]) == 255) {
      currentValueLeft[i] = random(pgm_read_byte_near(&maxValueLeft[currentMode][i]));
    } else {
      currentValueLeft[i] = pgm_read_byte_near(&defaultValueLeft[currentMode][i]);
    26bc:	fc 01       	movw	r30, r24
    26be:	e1 5d       	subi	r30, 0xD1	; 209
    26c0:	fd 4f       	sbci	r31, 0xFD	; 253
    26c2:	e4 91       	lpm	r30, Z
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:329
    }
    if (pgm_read_byte_near(&defaultValueLeft[currentMode][i]) == 255) {
      currentValueRight[i] = random(pgm_read_byte_near(&maxValueRight[currentMode][i]));
    } else {
      currentValueRight[i] = pgm_read_byte_near(&defaultValueRight[currentMode][i]);
    26c4:	d5 01       	movw	r26, r10
    26c6:	ec 93       	st	X, r30
    26c8:	ce cf       	rjmp	.-100    	; 0x2666 <setMode(unsigned char)+0xe8>

000026ca <__vector_22>:
__vector_22():
    26ca:	1f 92       	push	r1
    26cc:	0f 92       	push	r0
    26ce:	0f b6       	in	r0, 0x3f	; 63
    26d0:	0f 92       	push	r0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:58
  ctrla |= USART_RXCIE_bm; // turn on receive complete
  ctrla &= ~USART_TXCIE_bm; // turn off transmit complete
  USART0.CTRLA = ctrla;
}

ISR(USART0_DRE_vect) {
    26d2:	11 24       	eor	r1, r1
    26d4:	0b b6       	in	r0, 0x3b	; 59
    26d6:	0f 92       	push	r0
    26d8:	2f 93       	push	r18
    26da:	3f 93       	push	r19
    26dc:	4f 93       	push	r20
    26de:	5f 93       	push	r21
    26e0:	6f 93       	push	r22
    26e2:	7f 93       	push	r23
    26e4:	8f 93       	push	r24
    26e6:	9f 93       	push	r25
    26e8:	af 93       	push	r26
    26ea:	bf 93       	push	r27
    26ec:	ef 93       	push	r30
    26ee:	ff 93       	push	r31
    26f0:	8f e8       	ldi	r24, 0x8F	; 143
    26f2:	97 e4       	ldi	r25, 0x47	; 71
    26f4:	0e 94 e5 05 	call	0xbca	; 0xbca <UartClass::_tx_data_empty_irq(UartClass&)>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:59
  UartClass::_tx_data_empty_irq(Serial0);
    26f8:	ff 91       	pop	r31
    26fa:	ef 91       	pop	r30
    26fc:	bf 91       	pop	r27
    26fe:	af 91       	pop	r26
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:60
}
    2700:	9f 91       	pop	r25
    2702:	8f 91       	pop	r24
    2704:	7f 91       	pop	r23
    2706:	6f 91       	pop	r22
    2708:	5f 91       	pop	r21
    270a:	4f 91       	pop	r20
    270c:	3f 91       	pop	r19
    270e:	2f 91       	pop	r18
    2710:	0f 90       	pop	r0
    2712:	0b be       	out	0x3b, r0	; 59
    2714:	0f 90       	pop	r0
    2716:	0f be       	out	0x3f, r0	; 63
    2718:	0f 90       	pop	r0
    271a:	1f 90       	pop	r1
    271c:	18 95       	reti

0000271e <__vector_23>:
__vector_23():
    271e:	1f 92       	push	r1
    2720:	0f 92       	push	r0
    2722:	0f b6       	in	r0, 0x3f	; 63
    2724:	0f 92       	push	r0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:45

ISR(USART0_RXC_vect) {
  UartClass::_rx_complete_irq(Serial0);
}

ISR(USART0_TXC_vect) { //only called for half duplex mode, so we don't get all of the characters we sent.
    2726:	11 24       	eor	r1, r1
    2728:	8f 93       	push	r24
    272a:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <__TEXT_REGION_LENGTH__+0x7e0804>
    272e:	87 ff       	sbrs	r24, 7
    2730:	03 c0       	rjmp	.+6      	; 0x2738 <__vector_23+0x1a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:47
  uint8_t ctrla;
  while (USART0.STATUS & USART_RXCIF_bm) {
    2732:	80 91 00 08 	lds	r24, 0x0800	; 0x800800 <__TEXT_REGION_LENGTH__+0x7e0800>
    2736:	f9 cf       	rjmp	.-14     	; 0x272a <__vector_23+0xc>
    2738:	80 91 05 08 	lds	r24, 0x0805	; 0x800805 <__TEXT_REGION_LENGTH__+0x7e0805>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:50
    // dump these these, using local var as trashcan.
    // Used only in half duplex - this int means switching from send to receive.
    ctrla = USART0.RXDATAL;
    273c:	8f 7b       	andi	r24, 0xBF	; 191
    273e:	80 68       	ori	r24, 0x80	; 128
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:52
  }
  ctrla = USART0.CTRLA;
    2740:	80 93 05 08 	sts	0x0805, r24	; 0x800805 <__TEXT_REGION_LENGTH__+0x7e0805>
    2744:	8f 91       	pop	r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:54
  ctrla |= USART_RXCIE_bm; // turn on receive complete
  ctrla &= ~USART_TXCIE_bm; // turn off transmit complete
    2746:	0f 90       	pop	r0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:55
  USART0.CTRLA = ctrla;
    2748:	0f be       	out	0x3f, r0	; 63
    274a:	0f 90       	pop	r0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:56
}
    274c:	1f 90       	pop	r1
    274e:	18 95       	reti

00002750 <__vector_21>:
__vector_21():
    2750:	1f 92       	push	r1
    2752:	0f 92       	push	r0
    2754:	0f b6       	in	r0, 0x3f	; 63
    2756:	0f 92       	push	r0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:41
// "used" attribute so are never dropped and they keep the
// UartClass instance in as well. Putting each instance in its own
// file prevents the linker from pulling in any unused instances in the
// first place.

ISR(USART0_RXC_vect) {
    2758:	11 24       	eor	r1, r1
    275a:	0b b6       	in	r0, 0x3b	; 59
    275c:	0f 92       	push	r0
    275e:	2f 93       	push	r18
    2760:	8f 93       	push	r24
    2762:	9f 93       	push	r25
    2764:	ef 93       	push	r30
    2766:	ff 93       	push	r31
_rx_complete_irq():
    2768:	e0 91 9b 47 	lds	r30, 0x479B	; 0x80479b <Serial0+0xc>
    276c:	f0 91 9c 47 	lds	r31, 0x479C	; 0x80479c <Serial0+0xd>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:59
  #      # # #
 ### ####  #  */

void UartClass::_rx_complete_irq(UartClass& uartClass) {
  // if (bit_is_clear(*_rxdatah, USART_PERR_bp)) {
  uint8_t rxDataH = uartClass._hwserial_module->RXDATAH;
    2770:	81 81       	ldd	r24, Z+1	; 0x01
    2772:	90 81       	ld	r25, Z
    2774:	e0 91 a2 47 	lds	r30, 0x47A2	; 0x8047a2 <Serial0+0x13>
    2778:	81 fd       	sbrc	r24, 1
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:60
  uint8_t c = uartClass._hwserial_module->RXDATAL;  // no need to read the data twice. read it, then decide what to do
    277a:	0d c0       	rjmp	.+26     	; 0x2796 <__vector_21+0x46>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:61
  rx_buffer_index_t rxHead = uartClass._rx_buffer_head;
    277c:	81 e0       	ldi	r24, 0x01	; 1
    277e:	8e 0f       	add	r24, r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:63

  if (!(rxDataH & USART_PERR_bm)) {
    2780:	8f 73       	andi	r24, 0x3F	; 63
    2782:	20 91 a3 47 	lds	r18, 0x47A3	; 0x8047a3 <Serial0+0x14>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:66
    // No Parity error, read byte and store it in the buffer if there is room
    // unsigned char c = uartClass._hwserial_module->RXDATAL;
    rx_buffer_index_t i = (unsigned int)(rxHead + 1) % SERIAL_RX_BUFFER_SIZE;
    2786:	82 17       	cp	r24, r18
    2788:	31 f0       	breq	.+12     	; 0x2796 <__vector_21+0x46>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:72

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != uartClass._rx_buffer_tail) {
    278a:	f0 e0       	ldi	r31, 0x00	; 0
    278c:	e1 57       	subi	r30, 0x71	; 113
    278e:	f8 4b       	sbci	r31, 0xB8	; 184
    2790:	97 8b       	std	Z+23, r25	; 0x17
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:73
      uartClass._rx_buffer[rxHead] = c;
    2792:	80 93 a2 47 	sts	0x47A2, r24	; 0x8047a2 <Serial0+0x13>
__vector_21():
    2796:	ff 91       	pop	r31
    2798:	ef 91       	pop	r30
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:74
      uartClass._rx_buffer_head = i;
    279a:	9f 91       	pop	r25
    279c:	8f 91       	pop	r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART0.cpp:43
  UartClass::_rx_complete_irq(Serial0);
}
    279e:	2f 91       	pop	r18
    27a0:	0f 90       	pop	r0
    27a2:	0b be       	out	0x3b, r0	; 59
    27a4:	0f 90       	pop	r0
    27a6:	0f be       	out	0x3f, r0	; 63
    27a8:	0f 90       	pop	r0
    27aa:	1f 90       	pop	r1
    27ac:	18 95       	reti

000027ae <__vector_31>:
__vector_31():
    27ae:	1f 92       	push	r1
    27b0:	0f 92       	push	r0
    27b2:	0f b6       	in	r0, 0x3f	; 63
    27b4:	0f 92       	push	r0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:136
  #elif defined(MILLIS_USE_TIMERB4)
    ISR(TCB4_INT_vect)
  #else
    #error "no millis timer selected"
  #endif
  {
    27b6:	11 24       	eor	r1, r1
    27b8:	8f 93       	push	r24
    27ba:	9f 93       	push	r25
    27bc:	af 93       	push	r26
    27be:	bf 93       	push	r27
    27c0:	80 91 7e 41 	lds	r24, 0x417E	; 0x80417e <timer_millis>
    27c4:	90 91 7f 41 	lds	r25, 0x417F	; 0x80417f <timer_millis+0x1>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:142

    // copy these to local variables so they can be stored in registers
    // (volatile variables must be read from memory on every access)
    #if (defined(MILLIS_USE_TIMERB0) || defined(MILLIS_USE_TIMERB1) || defined(MILLIS_USE_TIMERB2) || defined(MILLIS_USE_TIMERB3) || defined(MILLIS_USE_TIMERB4))
      #if(F_CPU>1000000)
        timer_millis++; //that's all we need to do!
    27c8:	a0 91 80 41 	lds	r26, 0x4180	; 0x804180 <timer_millis+0x2>
    27cc:	b0 91 81 41 	lds	r27, 0x4181	; 0x804181 <timer_millis+0x3>
    27d0:	01 96       	adiw	r24, 0x01	; 1
    27d2:	a1 1d       	adc	r26, r1
    27d4:	b1 1d       	adc	r27, r1
    27d6:	80 93 7e 41 	sts	0x417E, r24	; 0x80417e <timer_millis>
    27da:	90 93 7f 41 	sts	0x417F, r25	; 0x80417f <timer_millis+0x1>
    27de:	a0 93 80 41 	sts	0x4180, r26	; 0x804180 <timer_millis+0x2>
    27e2:	b0 93 81 41 	sts	0x4181, r27	; 0x804181 <timer_millis+0x3>
    27e6:	81 e0       	ldi	r24, 0x01	; 1
    27e8:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
    27ec:	bf 91       	pop	r27
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:173
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.INTFLAGS = TCD_OVF_bm;
    #elif defined(MILLIS_USE_TIMERRTC)
      RTC.INTFLAGS = RTC_OVF_bm;
    #else //timerb
      _timer->INTFLAGS = TCB_CAPT_bm;
    27ee:	af 91       	pop	r26
    27f0:	9f 91       	pop	r25
    27f2:	8f 91       	pop	r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:175
    #endif
  }
    27f4:	0f 90       	pop	r0
    27f6:	0f be       	out	0x3f, r0	; 63
    27f8:	0f 90       	pop	r0
    27fa:	1f 90       	pop	r1
    27fc:	18 95       	reti

000027fe <__vector_44>:
__vector_44():
    27fe:	1f 92       	push	r1
    2800:	0f 92       	push	r0
    2802:	0f b6       	in	r0, 0x3f	; 63
    2804:	0f 92       	push	r0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1151
  }
  lastpacketsig += rxBuffer[len];
  return lastpacketsig;
}

ISR (TCB3_INT_vect) {
    2806:	11 24       	eor	r1, r1
    2808:	0b b6       	in	r0, 0x3b	; 59
    280a:	0f 92       	push	r0
    280c:	2f 93       	push	r18
    280e:	3f 93       	push	r19
    2810:	4f 93       	push	r20
    2812:	5f 93       	push	r21
    2814:	6f 93       	push	r22
    2816:	7f 93       	push	r23
    2818:	8f 93       	push	r24
    281a:	9f 93       	push	r25
    281c:	af 93       	push	r26
    281e:	bf 93       	push	r27
    2820:	ef 93       	push	r30
    2822:	ff 93       	push	r31
    2824:	40 91 3c 0b 	lds	r20, 0x0B3C	; 0x800b3c <__TEXT_REGION_LENGTH__+0x7e0b3c>
    2828:	50 91 3d 0b 	lds	r21, 0x0B3D	; 0x800b3d <__TEXT_REGION_LENGTH__+0x7e0b3d>
digitalReadFast():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1153
  static unsigned long lasttime = 0;
  unsigned int newTime = TCB3.CCMP; //immediately get the ICR value
    282c:	86 b3       	in	r24, 0x16	; 22
__vector_44():
    282e:	28 2f       	mov	r18, r24
    2830:	28 70       	andi	r18, 0x08	; 8
    2832:	83 fd       	sbrc	r24, 3
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:490

  // Old style port logic is a small integer 0 for PORTA, 1 for PORTB etc.
  vport = (VPORT_t *)(port * 4);

  // Read pin value from VPORTx.IN register
  return !!(vport->IN & mask);
    2834:	27 c0       	rjmp	.+78     	; 0x2884 <__vector_44+0x86>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1155
  uint8_t state = digitalReadFast(RF_PIN);
  TCB3.EVCTRL = state ? 0x51 : 0x41; //trigger on falling edge if pin is high, otherwise rising edge
    2836:	81 e4       	ldi	r24, 0x41	; 65
    2838:	80 93 34 0b 	sts	0x0B34, r24	; 0x800b34 <__TEXT_REGION_LENGTH__+0x7e0b34>
    283c:	80 91 7a 41 	lds	r24, 0x417A	; 0x80417a <__vector_44::lasttime>
    2840:	90 91 7b 41 	lds	r25, 0x417B	; 0x80417b <__vector_44::lasttime+0x1>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1156
  unsigned int duration = newTime - lasttime;
    2844:	ba 01       	movw	r22, r20
    2846:	68 1b       	sub	r22, r24
    2848:	79 0b       	sbc	r23, r25
    284a:	cb 01       	movw	r24, r22
    284c:	70 e0       	ldi	r23, 0x00	; 0
    284e:	60 e0       	ldi	r22, 0x00	; 0
    2850:	40 93 7a 41 	sts	0x417A, r20	; 0x80417a <__vector_44::lasttime>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1157
  lasttime = newTime;
    2854:	50 93 7b 41 	sts	0x417B, r21	; 0x80417b <__vector_44::lasttime+0x1>
    2858:	60 93 7c 41 	sts	0x417C, r22	; 0x80417c <__vector_44::lasttime+0x2>
    285c:	70 93 7d 41 	sts	0x417D, r23	; 0x80417d <__vector_44::lasttime+0x3>
    2860:	22 23       	and	r18, r18
    2862:	59 f1       	breq	.+86     	; 0x28ba <__vector_44+0xbc>
    2864:	f8 9b       	sbis	0x1f, 0	; 31
    2866:	10 c0       	rjmp	.+32     	; 0x2888 <__vector_44+0x8a>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1158
  if (state) {
    2868:	89 30       	cpi	r24, 0x09	; 9
    286a:	97 40       	sbci	r25, 0x07	; 7
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1159
    if (RFRX_NOW) {
    286c:	98 f0       	brcs	.+38     	; 0x2894 <__vector_44+0x96>
    286e:	f8 98       	cbi	0x1f, 0	; 31
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1160
      if (duration > rxLowMax) {
    2870:	10 92 79 41 	sts	0x4179, r1	; 0x804179 <bitnum>
    2874:	e9 e5       	ldi	r30, 0x59	; 89
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1177
      if (duration > rxZeroMin && duration < rxZeroMax) {
        dataIn = dataIn << 1;
      } else if (duration > rxOneMin && duration < rxOneMax) {
        dataIn = (dataIn << 1) + 1;
      } else {
        DONE_RX;
    2876:	f1 e4       	ldi	r31, 0x41	; 65
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1178
        bitnum = 0; // reset to bit zero
    2878:	80 e2       	ldi	r24, 0x20	; 32
    287a:	df 01       	movw	r26, r30
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1179
        memset((void*)rxBuffer, 0, 32); //clear buffer - memset on rxBuffer is safe because interrupts disabled in ISR
    287c:	1d 92       	st	X+, r1
    287e:	8a 95       	dec	r24
    2880:	e9 f7       	brne	.-6      	; 0x287c <__vector_44+0x7e>
    2882:	08 c0       	rjmp	.+16     	; 0x2894 <__vector_44+0x96>
    2884:	81 e5       	ldi	r24, 0x51	; 81
    2886:	d8 cf       	rjmp	.-80     	; 0x2838 <__vector_44+0x3a>
    2888:	83 58       	subi	r24, 0x83	; 131
    288a:	94 41       	sbci	r25, 0x14	; 20
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1155

ISR (TCB3_INT_vect) {
  static unsigned long lasttime = 0;
  unsigned int newTime = TCB3.CCMP; //immediately get the ICR value
  uint8_t state = digitalReadFast(RF_PIN);
  TCB3.EVCTRL = state ? 0x51 : 0x41; //trigger on falling edge if pin is high, otherwise rising edge
    288c:	8b 3d       	cpi	r24, 0xDB	; 219
    288e:	95 40       	sbci	r25, 0x05	; 5
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1166
        DONE_RX;
        bitnum = 0; // reset to bit zero
        memset((void*)rxBuffer, 0, 32); //clear buffer - memset on rxBuffer is safe because interrupts disabled in ISR
      }
    } else {
      if (duration > rxSyncMin && duration < rxSyncMax) {
    2890:	08 f4       	brcc	.+2      	; 0x2894 <__vector_44+0x96>
    2892:	f8 9a       	sbi	0x1f, 0	; 31
    2894:	ff 91       	pop	r31
    2896:	ef 91       	pop	r30
    2898:	bf 91       	pop	r27
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1167
        START_RX;
    289a:	af 91       	pop	r26
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1200
      } else {
        bitnum++;
      }
    }
  }
}
    289c:	9f 91       	pop	r25
    289e:	8f 91       	pop	r24
    28a0:	7f 91       	pop	r23
    28a2:	6f 91       	pop	r22
    28a4:	5f 91       	pop	r21
    28a6:	4f 91       	pop	r20
    28a8:	3f 91       	pop	r19
    28aa:	2f 91       	pop	r18
    28ac:	0f 90       	pop	r0
    28ae:	0b be       	out	0x3b, r0	; 59
    28b0:	0f 90       	pop	r0
    28b2:	0f be       	out	0x3f, r0	; 63
    28b4:	0f 90       	pop	r0
    28b6:	1f 90       	pop	r1
    28b8:	18 95       	reti
    28ba:	f8 9b       	sbis	0x1f, 0	; 31
    28bc:	eb cf       	rjmp	.-42     	; 0x2894 <__vector_44+0x96>
    28be:	9c 01       	movw	r18, r24
    28c0:	2d 52       	subi	r18, 0x2D	; 45
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1171
      if (duration > rxSyncMin && duration < rxSyncMax) {
        START_RX;
      }
    }
  } else {
    if (RFRX_NOW) {
    28c2:	31 40       	sbci	r19, 0x01	; 1
    28c4:	25 36       	cpi	r18, 0x65	; 101
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1172
      if (duration > rxZeroMin && duration < rxZeroMax) {
    28c6:	33 40       	sbci	r19, 0x03	; 3
    28c8:	c0 f5       	brcc	.+112    	; 0x293a <__vector_44+0x13c>
    28ca:	80 91 58 41 	lds	r24, 0x4158	; 0x804158 <dataIn>
    28ce:	88 0f       	add	r24, r24
    28d0:	80 93 58 41 	sts	0x4158, r24	; 0x804158 <dataIn>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1173
        dataIn = dataIn << 1;
    28d4:	80 91 79 41 	lds	r24, 0x4179	; 0x804179 <bitnum>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1175
      } else if (duration > rxOneMin && duration < rxOneMax) {
        dataIn = (dataIn << 1) + 1;
    28d8:	87 70       	andi	r24, 0x07	; 7
    28da:	87 30       	cpi	r24, 0x07	; 7
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1182
        DONE_RX;
        bitnum = 0; // reset to bit zero
        memset((void*)rxBuffer, 0, 32); //clear buffer - memset on rxBuffer is safe because interrupts disabled in ISR
        return;
      }
      if ((bitnum & 7) == 7) {
    28dc:	09 f5       	brne	.+66     	; 0x2920 <__vector_44+0x122>
    28de:	80 91 58 41 	lds	r24, 0x4158	; 0x804158 <dataIn>
    28e2:	e0 91 79 41 	lds	r30, 0x4179	; 0x804179 <bitnum>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1183
        rxBuffer[bitnum >> 3] = dataIn;
    28e6:	f0 e0       	ldi	r31, 0x00	; 0
    28e8:	93 e0       	ldi	r25, 0x03	; 3
    28ea:	f5 95       	asr	r31
    28ec:	e7 95       	ror	r30
    28ee:	9a 95       	dec	r25
    28f0:	e1 f7       	brne	.-8      	; 0x28ea <__vector_44+0xec>
    28f2:	e7 5a       	subi	r30, 0xA7	; 167
    28f4:	fe 4b       	sbci	r31, 0xBE	; 190
    28f6:	80 83       	st	Z, r24
    28f8:	80 91 79 41 	lds	r24, 0x4179	; 0x804179 <bitnum>
    28fc:	87 30       	cpi	r24, 0x07	; 7
    28fe:	71 f4       	brne	.+28     	; 0x291c <__vector_44+0x11e>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1184
        if (bitnum == 7) {
    2900:	80 91 58 41 	lds	r24, 0x4158	; 0x804158 <dataIn>
    2904:	82 95       	swap	r24
    2906:	86 95       	lsr	r24
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1185
          byte t = dataIn >> 6;
    2908:	86 95       	lsr	r24
    290a:	83 70       	andi	r24, 0x03	; 3
    290c:	09 f1       	breq	.+66     	; 0x2950 <__vector_44+0x152>
    290e:	81 30       	cpi	r24, 0x01	; 1
    2910:	09 f1       	breq	.+66     	; 0x2954 <__vector_44+0x156>
    2912:	82 30       	cpi	r24, 0x02	; 2
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1186
          pktLength = t ? (t == 1 ? 63 : (t == 2 ? 127 : 255)) : 31;
    2914:	09 f1       	breq	.+66     	; 0x2958 <__vector_44+0x15a>
    2916:	8f ef       	ldi	r24, 0xFF	; 255
    2918:	80 93 02 40 	sts	0x4002, r24	; 0x804002 <pktLength>
    291c:	10 92 58 41 	sts	0x4158, r1	; 0x804158 <dataIn>
    2920:	90 91 79 41 	lds	r25, 0x4179	; 0x804179 <bitnum>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1188
        }
        dataIn = 0;
    2924:	80 91 02 40 	lds	r24, 0x4002	; 0x804002 <pktLength>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1190
      }
      if (bitnum >= pktLength) {
    2928:	98 17       	cp	r25, r24
    292a:	c0 f0       	brcs	.+48     	; 0x295c <__vector_44+0x15e>
    292c:	10 92 79 41 	sts	0x4179, r1	; 0x804179 <bitnum>
    2930:	f8 98       	cbi	0x1f, 0	; 31
    2932:	f9 9a       	sbi	0x1f, 1	; 31
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1191
        bitnum = 0;
    2934:	10 92 35 0b 	sts	0x0B35, r1	; 0x800b35 <__TEXT_REGION_LENGTH__+0x7e0b35>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1192
        DONE_RX;
    2938:	ad cf       	rjmp	.-166    	; 0x2894 <__vector_44+0x96>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1193
        SET_MESSAGE;
    293a:	8f 5c       	subi	r24, 0xCF	; 207
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1194
        TCB3.INTCTRL = 0; //turn off input capture;
    293c:	94 40       	sbci	r25, 0x04	; 4
    293e:	85 36       	cpi	r24, 0x65	; 101
    2940:	93 40       	sbci	r25, 0x03	; 3
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1174
    }
  } else {
    if (RFRX_NOW) {
      if (duration > rxZeroMin && duration < rxZeroMax) {
        dataIn = dataIn << 1;
      } else if (duration > rxOneMin && duration < rxOneMax) {
    2942:	08 f0       	brcs	.+2      	; 0x2946 <__vector_44+0x148>
    2944:	94 cf       	rjmp	.-216    	; 0x286e <__vector_44+0x70>
    2946:	80 91 58 41 	lds	r24, 0x4158	; 0x804158 <dataIn>
    294a:	88 0f       	add	r24, r24
    294c:	8f 5f       	subi	r24, 0xFF	; 255
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1175
        dataIn = (dataIn << 1) + 1;
    294e:	c0 cf       	rjmp	.-128    	; 0x28d0 <__vector_44+0xd2>
    2950:	8f e1       	ldi	r24, 0x1F	; 31
    2952:	e2 cf       	rjmp	.-60     	; 0x2918 <__vector_44+0x11a>
    2954:	8f e3       	ldi	r24, 0x3F	; 63
    2956:	e0 cf       	rjmp	.-64     	; 0x2918 <__vector_44+0x11a>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1186
      }
      if ((bitnum & 7) == 7) {
        rxBuffer[bitnum >> 3] = dataIn;
        if (bitnum == 7) {
          byte t = dataIn >> 6;
          pktLength = t ? (t == 1 ? 63 : (t == 2 ? 127 : 255)) : 31;
    2958:	8f e7       	ldi	r24, 0x7F	; 127
    295a:	de cf       	rjmp	.-68     	; 0x2918 <__vector_44+0x11a>
    295c:	80 91 79 41 	lds	r24, 0x4179	; 0x804179 <bitnum>
    2960:	8f 5f       	subi	r24, 0xFF	; 255
    2962:	80 93 79 41 	sts	0x4179, r24	; 0x804179 <bitnum>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1196
        bitnum = 0;
        DONE_RX;
        SET_MESSAGE;
        TCB3.INTCTRL = 0; //turn off input capture;
      } else {
        bitnum++;
    2966:	96 cf       	rjmp	.-212    	; 0x2894 <__vector_44+0x96>

00002968 <__vector_30>:
__vector_30():
    2968:	1f 92       	push	r1
    296a:	0f 92       	push	r0
    296c:	0f b6       	in	r0, 0x3f	; 63
    296e:	0f 92       	push	r0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:998
  PORTC.PIN1CTRL = PORT_PULLUPEN_bm | PORT_ISC_BOTHEDGES_gc;
  PORTC.PIN2CTRL = PORT_PULLUPEN_bm | PORT_ISC_BOTHEDGES_gc;
  PORTC.PIN3CTRL = PORT_PULLUPEN_bm | PORT_ISC_BOTHEDGES_gc;
}

ISR(PORTC_PORT_vect) {
    2970:	11 24       	eor	r1, r1
    2972:	0b b6       	in	r0, 0x3b	; 59
    2974:	0f 92       	push	r0
    2976:	2f 93       	push	r18
    2978:	3f 93       	push	r19
    297a:	4f 93       	push	r20
    297c:	5f 93       	push	r21
    297e:	8f 93       	push	r24
    2980:	9f 93       	push	r25
    2982:	ef 93       	push	r30
    2984:	ff 93       	push	r31
    2986:	8a b1       	in	r24, 0x0a	; 10
    2988:	9b b1       	in	r25, 0x0b	; 11
    298a:	9b b9       	out	0x0b, r25	; 11
    298c:	90 91 00 40 	lds	r25, 0x4000	; 0x804000 <__DATA_REGION_ORIGIN__>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1007
  static int8_t EncR_Val = 0;   //encoder value
  static const int8_t enc_states [] PROGMEM   = {0,-1,  1, 0,  1, 0, 0, -1,-1, 0, 0,  1, 0,  1, -1, 0};  //encoder lookup table
  //static const int8_t enc_states [] PROGMEM = {0, 1, -1, 0, -1, 0, 0,  1, 1, 0, 0, -1, 0, -1,  1, 0}; // reversed encoder table
  uint8_t enc_pinstate = ENC_PORT_READ();
  
  VPORTC.INTFLAGS = VPORTC.INTFLAGS;
    2990:	99 0f       	add	r25, r25
    2992:	99 0f       	add	r25, r25
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1009
  EncL_Prev <<= 2; //remember previous state
  EncR_Prev <<= 2; //remember previous state
    2994:	e8 2f       	mov	r30, r24
    2996:	ef 70       	andi	r30, 0x0F	; 15
    2998:	e6 95       	lsr	r30
    299a:	e6 95       	lsr	r30
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1005
  static int8_t EncL_Val = 0;   //encoder value
  static uint8_t EncR_Prev = 3;  //lookup table index
  static int8_t EncR_Val = 0;   //encoder value
  static const int8_t enc_states [] PROGMEM   = {0,-1,  1, 0,  1, 0, 0, -1,-1, 0, 0,  1, 0,  1, -1, 0};  //encoder lookup table
  //static const int8_t enc_states [] PROGMEM = {0, 1, -1, 0, -1, 0, 0,  1, 1, 0, 0, -1, 0, -1,  1, 0}; // reversed encoder table
  uint8_t enc_pinstate = ENC_PORT_READ();
    299c:	20 91 01 40 	lds	r18, 0x4001	; 0x804001 <__vector_30::EncL_Prev>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1011
  
  VPORTC.INTFLAGS = VPORTC.INTFLAGS;
  EncL_Prev <<= 2; //remember previous state
  EncR_Prev <<= 2; //remember previous state

  EncL_Prev |= (enc_pinstate & 0x0C) >> 2;
    29a0:	22 0f       	add	r18, r18
    29a2:	22 0f       	add	r18, r18
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1008
  static const int8_t enc_states [] PROGMEM   = {0,-1,  1, 0,  1, 0, 0, -1,-1, 0, 0,  1, 0,  1, -1, 0};  //encoder lookup table
  //static const int8_t enc_states [] PROGMEM = {0, 1, -1, 0, -1, 0, 0,  1, 1, 0, 0, -1, 0, -1,  1, 0}; // reversed encoder table
  uint8_t enc_pinstate = ENC_PORT_READ();
  
  VPORTC.INTFLAGS = VPORTC.INTFLAGS;
  EncL_Prev <<= 2; //remember previous state
    29a4:	e2 2b       	or	r30, r18
    29a6:	e0 93 01 40 	sts	0x4001, r30	; 0x804001 <__vector_30::EncL_Prev>
    29aa:	83 70       	andi	r24, 0x03	; 3
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1011
  EncR_Prev <<= 2; //remember previous state

  EncL_Prev |= (enc_pinstate & 0x0C) >> 2;
    29ac:	98 2b       	or	r25, r24
    29ae:	90 93 00 40 	sts	0x4000, r25	; 0x804000 <__DATA_REGION_ORIGIN__>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1012
  EncR_Prev |= (enc_pinstate & 0x03);
    29b2:	ef 70       	andi	r30, 0x0F	; 15
    29b4:	f0 e0       	ldi	r31, 0x00	; 0
    29b6:	ed 56       	subi	r30, 0x6D	; 109
    29b8:	fb 4f       	sbci	r31, 0xFB	; 251
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1014

  EncL_Val += pgm_read_byte(&(enc_states[(EncL_Prev & 0x0F)]));
    29ba:	84 91       	lpm	r24, Z
    29bc:	e0 91 57 41 	lds	r30, 0x4157	; 0x804157 <__vector_30::EncL_Val>
    29c0:	8e 0f       	add	r24, r30
    29c2:	80 93 57 41 	sts	0x4157, r24	; 0x804157 <__vector_30::EncL_Val>
    29c6:	9f 70       	andi	r25, 0x0F	; 15
    29c8:	e9 2f       	mov	r30, r25
    29ca:	f0 e0       	ldi	r31, 0x00	; 0
    29cc:	ed 56       	subi	r30, 0x6D	; 109
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1015
  EncR_Val += pgm_read_byte(&(enc_states[(EncR_Prev & 0x0F)]));
    29ce:	fb 4f       	sbci	r31, 0xFB	; 251
    29d0:	94 91       	lpm	r25, Z
    29d2:	e0 91 56 41 	lds	r30, 0x4156	; 0x804156 <__vector_30::EncR_Val>
    29d6:	9e 0f       	add	r25, r30
    29d8:	90 93 56 41 	sts	0x4156, r25	; 0x804156 <__vector_30::EncR_Val>
    29dc:	84 30       	cpi	r24, 0x04	; 4
    29de:	0c f4       	brge	.+2      	; 0x29e2 <__vector_30+0x7a>
    29e0:	81 c0       	rjmp	.+258    	; 0x2ae4 <__vector_30+0x17c>
    29e2:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1018

  /* post "Navigation forward/reverse" event */
  if ( EncL_Val > 3 ) { //four steps forward
    29e6:	f0 e0       	ldi	r31, 0x00	; 0
    29e8:	e7 58       	subi	r30, 0x87	; 135
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1019
    if (currentValueLeft[currentSettingLeft] < pgm_read_byte_near(&maxValueLeft[currentMode][currentSettingLeft]))currentValueLeft[currentSettingLeft]++;
    29ea:	f8 4b       	sbci	r31, 0xB8	; 184
    29ec:	20 81       	ld	r18, Z
    29ee:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    29f2:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    29f6:	38 e0       	ldi	r19, 0x08	; 8
    29f8:	83 9f       	mul	r24, r19
    29fa:	a0 01       	movw	r20, r0
    29fc:	11 24       	eor	r1, r1
    29fe:	e4 0f       	add	r30, r20
    2a00:	f5 2f       	mov	r31, r21
    2a02:	f1 1d       	adc	r31, r1
    2a04:	e5 5c       	subi	r30, 0xC5	; 197
    2a06:	fb 4f       	sbci	r31, 0xFB	; 251
    2a08:	e4 91       	lpm	r30, Z
    2a0a:	2e 17       	cp	r18, r30
    2a0c:	40 f4       	brcc	.+16     	; 0x2a1e <__vector_30+0xb6>
    2a0e:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2a12:	f0 e0       	ldi	r31, 0x00	; 0
    2a14:	e7 58       	subi	r30, 0x87	; 135
    2a16:	f8 4b       	sbci	r31, 0xB8	; 184
    2a18:	20 81       	ld	r18, Z
    2a1a:	2f 5f       	subi	r18, 0xFF	; 255
    2a1c:	20 83       	st	Z, r18
    2a1e:	81 50       	subi	r24, 0x01	; 1
    2a20:	85 30       	cpi	r24, 0x05	; 5
    2a22:	10 f5       	brcc	.+68     	; 0x2a68 <__vector_30+0x100>
    2a24:	80 91 8b 41 	lds	r24, 0x418B	; 0x80418b <currentSettingLeft>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1021
    //hackjob to handle min exceeding max or vice versa.
    if ((currentMode == 1 || currentMode == 2 || currentMode == 3 || currentMode == 4 || currentMode == 5) && currentSettingLeft < 6) {
    2a28:	86 30       	cpi	r24, 0x06	; 6
    2a2a:	f0 f4       	brcc	.+60     	; 0x2a68 <__vector_30+0x100>
    2a2c:	80 91 8b 41 	lds	r24, 0x418B	; 0x80418b <currentSettingLeft>
    2a30:	80 fd       	sbrc	r24, 0
    2a32:	1a c0       	rjmp	.+52     	; 0x2a68 <__vector_30+0x100>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1022
      if (!(currentSettingLeft & 1)) {
    2a34:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2a38:	f0 e0       	ldi	r31, 0x00	; 0
    2a3a:	e7 58       	subi	r30, 0x87	; 135
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1023
        if (currentValueLeft[currentSettingLeft] > currentValueLeft[currentSettingLeft + 1]) {
    2a3c:	f8 4b       	sbci	r31, 0xB8	; 184
    2a3e:	20 81       	ld	r18, Z
    2a40:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2a44:	f0 e0       	ldi	r31, 0x00	; 0
    2a46:	e6 58       	subi	r30, 0x86	; 134
    2a48:	f8 4b       	sbci	r31, 0xB8	; 184
    2a4a:	80 81       	ld	r24, Z
    2a4c:	82 17       	cp	r24, r18
    2a4e:	60 f4       	brcc	.+24     	; 0x2a68 <__vector_30+0x100>
    2a50:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2a54:	f0 e0       	ldi	r31, 0x00	; 0
    2a56:	e7 58       	subi	r30, 0x87	; 135
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1024
          currentValueLeft[currentSettingLeft + 1] = currentValueLeft[currentSettingLeft];
    2a58:	f8 4b       	sbci	r31, 0xB8	; 184
    2a5a:	80 81       	ld	r24, Z
    2a5c:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2a60:	f0 e0       	ldi	r31, 0x00	; 0
    2a62:	e6 58       	subi	r30, 0x86	; 134
    2a64:	f8 4b       	sbci	r31, 0xB8	; 184
    2a66:	80 83       	st	Z, r24
    2a68:	80 91 06 40 	lds	r24, 0x4006	; 0x804006 <UIChanged>
    2a6c:	81 60       	ori	r24, 0x01	; 1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1037
    if (currentValueLeft[currentSettingLeft])currentValueLeft[currentSettingLeft]--;
    //hackjob to handle min exceeding max or vice versa.
    if ((currentMode == 1 || currentMode == 2) && currentSettingLeft < 6) {
      if (currentSettingLeft & 1) {
        if (currentValueLeft[currentSettingLeft] < currentValueLeft[currentSettingLeft - 1]) {
          currentValueLeft[currentSettingLeft - 1] = currentValueLeft[currentSettingLeft];
    2a6e:	80 93 06 40 	sts	0x4006, r24	; 0x804006 <UIChanged>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1041
        }
      }
    }
    UIChanged |= 1;
    2a72:	10 92 57 41 	sts	0x4157, r1	; 0x804157 <__vector_30::EncL_Val>
    2a76:	94 30       	cpi	r25, 0x04	; 4
    2a78:	0c f4       	brge	.+2      	; 0x2a7c <__vector_30+0x114>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1042
    EncL_Val = 0;
    2a7a:	72 c0       	rjmp	.+228    	; 0x2b60 <__vector_30+0x1f8>
    2a7c:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1044
  }
  if ( EncR_Val > 3 ) { //four steps forward
    2a80:	f0 e0       	ldi	r31, 0x00	; 0
    2a82:	ef 57       	subi	r30, 0x7F	; 127
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1045
    if (currentValueRight[currentSettingRight] < pgm_read_byte_near(&maxValueRight[currentMode][currentSettingRight]))currentValueRight[currentSettingRight]++;
    2a84:	f8 4b       	sbci	r31, 0xB8	; 184
    2a86:	20 81       	ld	r18, Z
    2a88:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
    2a8c:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    2a90:	38 e0       	ldi	r19, 0x08	; 8
    2a92:	83 9f       	mul	r24, r19
    2a94:	c0 01       	movw	r24, r0
    2a96:	11 24       	eor	r1, r1
    2a98:	e8 0f       	add	r30, r24
    2a9a:	f9 2f       	mov	r31, r25
    2a9c:	f1 1d       	adc	r31, r1
    2a9e:	ec 5a       	subi	r30, 0xAC	; 172
    2aa0:	f8 4f       	sbci	r31, 0xF8	; 248
    2aa2:	e4 91       	lpm	r30, Z
    2aa4:	2e 17       	cp	r18, r30
    2aa6:	40 f4       	brcc	.+16     	; 0x2ab8 <__vector_30+0x150>
    2aa8:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
    2aac:	f0 e0       	ldi	r31, 0x00	; 0
    2aae:	ef 57       	subi	r30, 0x7F	; 127
    2ab0:	f8 4b       	sbci	r31, 0xB8	; 184
    2ab2:	80 81       	ld	r24, Z
    2ab4:	8f 5f       	subi	r24, 0xFF	; 255
    2ab6:	80 83       	st	Z, r24
    2ab8:	80 91 06 40 	lds	r24, 0x4006	; 0x804006 <UIChanged>
    2abc:	81 60       	ori	r24, 0x01	; 1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1050
    UIChanged |= 1;
    EncR_Val = 0;
  }
  else if ( EncR_Val < -3 ) { //four steps backwards
    if (currentValueRight[currentSettingRight]) currentValueRight[currentSettingRight]--;
    2abe:	80 93 06 40 	sts	0x4006, r24	; 0x804006 <UIChanged>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1051
    UIChanged |= 1;
    2ac2:	10 92 56 41 	sts	0x4156, r1	; 0x804156 <__vector_30::EncR_Val>
    2ac6:	ff 91       	pop	r31
    2ac8:	ef 91       	pop	r30
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1052
    EncR_Val = 0;
    2aca:	9f 91       	pop	r25
    2acc:	8f 91       	pop	r24
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1054
  }
}
    2ace:	5f 91       	pop	r21
    2ad0:	4f 91       	pop	r20
    2ad2:	3f 91       	pop	r19
    2ad4:	2f 91       	pop	r18
    2ad6:	0f 90       	pop	r0
    2ad8:	0b be       	out	0x3b, r0	; 59
    2ada:	0f 90       	pop	r0
    2adc:	0f be       	out	0x3f, r0	; 63
    2ade:	0f 90       	pop	r0
    2ae0:	1f 90       	pop	r1
    2ae2:	18 95       	reti
    2ae4:	8d 3f       	cpi	r24, 0xFD	; 253
    2ae6:	3c f6       	brge	.-114    	; 0x2a76 <__vector_30+0x10e>
    2ae8:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1031
      }
    }
    UIChanged |= 1;
    EncL_Val = 0;
  }
  else if ( EncL_Val < -3 ) { //four steps backwards
    2aec:	f0 e0       	ldi	r31, 0x00	; 0
    2aee:	e7 58       	subi	r30, 0x87	; 135
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1032
    if (currentValueLeft[currentSettingLeft])currentValueLeft[currentSettingLeft]--;
    2af0:	f8 4b       	sbci	r31, 0xB8	; 184
    2af2:	80 81       	ld	r24, Z
    2af4:	88 23       	and	r24, r24
    2af6:	41 f0       	breq	.+16     	; 0x2b08 <__vector_30+0x1a0>
    2af8:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2afc:	f0 e0       	ldi	r31, 0x00	; 0
    2afe:	e7 58       	subi	r30, 0x87	; 135
    2b00:	f8 4b       	sbci	r31, 0xB8	; 184
    2b02:	80 81       	ld	r24, Z
    2b04:	81 50       	subi	r24, 0x01	; 1
    2b06:	80 83       	st	Z, r24
    2b08:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    2b0c:	81 50       	subi	r24, 0x01	; 1
    2b0e:	82 30       	cpi	r24, 0x02	; 2
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1034
    //hackjob to handle min exceeding max or vice versa.
    if ((currentMode == 1 || currentMode == 2) && currentSettingLeft < 6) {
    2b10:	08 f0       	brcs	.+2      	; 0x2b14 <__vector_30+0x1ac>
    2b12:	aa cf       	rjmp	.-172    	; 0x2a68 <__vector_30+0x100>
    2b14:	80 91 8b 41 	lds	r24, 0x418B	; 0x80418b <currentSettingLeft>
    2b18:	86 30       	cpi	r24, 0x06	; 6
    2b1a:	08 f0       	brcs	.+2      	; 0x2b1e <__vector_30+0x1b6>
    2b1c:	a5 cf       	rjmp	.-182    	; 0x2a68 <__vector_30+0x100>
    2b1e:	80 91 8b 41 	lds	r24, 0x418B	; 0x80418b <currentSettingLeft>
    2b22:	80 ff       	sbrs	r24, 0
    2b24:	a1 cf       	rjmp	.-190    	; 0x2a68 <__vector_30+0x100>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1035
      if (currentSettingLeft & 1) {
    2b26:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2b2a:	f0 e0       	ldi	r31, 0x00	; 0
    2b2c:	e7 58       	subi	r30, 0x87	; 135
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1036
        if (currentValueLeft[currentSettingLeft] < currentValueLeft[currentSettingLeft - 1]) {
    2b2e:	f8 4b       	sbci	r31, 0xB8	; 184
    2b30:	20 81       	ld	r18, Z
    2b32:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2b36:	e1 50       	subi	r30, 0x01	; 1
    2b38:	ff 0b       	sbc	r31, r31
    2b3a:	e7 58       	subi	r30, 0x87	; 135
    2b3c:	f8 4b       	sbci	r31, 0xB8	; 184
    2b3e:	80 81       	ld	r24, Z
    2b40:	28 17       	cp	r18, r24
    2b42:	08 f0       	brcs	.+2      	; 0x2b46 <__vector_30+0x1de>
    2b44:	91 cf       	rjmp	.-222    	; 0x2a68 <__vector_30+0x100>
    2b46:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2b4a:	f0 e0       	ldi	r31, 0x00	; 0
    2b4c:	e7 58       	subi	r30, 0x87	; 135
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1037
          currentValueLeft[currentSettingLeft - 1] = currentValueLeft[currentSettingLeft];
    2b4e:	f8 4b       	sbci	r31, 0xB8	; 184
    2b50:	80 81       	ld	r24, Z
    2b52:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    2b56:	e1 50       	subi	r30, 0x01	; 1
    2b58:	ff 0b       	sbc	r31, r31
    2b5a:	e7 58       	subi	r30, 0x87	; 135
    2b5c:	f8 4b       	sbci	r31, 0xB8	; 184
    2b5e:	83 cf       	rjmp	.-250    	; 0x2a66 <__vector_30+0xfe>
    2b60:	9d 3f       	cpi	r25, 0xFD	; 253
    2b62:	0c f0       	brlt	.+2      	; 0x2b66 <__vector_30+0x1fe>
    2b64:	b0 cf       	rjmp	.-160    	; 0x2ac6 <__vector_30+0x15e>
    2b66:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1049
  if ( EncR_Val > 3 ) { //four steps forward
    if (currentValueRight[currentSettingRight] < pgm_read_byte_near(&maxValueRight[currentMode][currentSettingRight]))currentValueRight[currentSettingRight]++;
    UIChanged |= 1;
    EncR_Val = 0;
  }
  else if ( EncR_Val < -3 ) { //four steps backwards
    2b6a:	f0 e0       	ldi	r31, 0x00	; 0
    2b6c:	ef 57       	subi	r30, 0x7F	; 127
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:1050
    if (currentValueRight[currentSettingRight]) currentValueRight[currentSettingRight]--;
    2b6e:	f8 4b       	sbci	r31, 0xB8	; 184
    2b70:	80 81       	ld	r24, Z
    2b72:	88 23       	and	r24, r24
    2b74:	09 f4       	brne	.+2      	; 0x2b78 <__vector_30+0x210>
    2b76:	a0 cf       	rjmp	.-192    	; 0x2ab8 <__vector_30+0x150>
    2b78:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
    2b7c:	f0 e0       	ldi	r31, 0x00	; 0
    2b7e:	ef 57       	subi	r30, 0x7F	; 127
    2b80:	f8 4b       	sbci	r31, 0xB8	; 184
    2b82:	80 81       	ld	r24, Z
    2b84:	81 50       	subi	r24, 0x01	; 1
    2b86:	97 cf       	rjmp	.-210    	; 0x2ab6 <__vector_30+0x14e>

00002b88 <global constructors keyed to 65535_0_DriftAnimate_V2.ino.cpp.o.3543>:
_GLOBAL__I_65535_0_DriftAnimate_V2.ino.cpp.o.3543():
    2b88:	1f 93       	push	r17
    2b8a:	cf 93       	push	r28
    2b8c:	df 93       	push	r29
    2b8e:	ef e8       	ldi	r30, 0x8F	; 143
    2b90:	f7 e4       	ldi	r31, 0x47	; 71
    2b92:	12 82       	std	Z+2, r1	; 0x02
    2b94:	13 82       	std	Z+3, r1	; 0x03
    2b96:	88 ee       	ldi	r24, 0xE8	; 232
    2b98:	93 e0       	ldi	r25, 0x03	; 3
    2b9a:	a0 e0       	ldi	r26, 0x00	; 0
    2b9c:	b0 e0       	ldi	r27, 0x00	; 0
    2b9e:	84 83       	std	Z+4, r24	; 0x04
    2ba0:	95 83       	std	Z+5, r25	; 0x05
    2ba2:	a6 83       	std	Z+6, r26	; 0x06
    2ba4:	b7 83       	std	Z+7, r27	; 0x07
    2ba6:	81 e6       	ldi	r24, 0x61	; 97
    2ba8:	90 e4       	ldi	r25, 0x40	; 64
    2baa:	80 83       	st	Z, r24
    2bac:	91 83       	std	Z+1, r25	; 0x01
    2bae:	80 e0       	ldi	r24, 0x00	; 0
    2bb0:	98 e0       	ldi	r25, 0x08	; 8
    2bb2:	84 87       	std	Z+12, r24	; 0x0c
    2bb4:	95 87       	std	Z+13, r25	; 0x0d
    2bb6:	8c ea       	ldi	r24, 0xAC	; 172
    2bb8:	97 e0       	ldi	r25, 0x07	; 7
    2bba:	86 87       	std	Z+14, r24	; 0x0e
    2bbc:	97 87       	std	Z+15, r25	; 0x0f
    2bbe:	12 e0       	ldi	r17, 0x02	; 2
    2bc0:	10 8b       	std	Z+16, r17	; 0x10
    2bc2:	11 8a       	std	Z+17, r1	; 0x11
    2bc4:	12 8a       	std	Z+18, r1	; 0x12
    2bc6:	c5 e1       	ldi	r28, 0x15	; 21
    2bc8:	de e4       	ldi	r29, 0x4E	; 78
    2bca:	1a 82       	std	Y+2, r1	; 0x02
    2bcc:	1b 82       	std	Y+3, r1	; 0x03
    2bce:	8d ec       	ldi	r24, 0xCD	; 205
    2bd0:	90 e4       	ldi	r25, 0x40	; 64
    2bd2:	88 83       	st	Y, r24
    2bd4:	99 83       	std	Y+1, r25	; 0x01
    2bd6:	1f 82       	std	Y+7, r1	; 0x07
    2bd8:	18 86       	std	Y+8, r1	; 0x08
    2bda:	80 ed       	ldi	r24, 0xD0	; 208
    2bdc:	97 e0       	ldi	r25, 0x07	; 7
    2bde:	a0 e0       	ldi	r26, 0x00	; 0
    2be0:	b0 e0       	ldi	r27, 0x00	; 0
    2be2:	88 8b       	std	Y+16, r24	; 0x10
    2be4:	99 8b       	std	Y+17, r25	; 0x11
    2be6:	aa 8b       	std	Y+18, r26	; 0x12
    2be8:	bb 8b       	std	Y+19, r27	; 0x13
    2bea:	86 e2       	ldi	r24, 0x26	; 38
    2bec:	90 e0       	ldi	r25, 0x00	; 0
    2bee:	a0 e0       	ldi	r26, 0x00	; 0
    2bf0:	b0 e0       	ldi	r27, 0x00	; 0
    2bf2:	8c 8b       	std	Y+20, r24	; 0x14
    2bf4:	9d 8b       	std	Y+21, r25	; 0x15
    2bf6:	ae 8b       	std	Y+22, r26	; 0x16
    2bf8:	bf 8b       	std	Y+23, r27	; 0x17
    2bfa:	1c 86       	std	Y+12, r1	; 0x0c
    2bfc:	1d 86       	std	Y+13, r1	; 0x0d
    2bfe:	1e 86       	std	Y+14, r1	; 0x0e
    2c00:	1f 86       	std	Y+15, r1	; 0x0f
    2c02:	1b 86       	std	Y+11, r1	; 0x0b
    2c04:	0e 94 8c 06 	call	0xd18	; 0xd18 <micros>
    2c08:	68 8f       	std	Y+24, r22	; 0x18
    2c0a:	79 8f       	std	Y+25, r23	; 0x19
    2c0c:	8a 8f       	std	Y+26, r24	; 0x1a
    2c0e:	9b 8f       	std	Y+27, r25	; 0x1b
    2c10:	1c 8e       	std	Y+28, r1	; 0x1c
    2c12:	1d 8e       	std	Y+29, r1	; 0x1d
    2c14:	1e 8e       	std	Y+30, r1	; 0x1e
    2c16:	1f 8e       	std	Y+31, r1	; 0x1f
    2c18:	83 ee       	ldi	r24, 0xE3	; 227
    2c1a:	90 e4       	ldi	r25, 0x40	; 64
    2c1c:	88 83       	st	Y, r24
    2c1e:	99 83       	std	Y+1, r25	; 0x01
    2c20:	8a e1       	ldi	r24, 0x1A	; 26
    2c22:	88 a3       	std	Y+32, r24	; 0x20
    2c24:	8d e1       	ldi	r24, 0x1D	; 29
    2c26:	8a a3       	std	Y+34, r24	; 0x22
    2c28:	8b e1       	ldi	r24, 0x1B	; 27
    2c2a:	89 a3       	std	Y+33, r24	; 0x21
    2c2c:	86 e1       	ldi	r24, 0x16	; 22
    2c2e:	8b a3       	std	Y+35, r24	; 0x23
    2c30:	87 e1       	ldi	r24, 0x17	; 23
    2c32:	8c a3       	std	Y+36, r24	; 0x24
    2c34:	88 e1       	ldi	r24, 0x18	; 24
    2c36:	8d a3       	std	Y+37, r24	; 0x25
    2c38:	89 e1       	ldi	r24, 0x19	; 25
    2c3a:	8e a3       	std	Y+38, r24	; 0x26
    2c3c:	8f ef       	ldi	r24, 0xFF	; 255
    2c3e:	8f a3       	std	Y+39, r24	; 0x27
    2c40:	88 a7       	std	Y+40, r24	; 0x28
    2c42:	e2 e0       	ldi	r30, 0x02	; 2
    2c44:	fe e4       	ldi	r31, 0x4E	; 78
    2c46:	15 82       	std	Z+5, r1	; 0x05
    2c48:	86 e2       	ldi	r24, 0x26	; 38
    2c4a:	98 e4       	ldi	r25, 0x48	; 72
    2c4c:	86 83       	std	Z+6, r24	; 0x06
    2c4e:	97 83       	std	Z+7, r25	; 0x07
    2c50:	14 86       	std	Z+12, r1	; 0x0c
    2c52:	15 86       	std	Z+13, r1	; 0x0d
    2c54:	16 86       	std	Z+14, r1	; 0x0e
    2c56:	17 86       	std	Z+15, r1	; 0x0f
    2c58:	81 e0       	ldi	r24, 0x01	; 1
    2c5a:	83 87       	std	Z+11, r24	; 0x0b
    2c5c:	80 87       	std	Z+8, r24	; 0x08
    2c5e:	11 86       	std	Z+9, r1	; 0x09
    2c60:	12 87       	std	Z+10, r17	; 0x0a
    2c62:	8c ed       	ldi	r24, 0xDC	; 220
    2c64:	95 e0       	ldi	r25, 0x05	; 5
    2c66:	82 83       	std	Z+2, r24	; 0x02
    2c68:	93 83       	std	Z+3, r25	; 0x03
    2c6a:	84 ef       	ldi	r24, 0xF4	; 244
    2c6c:	91 e0       	ldi	r25, 0x01	; 1
    2c6e:	80 83       	st	Z, r24
    2c70:	91 83       	std	Z+1, r25	; 0x01
    2c72:	86 e0       	ldi	r24, 0x06	; 6
    2c74:	84 83       	std	Z+4, r24	; 0x04
    2c76:	84 e0       	ldi	r24, 0x04	; 4
    2c78:	94 e0       	ldi	r25, 0x04	; 4
    2c7a:	80 8b       	std	Z+16, r24	; 0x10
    2c7c:	91 8b       	std	Z+17, r25	; 0x11
    2c7e:	80 e4       	ldi	r24, 0x40	; 64
    2c80:	82 8b       	std	Z+18, r24	; 0x12
    2c82:	df 91       	pop	r29
    2c84:	cf 91       	pop	r28
    2c86:	1f 91       	pop	r17
    2c88:	08 95       	ret

00002c8a <main>:
main():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:49
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
    2c8a:	cf 93       	push	r28
    2c8c:	df 93       	push	r29
    2c8e:	cd b7       	in	r28, 0x3d	; 61
    2c90:	de b7       	in	r29, 0x3e	; 62
    2c92:	62 97       	sbiw	r28, 0x12	; 18
    2c94:	cd bf       	out	0x3d, r28	; 61
    2c96:	de bf       	out	0x3e, r29	; 62
init_clock():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1213
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
    #elif (F_CPU == 28000000)
      /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
    #elif (F_CPU == 24000000)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
    2c98:	88 ed       	ldi	r24, 0xD8	; 216
    2c9a:	94 e2       	ldi	r25, 0x24	; 36
    2c9c:	84 bf       	out	0x34, r24	; 52
    2c9e:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
init_TCA0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1460
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    2ca2:	21 e0       	ldi	r18, 0x01	; 1
    2ca4:	20 93 03 0a 	sts	0x0A03, r18	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7e0a03>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1465

  //Only 1 WGM is available in split mode

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    2ca8:	8e ef       	ldi	r24, 0xFE	; 254
    2caa:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7e0a26>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1466
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    2cae:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7e0a27>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1497
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    2cb2:	9b e0       	ldi	r25, 0x0B	; 11
    2cb4:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7e0a00>
init_timers():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1446
uint8_t PeripheralControl = 0xFF;

void init_timers() {
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    2cb8:	32 e0       	ldi	r19, 0x02	; 2
    2cba:	30 93 e6 05 	sts	0x05E6, r19	; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
init_TCA1():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1515

#if defined(TCA1)
void __attribute__((weak)) init_TCA1() {

  /* Enable Split Mode */
  TCA1.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    2cbe:	20 93 43 0a 	sts	0x0A43, r18	; 0x800a43 <__TEXT_REGION_LENGTH__+0x7e0a43>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1518

  /* Period setting, 8-bit register in SPLIT mode */
  TCA1.SPLIT.LPER    = PWM_TIMER_PERIOD;
    2cc2:	80 93 66 0a 	sts	0x0A66, r24	; 0x800a66 <__TEXT_REGION_LENGTH__+0x7e0a66>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1519
  TCA1.SPLIT.HPER    = PWM_TIMER_PERIOD;
    2cc6:	80 93 67 0a 	sts	0x0A67, r24	; 0x800a67 <__TEXT_REGION_LENGTH__+0x7e0a67>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1530
    TCA1.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) //use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA1) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA1 to different divider"
    #endif
    TCA1.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    2cca:	90 93 40 0a 	sts	0x0A40, r25	; 0x800a40 <__TEXT_REGION_LENGTH__+0x7e0a40>
init_TCBs():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1552
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
    2cce:	90 93 e7 05 	sts	0x05E7, r25	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7e05e7>
main():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1571
                        | TCB4_PINS
  #endif
        ;
  // Start with TCB0 - we take advantage of the fact that we can get a pointer
  // to TCB09's struct, and increment it to go through all of them.
  TCB_t *timer_B = (TCB_t *)&TCB0;
    2cd2:	e0 e0       	ldi	r30, 0x00	; 0
    2cd4:	fb e0       	ldi	r31, 0x0B	; 11
init_TCBs():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1591
  #endif

  // Timer B Setup loop for TCB[0:end]
  do {
    // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
    timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    2cd6:	37 e0       	ldi	r19, 0x07	; 7
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1594

    // Assign 8-bit period
    timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    2cd8:	9e ef       	ldi	r25, 0xFE	; 254
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1597
    // default duty 50% - we have to set something here because of the
    // errata, otherwise CCMP will not get the CCMPL either.
    timer_B->CCMPH = PWM_TIMER_COMPARE;
    2cda:	20 e8       	ldi	r18, 0x80	; 128
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1600

    // Use TCA clock (250kHz, +/- 50%) and enable
    timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    2cdc:	85 e0       	ldi	r24, 0x05	; 5
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1591
  #endif

  // Timer B Setup loop for TCB[0:end]
  do {
    // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
    timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    2cde:	31 83       	std	Z+1, r19	; 0x01
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1594

    // Assign 8-bit period
    timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    2ce0:	94 87       	std	Z+12, r25	; 0x0c
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1597
    // default duty 50% - we have to set something here because of the
    // errata, otherwise CCMP will not get the CCMPL either.
    timer_B->CCMPH = PWM_TIMER_COMPARE;
    2ce2:	25 87       	std	Z+13, r18	; 0x0d
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1600

    // Use TCA clock (250kHz, +/- 50%) and enable
    timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    2ce4:	80 83       	st	Z, r24
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1603

    // Increment pointer to next TCB instance
    timer_B++;
    2ce6:	70 96       	adiw	r30, 0x10	; 16
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1606

    // Stop when pointing to the last timer.
  } while (timer_B <= timer_B_end);
    2ce8:	e0 34       	cpi	r30, 0x40	; 64
    2cea:	4b e0       	ldi	r20, 0x0B	; 11
    2cec:	f4 07       	cpc	r31, r20
    2cee:	b9 f7       	brne	.-18     	; 0x2cde <main+0x54>
init_TCD0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1643
 * prescaler is 1. Similarly, it cannot be enabled right after disabling it - the ENRDY bit must*
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initiialization functions assume that the chip starts from a reset condition.               */

void __attribute__((weak)) init_TCD0() {
  TCD0.CMPACLR  = 0x0FFF;
    2cf0:	4f ef       	ldi	r20, 0xFF	; 255
    2cf2:	5f e0       	ldi	r21, 0x0F	; 15
    2cf4:	40 93 aa 0b 	sts	0x0BAA, r20	; 0x800baa <__TEXT_REGION_LENGTH__+0x7e0baa>
    2cf8:	50 93 ab 0b 	sts	0x0BAB, r21	; 0x800bab <__TEXT_REGION_LENGTH__+0x7e0bab>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1647
  // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
  // it will count to - so set to maximum (other settings used for non-overlapping PWM and
  // other advanced functionality)
  TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
    2cfc:	20 93 82 0b 	sts	0x0B82, r18	; 0x800b82 <__TEXT_REGION_LENGTH__+0x7e0b82>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1649
  // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
  TCD0.CTRLB    = TCD_WGMODE_ONERAMP_gc;
    2d00:	10 92 81 0b 	sts	0x0B81, r1	; 0x800b81 <__TEXT_REGION_LENGTH__+0x7e0b81>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1654
  // One ramp or dual slope are the only options that are viable to reproduce classic behavior.
  // and the latter is incompatible with using it as millis timer, and we want to share as much
  // code as we can between the TCD0 and non-TCD0 millis. IIRC with dual slope, one value needs
  // to be inverted and the other does not.
  TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
    2d04:	4b ef       	ldi	r20, 0xFB	; 251
    2d06:	53 e0       	ldi	r21, 0x03	; 3
    2d08:	40 93 ae 0b 	sts	0x0BAE, r20	; 0x800bae <__TEXT_REGION_LENGTH__+0x7e0bae>
    2d0c:	50 93 af 0b 	sts	0x0BAF, r21	; 0x800baf <__TEXT_REGION_LENGTH__+0x7e0baf>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1664
  #if (defined(TIMERD0_SET_CLOCK) && TIMERD0_SET_CLOCK == 0x08)
    _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x05 << 2));
  #endif


  TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
    2d10:	91 e7       	ldi	r25, 0x71	; 113
    2d12:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
init_ADC0():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1105
    #elif F_CPU >= 36000000
      ADC0.CTRLC = ADC_PRESC_DIV28_gc; //1.286 @ 36 MHz
    #elif F_CPU >  28000000
      ADC0.CTRLC = ADC_PRESC_DIV24_gc; //1.33 @ 32 MHz, 1.
    #elif F_CPU >= 24000000
      ADC0.CTRLC = ADC_PRESC_DIV20_gc; //1.2 @ 24, 1.25 @ 25, 1.4 @ 28  MHz
    2d16:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x7e0602>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1117
    #elif F_CPU >= 4000000
      ADC0.CTRLC = ADC_PRESC_DIV4_gc;  //1 MHz
    #else  // 1 MHz / 2 = 500 kHz - the lowest setting
      ADC0.CTRLC = ADC_PRESC_DIV2_gc;
    #endif
    ADC0.SAMPCTRL = 14; //16 ADC clock sampling time - should be about the same amount of *time* as originally?
    2d1a:	9e e0       	ldi	r25, 0x0E	; 14
    2d1c:	90 93 05 06 	sts	0x0605, r25	; 0x800605 <__TEXT_REGION_LENGTH__+0x7e0605>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1119
    // This is WAY conservative! We could drop it down...
    ADC0.CTRLD = ADC_INITDLY_DLY64_gc; //VREF can take 50uS to become ready, and we're running the ADC clock
    2d20:	90 e6       	ldi	r25, 0x60	; 96
    2d22:	90 93 03 06 	sts	0x0603, r25	; 0x800603 <__TEXT_REGION_LENGTH__+0x7e0603>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1122
    // at around 1 MHz, so we want 64 ADC clocks when we start up a new reference so we don't get bad readings at first
    /* Enable ADC */
    ADC0.CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
    2d26:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
analogReference():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:124


void analogReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
    2d2a:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    2d2e:	88 7f       	andi	r24, 0xF8	; 248
    2d30:	85 60       	ori	r24, 0x05	; 5
    2d32:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
DACReference():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:131
}

void DACReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.DAC0REF = (VREF.DAC0REF & ~(VREF_REFSEL_gm))|(mode);
    2d36:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
    2d3a:	88 7f       	andi	r24, 0xF8	; 248
    2d3c:	85 60       	ori	r24, 0x05	; 5
    2d3e:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
init_millis():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1042
      //RTC.CLKSEL = 0; this is the power on value
    #endif
      RTC.INTCTRL = 0x01; //enable overflow interrupt
      RTC.CTRLA = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
    #else //It's a type b timer
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    2d42:	8f ed       	ldi	r24, 0xDF	; 223
    2d44:	9e e2       	ldi	r25, 0x2E	; 46
    2d46:	80 93 2c 0b 	sts	0x0B2C, r24	; 0x800b2c <__TEXT_REGION_LENGTH__+0x7e0b2c>
    2d4a:	90 93 2d 0b 	sts	0x0B2D, r25	; 0x800b2d <__TEXT_REGION_LENGTH__+0x7e0b2d>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1044
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    2d4e:	81 e0       	ldi	r24, 0x01	; 1
    2d50:	80 93 25 0b 	sts	0x0B25, r24	; 0x800b25 <__TEXT_REGION_LENGTH__+0x7e0b25>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1046
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    2d54:	10 92 21 0b 	sts	0x0B21, r1	; 0x800b21 <__TEXT_REGION_LENGTH__+0x7e0b21>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring.c:1048
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    2d58:	93 e0       	ldi	r25, 0x03	; 3
    2d5a:	90 93 20 0b 	sts	0x0B20, r25	; 0x800b20 <__TEXT_REGION_LENGTH__+0x7e0b20>
main():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/main.cpp:53
  onBeforeInit(); //Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); //Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  //enable interrupts.
    2d5e:	78 94       	sei
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    2d60:	90 e4       	ldi	r25, 0x40	; 64
    2d62:	90 93 01 04 	sts	0x0401, r25	; 0x800401 <__TEXT_REGION_LENGTH__+0x7e0401>
    2d66:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7e04a1>
    2d6a:	92 e0       	ldi	r25, 0x02	; 2
    2d6c:	90 93 a1 04 	sts	0x04A1, r25	; 0x8004a1 <__TEXT_REGION_LENGTH__+0x7e04a1>
    2d70:	20 93 01 04 	sts	0x0401, r18	; 0x800401 <__TEXT_REGION_LENGTH__+0x7e0401>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    uint8_t status = SREG;              /* Save state */
    2d74:	3f b7       	in	r19, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    2d76:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    2d78:	80 93 42 04 	sts	0x0442, r24	; 0x800442 <__TEXT_REGION_LENGTH__+0x7e0442>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    2d7c:	20 91 50 04 	lds	r18, 0x0450	; 0x800450 <__TEXT_REGION_LENGTH__+0x7e0450>
    2d80:	28 60       	ori	r18, 0x08	; 8
    2d82:	20 93 50 04 	sts	0x0450, r18	; 0x800450 <__TEXT_REGION_LENGTH__+0x7e0450>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    2d86:	80 93 45 04 	sts	0x0445, r24	; 0x800445 <__TEXT_REGION_LENGTH__+0x7e0445>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
    2d8a:	3f bf       	out	0x3f, r19	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    uint8_t status = SREG;              /* Save state */
    2d8c:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    2d8e:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    2d90:	90 93 42 04 	sts	0x0442, r25	; 0x800442 <__TEXT_REGION_LENGTH__+0x7e0442>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    2d94:	80 91 51 04 	lds	r24, 0x0451	; 0x800451 <__TEXT_REGION_LENGTH__+0x7e0451>
    2d98:	88 60       	ori	r24, 0x08	; 8
    2d9a:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <__TEXT_REGION_LENGTH__+0x7e0451>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    2d9e:	90 93 45 04 	sts	0x0445, r25	; 0x800445 <__TEXT_REGION_LENGTH__+0x7e0445>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
    2da2:	2f bf       	out	0x3f, r18	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    uint8_t status = SREG;              /* Save state */
    2da4:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    2da6:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    2da8:	90 e1       	ldi	r25, 0x10	; 16
    2daa:	90 93 22 04 	sts	0x0422, r25	; 0x800422 <__TEXT_REGION_LENGTH__+0x7e0422>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    2dae:	80 91 34 04 	lds	r24, 0x0434	; 0x800434 <__TEXT_REGION_LENGTH__+0x7e0434>
    2db2:	88 60       	ori	r24, 0x08	; 8
    2db4:	80 93 34 04 	sts	0x0434, r24	; 0x800434 <__TEXT_REGION_LENGTH__+0x7e0434>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    2db8:	90 93 25 04 	sts	0x0425, r25	; 0x800425 <__TEXT_REGION_LENGTH__+0x7e0425>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
    2dbc:	2f bf       	out	0x3f, r18	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    uint8_t status = SREG;              /* Save state */
    2dbe:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    2dc0:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    2dc2:	94 e0       	ldi	r25, 0x04	; 4
    2dc4:	90 93 42 04 	sts	0x0442, r25	; 0x800442 <__TEXT_REGION_LENGTH__+0x7e0442>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    2dc8:	80 91 52 04 	lds	r24, 0x0452	; 0x800452 <__TEXT_REGION_LENGTH__+0x7e0452>
    2dcc:	88 60       	ori	r24, 0x08	; 8
    2dce:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <__TEXT_REGION_LENGTH__+0x7e0452>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    2dd2:	90 93 45 04 	sts	0x0445, r25	; 0x800445 <__TEXT_REGION_LENGTH__+0x7e0445>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
    2dd6:	2f bf       	out	0x3f, r18	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    uint8_t status = SREG;              /* Save state */
    2dd8:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    2dda:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    2ddc:	88 e0       	ldi	r24, 0x08	; 8
    2dde:	80 93 42 04 	sts	0x0442, r24	; 0x800442 <__TEXT_REGION_LENGTH__+0x7e0442>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    2de2:	90 91 53 04 	lds	r25, 0x0453	; 0x800453 <__TEXT_REGION_LENGTH__+0x7e0453>
    2de6:	98 60       	ori	r25, 0x08	; 8
    2de8:	90 93 53 04 	sts	0x0453, r25	; 0x800453 <__TEXT_REGION_LENGTH__+0x7e0453>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    2dec:	80 93 45 04 	sts	0x0445, r24	; 0x800445 <__TEXT_REGION_LENGTH__+0x7e0445>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
    2df0:	2f bf       	out	0x3f, r18	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    uint8_t status = SREG;              /* Save state */
    2df2:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    2df4:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    2df6:	80 93 22 04 	sts	0x0422, r24	; 0x800422 <__TEXT_REGION_LENGTH__+0x7e0422>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    2dfa:	90 91 33 04 	lds	r25, 0x0433	; 0x800433 <__TEXT_REGION_LENGTH__+0x7e0433>
    2dfe:	98 60       	ori	r25, 0x08	; 8
    2e00:	90 93 33 04 	sts	0x0433, r25	; 0x800433 <__TEXT_REGION_LENGTH__+0x7e0433>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    2e04:	80 93 25 04 	sts	0x0425, r24	; 0x800425 <__TEXT_REGION_LENGTH__+0x7e0425>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
    2e08:	2f bf       	out	0x3f, r18	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:233
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    uint8_t status = SREG;              /* Save state */
    2e0a:	2f b7       	in	r18, 0x3f	; 63
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:234
    cli();                              /* Interrupts off for PINnCTRL stuff */
    2e0c:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:235
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    2e0e:	90 e2       	ldi	r25, 0x20	; 32
    2e10:	90 93 22 04 	sts	0x0422, r25	; 0x800422 <__TEXT_REGION_LENGTH__+0x7e0422>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:237
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    2e14:	80 91 35 04 	lds	r24, 0x0435	; 0x800435 <__TEXT_REGION_LENGTH__+0x7e0435>
    2e18:	88 60       	ori	r24, 0x08	; 8
    2e1a:	80 93 35 04 	sts	0x0435, r24	; 0x800435 <__TEXT_REGION_LENGTH__+0x7e0435>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:238
      port->OUTSET = bit_mask;          /* emulate setting of the port output register on classic AVR */
    2e1e:	90 93 25 04 	sts	0x0425, r25	; 0x800425 <__TEXT_REGION_LENGTH__+0x7e0425>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:243
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
      port->OUTCLR = bit_mask;          /* emulate clearing of the port output register on classic AVR */
    }
    SREG = status;                      /* Restore state */
    2e22:	2f bf       	out	0x3f, r18	; 63
setupPCINT():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:982
}

#define debugSerial Serial0

void setupPCINT() {
  if (!MVIO.STATUS) {
    2e24:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    2e28:	81 11       	cpse	r24, r1
    2e2a:	4f c0       	rjmp	.+158    	; 0x2eca <main+0x240>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:983
    uint32_t start = millis();
    2e2c:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    2e30:	4b 01       	movw	r8, r22
    2e32:	5c 01       	movw	r10, r24
analogRead():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:143
    pin = digitalPinToAnalogInput(pin);
    if(pin == NOT_A_PIN) return -1;

  }
  /* Select channel */
  ADC0.MUXPOS = ((pin & 0x7F) << ADC_MUXPOS_gp);
    2e34:	15 e4       	ldi	r17, 0x45	; 69
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:147
  /* Reference should be already set up */

  /* Start conversion */
  ADC0.COMMAND = ADC_STCONV_bm;
    2e36:	01 e0       	ldi	r16, 0x01	; 1
setupPCINT():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:984
    while ((!MVIO.STATUS) && millis() - start > 2000) {
    2e38:	80 91 c2 00 	lds	r24, 0x00C2	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    2e3c:	81 11       	cpse	r24, r1
    2e3e:	45 c0       	rjmp	.+138    	; 0x2eca <main+0x240>
    2e40:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    2e44:	68 19       	sub	r22, r8
    2e46:	79 09       	sbc	r23, r9
    2e48:	8a 09       	sbc	r24, r10
    2e4a:	9b 09       	sbc	r25, r11
    2e4c:	61 3d       	cpi	r22, 0xD1	; 209
    2e4e:	77 40       	sbci	r23, 0x07	; 7
    2e50:	81 05       	cpc	r24, r1
    2e52:	91 05       	cpc	r25, r1
    2e54:	d0 f1       	brcs	.+116    	; 0x2eca <main+0x240>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:985
      if (millis() - start > 1000) {
    2e56:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    2e5a:	68 19       	sub	r22, r8
    2e5c:	79 09       	sbc	r23, r9
    2e5e:	8a 09       	sbc	r24, r10
    2e60:	9b 09       	sbc	r25, r11
    2e62:	69 3e       	cpi	r22, 0xE9	; 233
    2e64:	73 40       	sbci	r23, 0x03	; 3
    2e66:	81 05       	cpc	r24, r1
    2e68:	91 05       	cpc	r25, r1
    2e6a:	30 f3       	brcs	.-52     	; 0x2e38 <main+0x1ae>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:986
        Serial.println("MVIO failed to initialize? No VDDIO2?");
    2e6c:	86 e0       	ldi	r24, 0x06	; 6
    2e6e:	91 e4       	ldi	r25, 0x41	; 65
    2e70:	7c d8       	rcall	.-3848   	; 0x1f6a <Print::println(char const*) [clone .constprop.25]>
analogRead():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:143
    pin = digitalPinToAnalogInput(pin);
    if(pin == NOT_A_PIN) return -1;

  }
  /* Select channel */
  ADC0.MUXPOS = ((pin & 0x7F) << ADC_MUXPOS_gp);
    2e72:	10 93 08 06 	sts	0x0608, r17	; 0x800608 <__TEXT_REGION_LENGTH__+0x7e0608>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:147
  /* Reference should be already set up */

  /* Start conversion */
  ADC0.COMMAND = ADC_STCONV_bm;
    2e76:	00 93 0a 06 	sts	0x060A, r16	; 0x80060a <__TEXT_REGION_LENGTH__+0x7e060a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:150

  /* Wait for result ready */
  while(!(ADC0.INTFLAGS & ADC_RESRDY_bm));
    2e7a:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <__TEXT_REGION_LENGTH__+0x7e060d>
    2e7e:	80 ff       	sbrs	r24, 0
    2e80:	fc cf       	rjmp	.-8      	; 0x2e7a <main+0x1f0>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_analog.c:156

  #if (defined(__AVR_DA__) && (!defined(NO_ADC_WORKAROUND)))
    // That may become defined when DA-series silicon is available with the fix
    ADC0.MUXPOS = 0x40;
  #endif
  return ADC0.RES;
    2e82:	c0 90 10 06 	lds	r12, 0x0610	; 0x800610 <__TEXT_REGION_LENGTH__+0x7e0610>
    2e86:	d0 90 11 06 	lds	r13, 0x0611	; 0x800611 <__TEXT_REGION_LENGTH__+0x7e0611>
print():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:78
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
    2e8a:	0d 2c       	mov	r0, r13
    2e8c:	00 0c       	add	r0, r0
    2e8e:	ee 08       	sbc	r14, r14
    2e90:	ff 08       	sbc	r15, r15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:96
    if (n < 0) {
      int t = print('-');
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
    2e92:	2a e0       	ldi	r18, 0x0A	; 10
    2e94:	b7 01       	movw	r22, r14
    2e96:	a6 01       	movw	r20, r12
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:91
size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
    2e98:	f7 fe       	sbrs	r15, 7
    2e9a:	0d c0       	rjmp	.+26     	; 0x2eb6 <main+0x22c>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:92
      int t = print('-');
    2e9c:	6d e2       	ldi	r22, 0x2D	; 45
    2e9e:	8f e8       	ldi	r24, 0x8F	; 143
    2ea0:	97 e4       	ldi	r25, 0x47	; 71
    2ea2:	0e 94 10 04 	call	0x820	; 0x820 <Print::print(char)>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:93
      n = -n;
    2ea6:	44 27       	eor	r20, r20
    2ea8:	55 27       	eor	r21, r21
    2eaa:	ba 01       	movw	r22, r20
    2eac:	4c 19       	sub	r20, r12
    2eae:	5d 09       	sbc	r21, r13
    2eb0:	6e 09       	sbc	r22, r14
    2eb2:	7f 09       	sbc	r23, r15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:94
      return printNumber(n, 10) + t;
    2eb4:	2a e0       	ldi	r18, 0x0A	; 10
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:96
    }
    return printNumber(n, 10);
    2eb6:	8f e8       	ldi	r24, 0x8F	; 143
    2eb8:	97 e4       	ldi	r25, 0x47	; 71
    2eba:	12 d8       	rcall	.-4060   	; 0x1ee0 <Print::printNumber(unsigned long, unsigned char)>
write():
    2ebc:	65 ef       	ldi	r22, 0xF5	; 245
    2ebe:	70 e4       	ldi	r23, 0x40	; 64
    2ec0:	8f e8       	ldi	r24, 0x8F	; 143
    2ec2:	97 e4       	ldi	r25, 0x47	; 71
    2ec4:	0e 94 61 0f 	call	0x1ec2	; 0x1ec2 <Print::write(char const*) [clone .part.2]>
    2ec8:	b7 cf       	rjmp	.-146    	; 0x2e38 <main+0x1ae>
setupPCINT():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:991
        Serial.println(analogRead(ADC_VDDIO2DIV10));
      }
    }
  }
  VPORTC.INTFLAGS = VPORTC.INTFLAGS;
    2eca:	8b b1       	in	r24, 0x0b	; 11
    2ecc:	8b b9       	out	0x0b, r24	; 11
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:992
  PORTC.PIN0CTRL = PORT_PULLUPEN_bm | PORT_ISC_BOTHEDGES_gc;
    2ece:	89 e0       	ldi	r24, 0x09	; 9
    2ed0:	80 93 50 04 	sts	0x0450, r24	; 0x800450 <__TEXT_REGION_LENGTH__+0x7e0450>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:993
  PORTC.PIN1CTRL = PORT_PULLUPEN_bm | PORT_ISC_BOTHEDGES_gc;
    2ed4:	80 93 51 04 	sts	0x0451, r24	; 0x800451 <__TEXT_REGION_LENGTH__+0x7e0451>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:994
  PORTC.PIN2CTRL = PORT_PULLUPEN_bm | PORT_ISC_BOTHEDGES_gc;
    2ed8:	80 93 52 04 	sts	0x0452, r24	; 0x800452 <__TEXT_REGION_LENGTH__+0x7e0452>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:995
  PORTC.PIN3CTRL = PORT_PULLUPEN_bm | PORT_ISC_BOTHEDGES_gc;
    2edc:	80 93 53 04 	sts	0x0453, r24	; 0x800453 <__TEXT_REGION_LENGTH__+0x7e0453>
swap():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:166
  uint8_t ret_val = _pins_to_swap(_usart_pins, _mux_count, tx, rx);   // return 127 when correct swap number wasn't found
  return swap(ret_val);
}

bool UartClass::swap(uint8_t newmux) {
  if (_state < _mux_count) {
    2ee0:	90 91 a1 47 	lds	r25, 0x47A1	; 0x8047a1 <Serial0+0x12>
    2ee4:	80 91 9f 47 	lds	r24, 0x479F	; 0x80479f <Serial0+0x10>
    2ee8:	98 17       	cp	r25, r24
    2eea:	08 f0       	brcs	.+2      	; 0x2eee <main+0x264>
    2eec:	83 c1       	rjmp	.+774    	; 0x31f4 <main+0x56a>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:167
    _pin_set = newmux;
    2eee:	81 e0       	ldi	r24, 0x01	; 1
    2ef0:	80 93 a0 47 	sts	0x47A0, r24	; 0x8047a0 <Serial0+0x11>
setup():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:223
  //_PROTECTED_WRITE(CLKCTRL_OSCHFTUNE,CLKCTRL_OSCHFTUNE);
  setupPins();
  setupPCINT();
  //setupRF();
  Serial.swap(1);
  Serial.begin(115200);
    2ef4:	40 e0       	ldi	r20, 0x00	; 0
    2ef6:	52 ec       	ldi	r21, 0xC2	; 194
    2ef8:	61 e0       	ldi	r22, 0x01	; 1
    2efa:	70 e0       	ldi	r23, 0x00	; 0
    2efc:	8f e8       	ldi	r24, 0x8F	; 143
    2efe:	97 e4       	ldi	r25, 0x47	; 71
    2f00:	0e 94 10 09 	call	0x1220	; 0x1220 <UartClass::begin(unsigned long)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:224
  Serial.println("Hi, I started!");
    2f04:	8c e2       	ldi	r24, 0x2C	; 44
    2f06:	91 e4       	ldi	r25, 0x41	; 65
    2f08:	30 d8       	rcall	.-4000   	; 0x1f6a <Print::println(char const*) [clone .constprop.25]>
begin():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:198
	 * - 40x4 is dual 40x2 displays using dual E signals which is not suppo
	 *
	 * users can override this at any time by calling setRowOffsets(r0,r1,r2,r3)
	 */

	if((!_rowOffsets[0] && !_rowOffsets[1] && !_rowOffsets[2] && !_rowOffsets[3])
    2f0a:	80 91 21 4e 	lds	r24, 0x4E21	; 0x804e21 <lcd+0xc>
    2f0e:	81 11       	cpse	r24, r1
    2f10:	0c c0       	rjmp	.+24     	; 0x2f2a <main+0x2a0>
    2f12:	80 91 22 4e 	lds	r24, 0x4E22	; 0x804e22 <lcd+0xd>
    2f16:	81 11       	cpse	r24, r1
    2f18:	08 c0       	rjmp	.+16     	; 0x2f2a <main+0x2a0>
    2f1a:	80 91 23 4e 	lds	r24, 0x4E23	; 0x804e23 <lcd+0xe>
    2f1e:	81 11       	cpse	r24, r1
    2f20:	04 c0       	rjmp	.+8      	; 0x2f2a <main+0x2a0>
    2f22:	80 91 24 4e 	lds	r24, 0x4E24	; 0x804e24 <lcd+0xf>
    2f26:	88 23       	and	r24, r24
    2f28:	21 f0       	breq	.+8      	; 0x2f32 <main+0x2a8>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:199
	 || (_cols && (_cols != cols)))
    2f2a:	80 91 1c 4e 	lds	r24, 0x4E1C	; 0x804e1c <lcd+0x7>
    2f2e:	8f 7e       	andi	r24, 0xEF	; 239
    2f30:	59 f0       	breq	.+22     	; 0x2f48 <main+0x2be>
setRowOffsets():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:564
// See here for further explanation of lcd memory addressing:
// http://web.alfredstate.edu/weimandn/lcd/lcd_addressing/lcd_addressing_index.html

int hd44780::setRowOffsets(int row0, int row1, int row2, int row3)
{
	_rowOffsets[0] = row0;
    2f32:	10 92 21 4e 	sts	0x4E21, r1	; 0x804e21 <lcd+0xc>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:565
	_rowOffsets[1] = row1;
    2f36:	80 e4       	ldi	r24, 0x40	; 64
    2f38:	80 93 22 4e 	sts	0x4E22, r24	; 0x804e22 <lcd+0xd>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:566
	_rowOffsets[2] = row2;
    2f3c:	80 e1       	ldi	r24, 0x10	; 16
    2f3e:	80 93 23 4e 	sts	0x4E23, r24	; 0x804e23 <lcd+0xe>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:567
	_rowOffsets[3] = row3;
    2f42:	80 e5       	ldi	r24, 0x50	; 80
    2f44:	80 93 24 4e 	sts	0x4E24, r24	; 0x804e24 <lcd+0xf>
begin():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:208


	/*
	 * Save rows/cols
	 */
	_rows = rows;
    2f48:	82 e0       	ldi	r24, 0x02	; 2
    2f4a:	80 93 1d 4e 	sts	0x4E1D, r24	; 0x804e1d <lcd+0x8>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:209
	_cols = cols;
    2f4e:	80 e1       	ldi	r24, 0x10	; 16
    2f50:	80 93 1c 4e 	sts	0x4E1C, r24	; 0x804e1c <lcd+0x7>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:218
	 * according to datasheet,we need at least 40ms after power rises above 2.7V
	 * before sending commands.The Arduino AVR can turn on and start running way
	 * before 4.5V so we'll wait 100ms to add some additional margin
	 */

	delay(100); 
    2f54:	64 e6       	ldi	r22, 0x64	; 100
    2f56:	70 e0       	ldi	r23, 0x00	; 0
    2f58:	80 e0       	ldi	r24, 0x00	; 0
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	0e 94 d1 06 	call	0xda2	; 0xda2 <delay>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:221
  
	// default to 4 bit mode (can be overridded by i/o class library)
	_displayfunction = HD44780_4BITMODE;
    2f60:	10 92 19 4e 	sts	0x4E19, r1	; 0x804e19 <lcd+0x4>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:224

	// call h/w i/o class init function
	if((rval = ioinit())) // intentional assignment
    2f64:	85 e1       	ldi	r24, 0x15	; 21
    2f66:	9e e4       	ldi	r25, 0x4E	; 78
    2f68:	0e 94 19 0c 	call	0x1832	; 0x1832 <hd44780_pinIO::ioinit()>
    2f6c:	89 2b       	or	r24, r25
    2f6e:	09 f0       	breq	.+2      	; 0x2f72 <main+0x2e8>
    2f70:	49 c0       	rjmp	.+146    	; 0x3004 <main+0x37a>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:229
	{
		return(rval);
	}

	if (_rows > 1)
    2f72:	80 91 1d 4e 	lds	r24, 0x4E1D	; 0x804e1d <lcd+0x8>
    2f76:	82 30       	cpi	r24, 0x02	; 2
    2f78:	28 f0       	brcs	.+10     	; 0x2f84 <main+0x2fa>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:231
	{
		_displayfunction |= HD44780_2LINE;
    2f7a:	80 91 19 4e 	lds	r24, 0x4E19	; 0x804e19 <lcd+0x4>
    2f7e:	88 60       	ori	r24, 0x08	; 8
    2f80:	80 93 19 4e 	sts	0x4E19, r24	; 0x804e19 <lcd+0x4>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:484
	 * like yield() to potentially allow other code to execute during this time period.
	 *
	 * delay() can be used because this code is never called from a constructor
	 *
	 */
	command4bit(HD44780_FUNCTIONSET|HD44780_8BITMODE);
    2f84:	80 e3       	ldi	r24, 0x30	; 48
    2f86:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <hd44780::command4bit(unsigned char) [clone .constprop.15]>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:485
	delay(5); // wait 5ms vs 4.1ms, some are slower than spec
    2f8a:	65 e0       	ldi	r22, 0x05	; 5
    2f8c:	70 e0       	ldi	r23, 0x00	; 0
    2f8e:	80 e0       	ldi	r24, 0x00	; 0
    2f90:	90 e0       	ldi	r25, 0x00	; 0
    2f92:	0e 94 d1 06 	call	0xda2	; 0xda2 <delay>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:487

	command4bit(HD44780_FUNCTIONSET|HD44780_8BITMODE);
    2f96:	80 e3       	ldi	r24, 0x30	; 48
    2f98:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <hd44780::command4bit(unsigned char) [clone .constprop.15]>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:488
	delay(1); // wait 1ms vs 100us
    2f9c:	61 e0       	ldi	r22, 0x01	; 1
    2f9e:	70 e0       	ldi	r23, 0x00	; 0
    2fa0:	80 e0       	ldi	r24, 0x00	; 0
    2fa2:	90 e0       	ldi	r25, 0x00	; 0
    2fa4:	0e 94 d1 06 	call	0xda2	; 0xda2 <delay>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:490
    
	command4bit(HD44780_FUNCTIONSET|HD44780_8BITMODE);
    2fa8:	80 e3       	ldi	r24, 0x30	; 48
    2faa:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <hd44780::command4bit(unsigned char) [clone .constprop.15]>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:491
	delay(1); // wait 1ms vs 100us
    2fae:	61 e0       	ldi	r22, 0x01	; 1
    2fb0:	70 e0       	ldi	r23, 0x00	; 0
    2fb2:	80 e0       	ldi	r24, 0x00	; 0
    2fb4:	90 e0       	ldi	r25, 0x00	; 0
    2fb6:	0e 94 d1 06 	call	0xda2	; 0xda2 <delay>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:504
	 * isn't in 4 bit mode yet.
	 * Note: there is no need for a delay *after* command4bit() since
	 * it uses markStart(_insExecTime) to indicate the instruction time
	 * and will be honored by waitReady() used in the i/o class.
	 */
	if(!(_displayfunction & HD44780_8BITMODE))
    2fba:	80 91 19 4e 	lds	r24, 0x4E19	; 0x804e19 <lcd+0x4>
    2fbe:	84 fd       	sbrc	r24, 4
    2fc0:	03 c0       	rjmp	.+6      	; 0x2fc8 <main+0x33e>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:505
		command4bit(HD44780_FUNCTIONSET|HD44780_4BITMODE);
    2fc2:	80 e2       	ldi	r24, 0x20	; 32
    2fc4:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <hd44780::command4bit(unsigned char) [clone .constprop.15]>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:514
	 * and in 4 bit mode for 4bit only host interfaces so we can 
	 * now use the "normal" library command() & API interface functions
	 */

	// set # lines, font size, etc.
	command(HD44780_FUNCTIONSET | _displayfunction);  
    2fc8:	60 91 19 4e 	lds	r22, 0x4E19	; 0x804e19 <lcd+0x4>
    2fcc:	60 62       	ori	r22, 0x20	; 32
    2fce:	85 e1       	ldi	r24, 0x15	; 21
    2fd0:	9e e4       	ldi	r25, 0x4E	; 78
    2fd2:	0e 94 0d 07 	call	0xe1a	; 0xe1a <hd44780::command(unsigned char)>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:518


	// turn the display on with no cursor or blinking default
	_displaycontrol = HD44780_DISPLAYON | HD44780_CURSOROFF | HD44780_BLINKOFF;  
    2fd6:	84 e0       	ldi	r24, 0x04	; 4
    2fd8:	80 93 1a 4e 	sts	0x4E1A, r24	; 0x804e1a <lcd+0x5>
display():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:639

// turn on display pixels
int hd44780::display()
{
	_displaycontrol |= HD44780_DISPLAYON;
	return(command(HD44780_DISPLAYCONTROL | _displaycontrol));
    2fdc:	6c e0       	ldi	r22, 0x0C	; 12
    2fde:	85 e1       	ldi	r24, 0x15	; 21
    2fe0:	9e e4       	ldi	r25, 0x4E	; 78
    2fe2:	0e 94 0d 07 	call	0xe1a	; 0xe1a <hd44780::command(unsigned char)>
begin():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:521

	// turn the display on with no cursor or blinking default
	_displaycontrol = HD44780_DISPLAYON | HD44780_CURSOROFF | HD44780_BLINKOFF;  
	display();

	clear(); // clear display
    2fe6:	0e 94 44 07 	call	0xe88	; 0xe88 <hd44780::clear() [clone .constprop.24]>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:524

	// Initialize to default text direction (for romance languages)
	_displaymode = HD44780_ENTRYLEFT2RIGHT;
    2fea:	82 e0       	ldi	r24, 0x02	; 2
    2fec:	80 93 1b 4e 	sts	0x4E1B, r24	; 0x804e1b <lcd+0x6>
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:526
	// set the entry mode
	rval = command(HD44780_ENTRYMODESET | _displaymode);
    2ff0:	66 e0       	ldi	r22, 0x06	; 6
    2ff2:	85 e1       	ldi	r24, 0x15	; 21
    2ff4:	9e e4       	ldi	r25, 0x4E	; 78
    2ff6:	0e 94 0d 07 	call	0xe1a	; 0xe1a <hd44780::command(unsigned char)>
backlight():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.cpp:788
#endif

// turn on backlight at full intensity
int hd44780::backlight(void)
{
	return(iosetBacklight(-1)); // max brightness
    2ffa:	6f ef       	ldi	r22, 0xFF	; 255
    2ffc:	85 e1       	ldi	r24, 0x15	; 21
    2ffe:	9e e4       	ldi	r25, 0x4E	; 78
    3000:	0e 94 6f 0e 	call	0x1cde	; 0x1cde <hd44780_pinIO::iosetBacklight(unsigned char)>
setup():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:226
  lcd.begin(16, 2);
  lcd.print(F("Woah I'm on a DB!"));
    3004:	62 eb       	ldi	r22, 0xB2	; 178
    3006:	74 e0       	ldi	r23, 0x04	; 4
    3008:	85 e1       	ldi	r24, 0x15	; 21
    300a:	9e e4       	ldi	r25, 0x4E	; 78
    300c:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:227
  lcd.setCursor(0, 1);
    3010:	41 e0       	ldi	r20, 0x01	; 1
    3012:	60 e0       	ldi	r22, 0x00	; 0
    3014:	85 e1       	ldi	r24, 0x15	; 21
    3016:	9e e4       	ldi	r25, 0x4E	; 78
    3018:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:228
  lcd.print(F("Nothing works!"));
    301c:	63 ea       	ldi	r22, 0xA3	; 163
    301e:	74 e0       	ldi	r23, 0x04	; 4
    3020:	85 e1       	ldi	r24, 0x15	; 21
    3022:	9e e4       	ldi	r25, 0x4E	; 78
    3024:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:229
  digitalWrite(LCD_BL_R, HIGH);
    3028:	61 e0       	ldi	r22, 0x01	; 1
    302a:	88 e0       	ldi	r24, 0x08	; 8
    302c:	0e 94 35 09 	call	0x126a	; 0x126a <digitalWrite>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:230
  digitalWrite(LCD_BL_G, HIGH);
    3030:	61 e0       	ldi	r22, 0x01	; 1
    3032:	89 e0       	ldi	r24, 0x09	; 9
    3034:	0e 94 35 09 	call	0x126a	; 0x126a <digitalWrite>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:231
  digitalWrite(LCD_BL_B, HIGH);
    3038:	61 e0       	ldi	r22, 0x01	; 1
    303a:	8a e0       	ldi	r24, 0x0A	; 10
    303c:	0e 94 35 09 	call	0x126a	; 0x126a <digitalWrite>
_pinMode():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:228
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
  //if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    3040:	80 e4       	ldi	r24, 0x40	; 64
    3042:	80 93 61 04 	sts	0x0461, r24	; 0x800461 <__TEXT_REGION_LENGTH__+0x7e0461>
setup():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:233
  pinMode(PIN_PD6,OUTPUT);
  digitalWrite(PIN_PD6,HIGH);
    3046:	61 e0       	ldi	r22, 0x01	; 1
    3048:	8c e1       	ldi	r24, 0x1C	; 28
    304a:	0e 94 35 09 	call	0x126a	; 0x126a <digitalWrite>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:234
  delay(2000);
    304e:	60 ed       	ldi	r22, 0xD0	; 208
    3050:	77 e0       	ldi	r23, 0x07	; 7
    3052:	80 e0       	ldi	r24, 0x00	; 0
    3054:	90 e0       	ldi	r25, 0x00	; 0
    3056:	0e 94 d1 06 	call	0xda2	; 0xda2 <delay>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:235
  lcd.clear();
    305a:	0e 94 44 07 	call	0xe88	; 0xe88 <hd44780::clear() [clone .constprop.24]>
loadMode():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:386
  currentSettingLeft = 0;
  currentSettingRight = 0;
}

void loadMode() {
  Serial.println("LoadMode Called");
    305e:	8b e3       	ldi	r24, 0x3B	; 59
    3060:	91 e4       	ldi	r25, 0x41	; 65
    3062:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <Print::println(char const*) [clone .constprop.25]>
_ZNK5EERefdeEv():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:47
  EERef(const uint8_t index)
    : index(index)                 {}

  // Access/read members.
  uint8_t operator*() const            {
    return (*(uint8_t *)((uint16_t)(MAPPED_EEPROM_START + (index & EEPROM_INDEX_MASK))));
    3066:	10 91 0f 14 	lds	r17, 0x140F	; 0x80140f <__TEXT_REGION_LENGTH__+0x7e140f>
loadMode():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:387
  if (EEPROM.read(0x0F) != 255) {
    306a:	1f 3f       	cpi	r17, 0xFF	; 255
    306c:	79 f1       	breq	.+94     	; 0x30cc <main+0x442>
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:459

  return 1;
}

void UartClass::printHex(const uint8_t b) {
  char x = (b >> 4) | '0';
    306e:	61 2f       	mov	r22, r17
    3070:	62 95       	swap	r22
    3072:	6f 70       	andi	r22, 0x0F	; 15
    3074:	60 63       	ori	r22, 0x30	; 48
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:460
  if (x > '9')
    3076:	6a 33       	cpi	r22, 0x3A	; 58
    3078:	0c f0       	brlt	.+2      	; 0x307c <main+0x3f2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:461
    x += 7;
    307a:	69 5f       	subi	r22, 0xF9	; 249
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.h:128
    virtual void flush(void);
    virtual size_t write(uint8_t b);
    inline size_t write(unsigned long n) {return write((uint8_t)n);}
    inline size_t write(long n)          {return write((uint8_t)n);}
    inline size_t write(unsigned int n)  {return write((uint8_t)n);}
    inline size_t write(int n)           {return write((uint8_t)n);}
    307c:	8f e8       	ldi	r24, 0x8F	; 143
    307e:	97 e4       	ldi	r25, 0x47	; 71
    3080:	0e 94 2a 06 	call	0xc54	; 0xc54 <UartClass::write(unsigned char)>
printHex():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:463
  write(x);
  x = (b & 0x0F) | '0';
    3084:	61 2f       	mov	r22, r17
    3086:	6f 70       	andi	r22, 0x0F	; 15
    3088:	60 63       	ori	r22, 0x30	; 48
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:464
  if (x > '9')
    308a:	6a 33       	cpi	r22, 0x3A	; 58
    308c:	08 f0       	brcs	.+2      	; 0x3090 <main+0x406>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:465
    x += 7;
    308e:	69 5f       	subi	r22, 0xF9	; 249
write():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.h:128
    3090:	8f e8       	ldi	r24, 0x8F	; 143
    3092:	97 e4       	ldi	r25, 0x47	; 71
    3094:	0e 94 2a 06 	call	0xc54	; 0xc54 <UartClass::write(unsigned char)>
_ZNK5EERefdeEv():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:47
    3098:	80 91 0f 14 	lds	r24, 0x140F	; 0x80140f <__TEXT_REGION_LENGTH__+0x7e140f>
loadMode():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:389
    Serial.printHex(EEPROM.read(0x0F));
    currentMode = EEPROM.read(0x0F);
    309c:	80 93 89 47 	sts	0x4789, r24	; 0x804789 <currentMode>
    30a0:	90 e0       	ldi	r25, 0x00	; 0
    30a2:	80 e0       	ldi	r24, 0x00	; 0
_ZNK5EERefdeEv():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:47
    30a4:	fc 01       	movw	r30, r24
    30a6:	e0 5f       	subi	r30, 0xF0	; 240
    30a8:	fb 4e       	sbci	r31, 0xEB	; 235
    30aa:	20 81       	ld	r18, Z
loadMode():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:391
    for (byte i = 0; i < 8; i++) {
      currentValueLeft[i] = EEPROM.read(0x10 + i);
    30ac:	fc 01       	movw	r30, r24
    30ae:	e7 58       	subi	r30, 0x87	; 135
    30b0:	f8 4b       	sbci	r31, 0xB8	; 184
    30b2:	20 83       	st	Z, r18
_ZNK5EERefdeEv():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:47
    30b4:	fc 01       	movw	r30, r24
    30b6:	e8 5e       	subi	r30, 0xE8	; 232
    30b8:	fb 4e       	sbci	r31, 0xEB	; 235
    30ba:	20 81       	ld	r18, Z
loadMode():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:392
      currentValueRight[i] = EEPROM.read(0x18 + i);
    30bc:	fc 01       	movw	r30, r24
    30be:	ef 57       	subi	r30, 0x7F	; 127
    30c0:	f8 4b       	sbci	r31, 0xB8	; 184
    30c2:	20 83       	st	Z, r18
    30c4:	01 96       	adiw	r24, 0x01	; 1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:390
void loadMode() {
  Serial.println("LoadMode Called");
  if (EEPROM.read(0x0F) != 255) {
    Serial.printHex(EEPROM.read(0x0F));
    currentMode = EEPROM.read(0x0F);
    for (byte i = 0; i < 8; i++) {
    30c6:	88 30       	cpi	r24, 0x08	; 8
    30c8:	91 05       	cpc	r25, r1
    30ca:	61 f7       	brne	.-40     	; 0x30a4 <main+0x41a>
map():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Common.cpp:6
#include "Common.h"

/* C++ prototypes */
long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
    30cc:	21 2c       	mov	r2, r1
    30ce:	31 2c       	mov	r3, r1
    30d0:	21 01       	movw	r4, r2
    30d2:	2a 94       	dec	r2
handleUI():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:402
void handleUI() {
  static byte lastBtnState = 7;
  static byte lastBtnBounceState = 7;
  static unsigned long lastBtnAt = 0;
  static unsigned long lastPressAt = 0;
  byte btnRead = BTN_PORT_READ();
    30d4:	06 b1       	in	r16, 0x06	; 6
    30d6:	10 e0       	ldi	r17, 0x00	; 0
    30d8:	53 e0       	ldi	r21, 0x03	; 3
    30da:	15 95       	asr	r17
    30dc:	07 95       	ror	r16
    30de:	5a 95       	dec	r21
    30e0:	e1 f7       	brne	.-8      	; 0x30da <main+0x450>
    30e2:	f0 2f       	mov	r31, r16
    30e4:	f7 70       	andi	r31, 0x07	; 7
    30e6:	ff 2e       	mov	r15, r31
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:403
  if (!(btnRead == lastBtnBounceState)) { //debounce all buttons at once.
    30e8:	80 91 04 40 	lds	r24, 0x4004	; 0x804004 <handleUI()::lastBtnBounceState>
    30ec:	f8 17       	cp	r31, r24
    30ee:	09 f4       	brne	.+2      	; 0x30f2 <main+0x468>
    30f0:	84 c0       	rjmp	.+264    	; 0x31fa <main+0x570>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:404
    lastBtnBounceState = btnRead;
    30f2:	f0 93 04 40 	sts	0x4004, r31	; 0x804004 <handleUI()::lastBtnBounceState>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:405
    lastBtnAt = millis();
    30f6:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    30fa:	60 93 86 41 	sts	0x4186, r22	; 0x804186 <handleUI()::lastBtnAt>
    30fe:	70 93 87 41 	sts	0x4187, r23	; 0x804187 <handleUI()::lastBtnAt+0x1>
    3102:	80 93 88 41 	sts	0x4188, r24	; 0x804188 <handleUI()::lastBtnAt+0x2>
    3106:	90 93 89 41 	sts	0x4189, r25	; 0x804189 <handleUI()::lastBtnAt+0x3>
handleLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:473
void handleLCD() {
  static byte drift2_colors = 255;
  static unsigned long lastInputAt;
  static byte attractmode = 0;
  byte uichg = 0;
  if (millis() - lastRFUpdateAt < 5000 && lastRFUpdateAt) {
    310a:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    310e:	00 91 91 41 	lds	r16, 0x4191	; 0x804191 <lastRFUpdateAt>
    3112:	10 91 92 41 	lds	r17, 0x4192	; 0x804192 <lastRFUpdateAt+0x1>
    3116:	20 91 93 41 	lds	r18, 0x4193	; 0x804193 <lastRFUpdateAt+0x2>
    311a:	30 91 94 41 	lds	r19, 0x4194	; 0x804194 <lastRFUpdateAt+0x3>
    311e:	60 1b       	sub	r22, r16
    3120:	71 0b       	sbc	r23, r17
    3122:	82 0b       	sbc	r24, r18
    3124:	93 0b       	sbc	r25, r19
    3126:	68 38       	cpi	r22, 0x88	; 136
    3128:	73 41       	sbci	r23, 0x13	; 19
    312a:	81 05       	cpc	r24, r1
    312c:	91 05       	cpc	r25, r1
    312e:	68 f4       	brcc	.+26     	; 0x314a <main+0x4c0>
    3130:	80 91 91 41 	lds	r24, 0x4191	; 0x804191 <lastRFUpdateAt>
    3134:	90 91 92 41 	lds	r25, 0x4192	; 0x804192 <lastRFUpdateAt+0x1>
    3138:	a0 91 93 41 	lds	r26, 0x4193	; 0x804193 <lastRFUpdateAt+0x2>
    313c:	b0 91 94 41 	lds	r27, 0x4194	; 0x804194 <lastRFUpdateAt+0x3>
    3140:	89 2b       	or	r24, r25
    3142:	8a 2b       	or	r24, r26
    3144:	8b 2b       	or	r24, r27
    3146:	09 f0       	breq	.+2      	; 0x314a <main+0x4c0>
    3148:	53 c1       	rjmp	.+678    	; 0x33f0 <main+0x766>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:476
    return;
  }
  cli();
    314a:	f8 94       	cli
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:477
  uichg = UIChanged;
    314c:	10 91 06 40 	lds	r17, 0x4006	; 0x804006 <UIChanged>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:478
  UIChanged = 0;
    3150:	10 92 06 40 	sts	0x4006, r1	; 0x804006 <UIChanged>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:479
  sei();
    3154:	78 94       	sei
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:480
  if (uichg == 0) {
    3156:	11 11       	cpse	r17, r1
    3158:	cc c1       	rjmp	.+920    	; 0x34f2 <main+0x868>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:481
    if (millis() - lastInputAt > 60000) {
    315a:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    315e:	c0 90 8d 41 	lds	r12, 0x418D	; 0x80418d <handleLCD()::lastInputAt>
    3162:	d0 90 8e 41 	lds	r13, 0x418E	; 0x80418e <handleLCD()::lastInputAt+0x1>
    3166:	e0 90 8f 41 	lds	r14, 0x418F	; 0x80418f <handleLCD()::lastInputAt+0x2>
    316a:	f0 90 90 41 	lds	r15, 0x4190	; 0x804190 <handleLCD()::lastInputAt+0x3>
    316e:	6c 19       	sub	r22, r12
    3170:	7d 09       	sbc	r23, r13
    3172:	8e 09       	sbc	r24, r14
    3174:	9f 09       	sbc	r25, r15
    3176:	61 36       	cpi	r22, 0x61	; 97
    3178:	7a 4e       	sbci	r23, 0xEA	; 234
    317a:	81 05       	cpc	r24, r1
    317c:	91 05       	cpc	r25, r1
    317e:	08 f4       	brcc	.+2      	; 0x3182 <main+0x4f8>
    3180:	37 c1       	rjmp	.+622    	; 0x33f0 <main+0x766>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:482
      if (!attractmode || (millis() - lastInputAt > 120000)) {
    3182:	80 91 8c 41 	lds	r24, 0x418C	; 0x80418c <handleLCD()::attractmode>
    3186:	81 11       	cpse	r24, r1
    3188:	27 c1       	rjmp	.+590    	; 0x33d8 <main+0x74e>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:483
        attractmode = 1;
    318a:	81 e0       	ldi	r24, 0x01	; 1
    318c:	80 93 8c 41 	sts	0x418C, r24	; 0x80418c <handleLCD()::attractmode>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:484
        lastInputAt = millis() - 60000;
    3190:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    3194:	60 56       	subi	r22, 0x60	; 96
    3196:	7a 4e       	sbci	r23, 0xEA	; 234
    3198:	81 09       	sbc	r24, r1
    319a:	91 09       	sbc	r25, r1
    319c:	60 93 8d 41 	sts	0x418D, r22	; 0x80418d <handleLCD()::lastInputAt>
    31a0:	70 93 8e 41 	sts	0x418E, r23	; 0x80418e <handleLCD()::lastInputAt+0x1>
    31a4:	80 93 8f 41 	sts	0x418F, r24	; 0x80418f <handleLCD()::lastInputAt+0x2>
    31a8:	90 93 90 41 	sts	0x4190, r25	; 0x804190 <handleLCD()::lastInputAt+0x3>
doAttractLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:555
    }
  }
  attractmode = 0;
}
void doAttractLCD() {
  lcd.clear();
    31ac:	0e 94 44 07 	call	0xe88	; 0xe88 <hd44780::clear() [clone .constprop.24]>
random():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:40
    31b0:	e8 d7       	rcall	.+4048   	; 0x4182 <random>
    31b2:	23 e0       	ldi	r18, 0x03	; 3
    31b4:	30 e0       	ldi	r19, 0x00	; 0
    31b6:	40 e0       	ldi	r20, 0x00	; 0
    31b8:	50 e0       	ldi	r21, 0x00	; 0
    31ba:	0e 94 16 21 	call	0x422c	; 0x422c <__divmodsi4>
doAttractLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:557
  byte s = random(0, 3);
  if (!s) {
    31be:	61 11       	cpse	r22, r1
    31c0:	54 c1       	rjmp	.+680    	; 0x346a <main+0x7e0>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:558
    lcd.setCursor(0, 0);
    31c2:	40 e0       	ldi	r20, 0x00	; 0
    31c4:	60 e0       	ldi	r22, 0x00	; 0
    31c6:	85 e1       	ldi	r24, 0x15	; 21
    31c8:	9e e4       	ldi	r25, 0x4E	; 78
    31ca:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:559
    lcd.print(F("Light Test v2.1"));
    31ce:	65 e4       	ldi	r22, 0x45	; 69
    31d0:	75 e0       	ldi	r23, 0x05	; 5
    31d2:	85 e1       	ldi	r24, 0x15	; 21
    31d4:	9e e4       	ldi	r25, 0x4E	; 78
    31d6:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:560
    lcd.setCursor(0, 1);
    31da:	41 e0       	ldi	r20, 0x01	; 1
    31dc:	60 e0       	ldi	r22, 0x00	; 0
    31de:	85 e1       	ldi	r24, 0x15	; 21
    31e0:	9e e4       	ldi	r25, 0x4E	; 78
    31e2:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:561
    lcd.print(F("AVR128DB48"));
    31e6:	6a e3       	ldi	r22, 0x3A	; 58
    31e8:	75 e0       	ldi	r23, 0x05	; 5
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:574
    lcd.setCursor(2, 0);
    lcd.print(F("PLAY WITH ME"));
    lcd.setCursor(0, 1);
    byte r = random(0, 2);
    if (r == 0) {
      lcd.print(F("USE KNOBS&BUTTON"));
    31ea:	85 e1       	ldi	r24, 0x15	; 21
    31ec:	9e e4       	ldi	r25, 0x4E	; 78
    31ee:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
    31f2:	fe c0       	rjmp	.+508    	; 0x33f0 <main+0x766>
swap():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/UART.cpp:173
    return true;
  } else if (newmux == MUX_NONE) {  //128 codes for MUX_NONE
    _pin_set = _mux_count;
    return true;
  } else {
    _pin_set = 0;
    31f4:	10 92 a0 47 	sts	0x47A0, r1	; 0x8047a0 <Serial0+0x11>
    31f8:	7d ce       	rjmp	.-774    	; 0x2ef4 <main+0x26a>
handleUI():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:407
  byte btnRead = BTN_PORT_READ();
  if (!(btnRead == lastBtnBounceState)) { //debounce all buttons at once.
    lastBtnBounceState = btnRead;
    lastBtnAt = millis();
  } else {
    if (millis() - lastBtnAt > 50) { //has been stable for 50ms
    31fa:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    31fe:	80 90 86 41 	lds	r8, 0x4186	; 0x804186 <handleUI()::lastBtnAt>
    3202:	90 90 87 41 	lds	r9, 0x4187	; 0x804187 <handleUI()::lastBtnAt+0x1>
    3206:	a0 90 88 41 	lds	r10, 0x4188	; 0x804188 <handleUI()::lastBtnAt+0x2>
    320a:	b0 90 89 41 	lds	r11, 0x4189	; 0x804189 <handleUI()::lastBtnAt+0x3>
    320e:	68 19       	sub	r22, r8
    3210:	79 09       	sbc	r23, r9
    3212:	8a 09       	sbc	r24, r10
    3214:	9b 09       	sbc	r25, r11
    3216:	63 33       	cpi	r22, 0x33	; 51
    3218:	71 05       	cpc	r23, r1
    321a:	81 05       	cpc	r24, r1
    321c:	91 05       	cpc	r25, r1
    321e:	08 f4       	brcc	.+2      	; 0x3222 <main+0x598>
    3220:	74 cf       	rjmp	.-280    	; 0x310a <main+0x480>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:408
      if (btnRead < lastBtnState ) {
    3222:	80 91 03 40 	lds	r24, 0x4003	; 0x804003 <handleUI()::lastBtnState>
    3226:	f8 16       	cp	r15, r24
    3228:	d8 f4       	brcc	.+54     	; 0x3260 <main+0x5d6>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:409
        if (!lastPressAt && !(btnRead & 1)) {
    322a:	80 91 82 41 	lds	r24, 0x4182	; 0x804182 <handleUI()::lastPressAt>
    322e:	90 91 83 41 	lds	r25, 0x4183	; 0x804183 <handleUI()::lastPressAt+0x1>
    3232:	a0 91 84 41 	lds	r26, 0x4184	; 0x804184 <handleUI()::lastPressAt+0x2>
    3236:	b0 91 85 41 	lds	r27, 0x4185	; 0x804185 <handleUI()::lastPressAt+0x3>
    323a:	89 2b       	or	r24, r25
    323c:	8a 2b       	or	r24, r26
    323e:	8b 2b       	or	r24, r27
    3240:	61 f4       	brne	.+24     	; 0x325a <main+0x5d0>
    3242:	00 fd       	sbrc	r16, 0
    3244:	0a c0       	rjmp	.+20     	; 0x325a <main+0x5d0>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:410
          lastPressAt = millis();
    3246:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    324a:	60 93 82 41 	sts	0x4182, r22	; 0x804182 <handleUI()::lastPressAt>
    324e:	70 93 83 41 	sts	0x4183, r23	; 0x804183 <handleUI()::lastPressAt+0x1>
    3252:	80 93 84 41 	sts	0x4184, r24	; 0x804184 <handleUI()::lastPressAt+0x2>
    3256:	90 93 85 41 	sts	0x4185, r25	; 0x804185 <handleUI()::lastPressAt+0x3>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:455
            currentSettingRight++;
          }
          UIChanged |= 2;
        }
      }
      lastBtnState = btnRead;
    325a:	f0 92 03 40 	sts	0x4003, r15	; 0x804003 <handleUI()::lastBtnState>
    325e:	55 cf       	rjmp	.-342    	; 0x310a <main+0x480>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:414
        if (!lastPressAt && !(btnRead & 1)) {
          lastPressAt = millis();
        }
        //do nothing - was button being pressed
      } else {
        if (((btnRead & MODE_BTN_bm)) && !(lastBtnState & MODE_BTN_bm)) {
    3260:	02 ff       	sbrs	r16, 2
    3262:	72 c0       	rjmp	.+228    	; 0x3348 <main+0x6be>
    3264:	82 fd       	sbrc	r24, 2
    3266:	70 c0       	rjmp	.+224    	; 0x3348 <main+0x6be>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:415
          if (lastPressAt && millis() - lastPressAt > 10000) {
    3268:	80 90 82 41 	lds	r8, 0x4182	; 0x804182 <handleUI()::lastPressAt>
    326c:	90 90 83 41 	lds	r9, 0x4183	; 0x804183 <handleUI()::lastPressAt+0x1>
    3270:	a0 90 84 41 	lds	r10, 0x4184	; 0x804184 <handleUI()::lastPressAt+0x2>
    3274:	b0 90 85 41 	lds	r11, 0x4185	; 0x804185 <handleUI()::lastPressAt+0x3>
    3278:	81 14       	cp	r8, r1
    327a:	91 04       	cpc	r9, r1
    327c:	a1 04       	cpc	r10, r1
    327e:	b1 04       	cpc	r11, r1
    3280:	09 f4       	brne	.+2      	; 0x3284 <main+0x5fa>
    3282:	4e c0       	rjmp	.+156    	; 0x3320 <main+0x696>
    3284:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    3288:	68 19       	sub	r22, r8
    328a:	79 09       	sbc	r23, r9
    328c:	8a 09       	sbc	r24, r10
    328e:	9b 09       	sbc	r25, r11
    3290:	61 31       	cpi	r22, 0x11	; 17
    3292:	77 42       	sbci	r23, 0x27	; 39
    3294:	81 05       	cpc	r24, r1
    3296:	91 05       	cpc	r25, r1
    3298:	08 f4       	brcc	.+2      	; 0x329c <main+0x612>
    329a:	ec c6       	rjmp	.+3544   	; 0x4074 <nextbyte24+0x4e>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:417

            lcd.clear();
    329c:	0e 94 44 07 	call	0xe88	; 0xe88 <hd44780::clear() [clone .constprop.24]>
main():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:373
  }

}

void clearMode() {
  for (byte i = 0x0F; i < 0x20; i++) {
    32a0:	4f e0       	ldi	r20, 0x0F	; 15
    32a2:	e4 2e       	mov	r14, r20
_ZN5EERefC2Eh():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:43
 */

struct EERef {

  EERef(const uint8_t index)
    : index(index)                 {}
    32a4:	e8 86       	std	Y+8, r14	; 0x08
_ZN11EEPROMClass5writeEhh.isra.5():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:221
  }
  uint8_t read(uint8_t idx)              {
    return EERef(idx);
  }
  void write(uint8_t idx, uint8_t val)   {
    (EERef(idx)) = val;
    32a6:	6f ef       	ldi	r22, 0xFF	; 255
    32a8:	ce 01       	movw	r24, r28
    32aa:	08 96       	adiw	r24, 0x08	; 8
    32ac:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <EERef::operator=(unsigned char)>
clearMode():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:373
    32b0:	e3 94       	inc	r14
    32b2:	30 e2       	ldi	r19, 0x20	; 32
    32b4:	e3 12       	cpse	r14, r19
    32b6:	f6 cf       	rjmp	.-20     	; 0x32a4 <main+0x61a>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:376
    EEPROM.write(i, 255);
  }
  currentMode = 0;
    32b8:	10 92 89 47 	sts	0x4789, r1	; 0x804789 <currentMode>
    32bc:	90 e0       	ldi	r25, 0x00	; 0
    32be:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:378
  for (byte i = 0; i < 8; i++) {
    currentValueLeft[i] = 0;
    32c0:	fc 01       	movw	r30, r24
    32c2:	e7 58       	subi	r30, 0x87	; 135
    32c4:	f8 4b       	sbci	r31, 0xB8	; 184
    32c6:	10 82       	st	Z, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:379
    currentValueRight[i] = 0;
    32c8:	fc 01       	movw	r30, r24
    32ca:	ef 57       	subi	r30, 0x7F	; 127
    32cc:	f8 4b       	sbci	r31, 0xB8	; 184
    32ce:	10 82       	st	Z, r1
    32d0:	01 96       	adiw	r24, 0x01	; 1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:377
void clearMode() {
  for (byte i = 0x0F; i < 0x20; i++) {
    EEPROM.write(i, 255);
  }
  currentMode = 0;
  for (byte i = 0; i < 8; i++) {
    32d2:	88 30       	cpi	r24, 0x08	; 8
    32d4:	91 05       	cpc	r25, r1
    32d6:	a1 f7       	brne	.-24     	; 0x32c0 <main+0x636>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:381
    currentValueLeft[i] = 0;
    currentValueRight[i] = 0;
  }
  currentSettingLeft = 0;
    32d8:	10 92 8b 41 	sts	0x418B, r1	; 0x80418b <currentSettingLeft>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:382
  currentSettingRight = 0;
    32dc:	10 92 8a 41 	sts	0x418A, r1	; 0x80418a <currentSettingRight>
handleUI():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:419
        if (((btnRead & MODE_BTN_bm)) && !(lastBtnState & MODE_BTN_bm)) {
          if (lastPressAt && millis() - lastPressAt > 10000) {

            lcd.clear();
            clearMode();
            lcd.setCursor(3, 0);
    32e0:	40 e0       	ldi	r20, 0x00	; 0
    32e2:	63 e0       	ldi	r22, 0x03	; 3
    32e4:	85 e1       	ldi	r24, 0x15	; 21
    32e6:	9e e4       	ldi	r25, 0x4E	; 78
    32e8:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:420
            lcd.print(F("Saved mode"));
    32ec:	67 ed       	ldi	r22, 0xD7	; 215
    32ee:	74 e0       	ldi	r23, 0x04	; 4
    32f0:	85 e1       	ldi	r24, 0x15	; 21
    32f2:	9e e4       	ldi	r25, 0x4E	; 78
    32f4:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:421
            lcd.setCursor(5, 1);
    32f8:	41 e0       	ldi	r20, 0x01	; 1
    32fa:	65 e0       	ldi	r22, 0x05	; 5
    32fc:	85 e1       	ldi	r24, 0x15	; 21
    32fe:	9e e4       	ldi	r25, 0x4E	; 78
    3300:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:422
            lcd.print(F("cleared"));
    3304:	6f ec       	ldi	r22, 0xCF	; 207
    3306:	74 e0       	ldi	r23, 0x04	; 4
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:429
            UIChanged = 7;
          } else if (lastPressAt && millis() - lastPressAt > 3000) {
            saveMode();
            lcd.clear();
            lcd.setCursor(3, 0);
            lcd.print(F("Mode Saved"));
    3308:	85 e1       	ldi	r24, 0x15	; 21
    330a:	9e e4       	ldi	r25, 0x4E	; 78
    330c:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:430
            delay(1000);
    3310:	68 ee       	ldi	r22, 0xE8	; 232
    3312:	73 e0       	ldi	r23, 0x03	; 3
    3314:	80 e0       	ldi	r24, 0x00	; 0
    3316:	90 e0       	ldi	r25, 0x00	; 0
    3318:	0e 94 d1 06 	call	0xda2	; 0xda2 <delay>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:431
            UIChanged = 7;
    331c:	87 e0       	ldi	r24, 0x07	; 7
    331e:	0a c0       	rjmp	.+20     	; 0x3334 <main+0x6aa>
advanceMode():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:308
  }
}


void advanceMode() {
  if (currentMode >= maxMode) {
    3320:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    3324:	8a 30       	cpi	r24, 0x0A	; 10
    3326:	08 f4       	brcc	.+2      	; 0x332a <main+0x6a0>
    3328:	42 c0       	rjmp	.+132    	; 0x33ae <main+0x724>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:312
    setMode(0);
  } else {
    if (currentMode == 1) currentMode++;
    setMode(currentMode + 1);
    332a:	80 e0       	ldi	r24, 0x00	; 0
    332c:	28 d9       	rcall	.-3504   	; 0x257e <setMode(unsigned char)>
handleUI():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:434
            lcd.print(F("Mode Saved"));
            delay(1000);
            UIChanged = 7;
          } else {
            advanceMode();
            UIChanged |= 4;
    332e:	80 91 06 40 	lds	r24, 0x4006	; 0x804006 <UIChanged>
    3332:	84 60       	ori	r24, 0x04	; 4
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:431
            saveMode();
            lcd.clear();
            lcd.setCursor(3, 0);
            lcd.print(F("Mode Saved"));
            delay(1000);
            UIChanged = 7;
    3334:	80 93 06 40 	sts	0x4006, r24	; 0x804006 <UIChanged>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:436
          } else {
            advanceMode();
            UIChanged |= 4;
          }
          lastPressAt = 0;
    3338:	10 92 82 41 	sts	0x4182, r1	; 0x804182 <handleUI()::lastPressAt>
    333c:	10 92 83 41 	sts	0x4183, r1	; 0x804183 <handleUI()::lastPressAt+0x1>
    3340:	10 92 84 41 	sts	0x4184, r1	; 0x804184 <handleUI()::lastPressAt+0x2>
    3344:	10 92 85 41 	sts	0x4185, r1	; 0x804185 <handleUI()::lastPressAt+0x3>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:438
        }
        if (((btnRead & ENC1_BTN_bm)) && !(lastBtnState & ENC1_BTN_bm)) {
    3348:	01 ff       	sbrs	r16, 1
    334a:	17 c0       	rjmp	.+46     	; 0x337a <main+0x6f0>
    334c:	80 91 03 40 	lds	r24, 0x4003	; 0x804003 <handleUI()::lastBtnState>
    3350:	81 fd       	sbrc	r24, 1
    3352:	13 c0       	rjmp	.+38     	; 0x337a <main+0x6f0>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:439
          if (currentSettingLeft >= pgm_read_byte_near(&maxSetting[currentMode][0])) {
    3354:	e0 91 89 47 	lds	r30, 0x4789	; 0x804789 <currentMode>
    3358:	f0 e0       	ldi	r31, 0x00	; 0
    335a:	ee 0f       	add	r30, r30
    335c:	ff 1f       	adc	r31, r31
    335e:	e8 58       	subi	r30, 0x88	; 136
    3360:	fa 4f       	sbci	r31, 0xFA	; 250
    3362:	e4 91       	lpm	r30, Z
    3364:	80 91 8b 41 	lds	r24, 0x418B	; 0x80418b <currentSettingLeft>
    3368:	8e 17       	cp	r24, r30
    336a:	50 f1       	brcs	.+84     	; 0x33c0 <main+0x736>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:440
            currentSettingLeft = 0;
    336c:	10 92 8b 41 	sts	0x418B, r1	; 0x80418b <currentSettingLeft>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:444
          } else {
            currentSettingLeft++;
          }
          UIChanged |= 2;
    3370:	80 91 06 40 	lds	r24, 0x4006	; 0x804006 <UIChanged>
    3374:	82 60       	ori	r24, 0x02	; 2
    3376:	80 93 06 40 	sts	0x4006, r24	; 0x804006 <UIChanged>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:446
        }
        if (((btnRead & ENC2_BTN_bm)) && !(lastBtnState & ENC2_BTN_bm)) {
    337a:	00 ff       	sbrs	r16, 0
    337c:	6e cf       	rjmp	.-292    	; 0x325a <main+0x5d0>
    337e:	80 91 03 40 	lds	r24, 0x4003	; 0x804003 <handleUI()::lastBtnState>
    3382:	80 fd       	sbrc	r24, 0
    3384:	6a cf       	rjmp	.-300    	; 0x325a <main+0x5d0>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:447
          if (currentSettingRight >= pgm_read_byte_near(&maxSetting[currentMode][1])) {
    3386:	e0 91 89 47 	lds	r30, 0x4789	; 0x804789 <currentMode>
    338a:	f0 e0       	ldi	r31, 0x00	; 0
    338c:	ee 0f       	add	r30, r30
    338e:	ff 1f       	adc	r31, r31
    3390:	e7 58       	subi	r30, 0x87	; 135
    3392:	fa 4f       	sbci	r31, 0xFA	; 250
    3394:	e4 91       	lpm	r30, Z
    3396:	80 91 8a 41 	lds	r24, 0x418A	; 0x80418a <currentSettingRight>
    339a:	8e 17       	cp	r24, r30
    339c:	b8 f0       	brcs	.+46     	; 0x33cc <main+0x742>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:448
            currentSettingRight = 0;
    339e:	10 92 8a 41 	sts	0x418A, r1	; 0x80418a <currentSettingRight>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:452
          } else {
            currentSettingRight++;
          }
          UIChanged |= 2;
    33a2:	80 91 06 40 	lds	r24, 0x4006	; 0x804006 <UIChanged>
    33a6:	82 60       	ori	r24, 0x02	; 2
    33a8:	80 93 06 40 	sts	0x4006, r24	; 0x804006 <UIChanged>
    33ac:	56 cf       	rjmp	.-340    	; 0x325a <main+0x5d0>
advanceMode():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:311

void advanceMode() {
  if (currentMode >= maxMode) {
    setMode(0);
  } else {
    if (currentMode == 1) currentMode++;
    33ae:	81 30       	cpi	r24, 0x01	; 1
    33b0:	19 f4       	brne	.+6      	; 0x33b8 <main+0x72e>
    33b2:	82 e0       	ldi	r24, 0x02	; 2
    33b4:	80 93 89 47 	sts	0x4789, r24	; 0x804789 <currentMode>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:312
    setMode(currentMode + 1);
    33b8:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    33bc:	8f 5f       	subi	r24, 0xFF	; 255
    33be:	b6 cf       	rjmp	.-148    	; 0x332c <main+0x6a2>
handleUI():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:442
        }
        if (((btnRead & ENC1_BTN_bm)) && !(lastBtnState & ENC1_BTN_bm)) {
          if (currentSettingLeft >= pgm_read_byte_near(&maxSetting[currentMode][0])) {
            currentSettingLeft = 0;
          } else {
            currentSettingLeft++;
    33c0:	80 91 8b 41 	lds	r24, 0x418B	; 0x80418b <currentSettingLeft>
    33c4:	8f 5f       	subi	r24, 0xFF	; 255
    33c6:	80 93 8b 41 	sts	0x418B, r24	; 0x80418b <currentSettingLeft>
    33ca:	d2 cf       	rjmp	.-92     	; 0x3370 <main+0x6e6>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:450
        }
        if (((btnRead & ENC2_BTN_bm)) && !(lastBtnState & ENC2_BTN_bm)) {
          if (currentSettingRight >= pgm_read_byte_near(&maxSetting[currentMode][1])) {
            currentSettingRight = 0;
          } else {
            currentSettingRight++;
    33cc:	80 91 8a 41 	lds	r24, 0x418A	; 0x80418a <currentSettingRight>
    33d0:	8f 5f       	subi	r24, 0xFF	; 255
    33d2:	80 93 8a 41 	sts	0x418A, r24	; 0x80418a <currentSettingRight>
    33d6:	e5 cf       	rjmp	.-54     	; 0x33a2 <main+0x718>
handleLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:482
  uichg = UIChanged;
  UIChanged = 0;
  sei();
  if (uichg == 0) {
    if (millis() - lastInputAt > 60000) {
      if (!attractmode || (millis() - lastInputAt > 120000)) {
    33d8:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    33dc:	6c 19       	sub	r22, r12
    33de:	7d 09       	sbc	r23, r13
    33e0:	8e 09       	sbc	r24, r14
    33e2:	9f 09       	sbc	r25, r15
    33e4:	61 3c       	cpi	r22, 0xC1	; 193
    33e6:	74 4d       	sbci	r23, 0xD4	; 212
    33e8:	81 40       	sbci	r24, 0x01	; 1
    33ea:	91 05       	cpc	r25, r1
    33ec:	08 f0       	brcs	.+2      	; 0x33f0 <main+0x766>
    33ee:	cd ce       	rjmp	.-614    	; 0x318a <main+0x500>
loop():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:253
  }
  */
  //digitalWriteFast(INDICATE2, CHANGE);
  handleUI();
  handleLCD();
  if (!updated) {
    33f0:	10 91 8e 47 	lds	r17, 0x478E	; 0x80478e <loop::updated>
    33f4:	00 91 89 47 	lds	r16, 0x4789	; 0x804789 <currentMode>
    33f8:	11 11       	cpse	r17, r1
    33fa:	87 c5       	rjmp	.+2830   	; 0x3f0a <main+0x1280>
digitalWriteFast():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:444
  if (val == LOW)
    vport->OUT &= ~mask;
  else if (val == CHANGE)
    vport->IN |= mask;
  else // HIGH
    vport->OUT |= mask;
    33fc:	a9 9a       	sbi	0x15, 1	; 21
updatePattern():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:584
    }
  }
}

void updatePattern() {
  if (currentMode == 0) {
    33fe:	01 11       	cpse	r16, r1
    3400:	b9 c1       	rjmp	.+882    	; 0x3774 <main+0xaea>
    3402:	06 e2       	ldi	r16, 0x26	; 38
    3404:	18 e4       	ldi	r17, 0x48	; 72
main():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:585
    for (unsigned int i = 0; i < LENGTH * 3; i++) {
    3406:	d1 2c       	mov	r13, r1
    3408:	c1 2c       	mov	r12, r1
updatePattern():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:586
      pixels[i] = getLeftVal(currentValueLeft[i % 3]);
    340a:	53 e0       	ldi	r21, 0x03	; 3
    340c:	e5 2e       	mov	r14, r21
    340e:	f1 2c       	mov	r15, r1
    3410:	c6 01       	movw	r24, r12
    3412:	b7 01       	movw	r22, r14
    3414:	0e 94 9c 23 	call	0x4738	; 0x4738 <__udivmodhi4>
    3418:	fc 01       	movw	r30, r24
    341a:	e7 58       	subi	r30, 0x87	; 135
    341c:	f8 4b       	sbci	r31, 0xB8	; 184
    341e:	80 81       	ld	r24, Z
    3420:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3424:	f8 01       	movw	r30, r16
    3426:	81 93       	st	Z+, r24
    3428:	8f 01       	movw	r16, r30
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:585
  }
}

void updatePattern() {
  if (currentMode == 0) {
    for (unsigned int i = 0; i < LENGTH * 3; i++) {
    342a:	ff ef       	ldi	r31, 0xFF	; 255
    342c:	cf 1a       	sub	r12, r31
    342e:	df 0a       	sbc	r13, r31
    3430:	2c ed       	ldi	r18, 0xDC	; 220
    3432:	c2 16       	cp	r12, r18
    3434:	25 e0       	ldi	r18, 0x05	; 5
    3436:	d2 06       	cpc	r13, r18
    3438:	59 f7       	brne	.-42     	; 0x3410 <main+0x786>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:612
  } else if (currentMode == 10) {
    updatePatternDrift2();
  } else {
    setMode(0);
  }
  frameNumber++;
    343a:	80 91 75 47 	lds	r24, 0x4775	; 0x804775 <frameNumber>
    343e:	90 91 76 47 	lds	r25, 0x4776	; 0x804776 <frameNumber+0x1>
    3442:	a0 91 77 47 	lds	r26, 0x4777	; 0x804777 <frameNumber+0x2>
    3446:	b0 91 78 47 	lds	r27, 0x4778	; 0x804778 <frameNumber+0x3>
    344a:	01 96       	adiw	r24, 0x01	; 1
    344c:	a1 1d       	adc	r26, r1
    344e:	b1 1d       	adc	r27, r1
    3450:	80 93 75 47 	sts	0x4775, r24	; 0x804775 <frameNumber>
    3454:	90 93 76 47 	sts	0x4776, r25	; 0x804776 <frameNumber+0x1>
    3458:	a0 93 77 47 	sts	0x4777, r26	; 0x804777 <frameNumber+0x2>
    345c:	b0 93 78 47 	sts	0x4778, r27	; 0x804778 <frameNumber+0x3>
digitalWriteFast():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:440
    vport->OUT &= ~mask;
  else // CHANGE
    vport->IN = mask;
*/
  if (val == LOW)
    vport->OUT &= ~mask;
    3460:	a9 98       	cbi	0x15, 1	; 21
loop():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:257
  handleLCD();
  if (!updated) {
    digitalWriteFast(INDICATE1,HIGH);
    updatePattern();
    digitalWriteFast(INDICATE1,LOW);
    updated = 1;
    3462:	81 e0       	ldi	r24, 0x01	; 1
    3464:	80 93 8e 47 	sts	0x478E, r24	; 0x80478e <loop::updated>
    3468:	35 ce       	rjmp	.-918    	; 0x30d4 <main+0x44a>
doAttractLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:563
    lcd.setCursor(0, 0);
    lcd.print(F("Light Test v2.1"));
    lcd.setCursor(0, 1);
    lcd.print(F("AVR128DB48"));
  } else if (s == 1) {
    lcd.setCursor(0, 0);
    346a:	40 e0       	ldi	r20, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:562
  if (!s) {
    lcd.setCursor(0, 0);
    lcd.print(F("Light Test v2.1"));
    lcd.setCursor(0, 1);
    lcd.print(F("AVR128DB48"));
  } else if (s == 1) {
    346c:	61 30       	cpi	r22, 0x01	; 1
    346e:	e9 f4       	brne	.+58     	; 0x34aa <main+0x820>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:563
    lcd.setCursor(0, 0);
    3470:	60 e0       	ldi	r22, 0x00	; 0
    3472:	85 e1       	ldi	r24, 0x15	; 21
    3474:	9e e4       	ldi	r25, 0x4E	; 78
    3476:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:564
    lcd.print(F("This is not a"));
    347a:	6c e2       	ldi	r22, 0x2C	; 44
    347c:	75 e0       	ldi	r23, 0x05	; 5
    347e:	85 e1       	ldi	r24, 0x15	; 21
    3480:	9e e4       	ldi	r25, 0x4E	; 78
    3482:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:565
    lcd.setCursor(0, 1);
    3486:	41 e0       	ldi	r20, 0x01	; 1
    3488:	60 e0       	ldi	r22, 0x00	; 0
    348a:	85 e1       	ldi	r24, 0x15	; 21
    348c:	9e e4       	ldi	r25, 0x4E	; 78
    348e:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:566
    lcd.print(F("real party"));
    3492:	61 e2       	ldi	r22, 0x21	; 33
    3494:	75 e0       	ldi	r23, 0x05	; 5
    3496:	85 e1       	ldi	r24, 0x15	; 21
    3498:	9e e4       	ldi	r25, 0x4E	; 78
    349a:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
write():
C:\Users\Spence\Documents\Arduino\libraries\hd44780/hd44780.h:199
	size_t write(uint8_t value);	// does char & line processing
	size_t _write(uint8_t value);	// does not do char & line processing
// write() overloads for 0 or null which is an int
// This is only because Print class doesn't do it.
	inline size_t write(unsigned int value) { return(write((uint8_t)value)); }
	inline size_t write(int value) { return(write((uint8_t)value)); }
    349e:	6f e7       	ldi	r22, 0x7F	; 127
    34a0:	85 e1       	ldi	r24, 0x15	; 21
    34a2:	9e e4       	ldi	r25, 0x4E	; 78
    34a4:	0e 94 6e 07 	call	0xedc	; 0xedc <hd44780::write(unsigned char)>
    34a8:	a3 cf       	rjmp	.-186    	; 0x33f0 <main+0x766>
doAttractLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:569
    lcd.write(0x7F);
  } else {
    lcd.setCursor(2, 0);
    34aa:	62 e0       	ldi	r22, 0x02	; 2
    34ac:	85 e1       	ldi	r24, 0x15	; 21
    34ae:	9e e4       	ldi	r25, 0x4E	; 78
    34b0:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:570
    lcd.print(F("PLAY WITH ME"));
    34b4:	64 e1       	ldi	r22, 0x14	; 20
    34b6:	75 e0       	ldi	r23, 0x05	; 5
    34b8:	85 e1       	ldi	r24, 0x15	; 21
    34ba:	9e e4       	ldi	r25, 0x4E	; 78
    34bc:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:571
    lcd.setCursor(0, 1);
    34c0:	41 e0       	ldi	r20, 0x01	; 1
    34c2:	60 e0       	ldi	r22, 0x00	; 0
    34c4:	85 e1       	ldi	r24, 0x15	; 21
    34c6:	9e e4       	ldi	r25, 0x4E	; 78
    34c8:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
random():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:40
    34cc:	5a d6       	rcall	.+3252   	; 0x4182 <random>
    34ce:	22 e0       	ldi	r18, 0x02	; 2
    34d0:	30 e0       	ldi	r19, 0x00	; 0
    34d2:	40 e0       	ldi	r20, 0x00	; 0
    34d4:	50 e0       	ldi	r21, 0x00	; 0
    34d6:	aa d6       	rcall	.+3412   	; 0x422c <__divmodsi4>
doAttractLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:573
    byte r = random(0, 2);
    if (r == 0) {
    34d8:	61 11       	cpse	r22, r1
    34da:	03 c0       	rjmp	.+6      	; 0x34e2 <main+0x858>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:574
      lcd.print(F("USE KNOBS&BUTTON"));
    34dc:	63 e0       	ldi	r22, 0x03	; 3
    34de:	75 e0       	ldi	r23, 0x05	; 5
    34e0:	84 ce       	rjmp	.-760    	; 0x31ea <main+0x560>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:575
    } else if (r == 1) {
    34e2:	61 30       	cpi	r22, 0x01	; 1
    34e4:	19 f4       	brne	.+6      	; 0x34ec <main+0x862>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:576
      lcd.print(F("TURN MY KNOBS ;)"));
    34e6:	62 ef       	ldi	r22, 0xF2	; 242
    34e8:	74 e0       	ldi	r23, 0x04	; 4
    34ea:	7f ce       	rjmp	.-770    	; 0x31ea <main+0x560>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:578
    } else {
      lcd.print(F("ADJUST LIGHTING"));
    34ec:	62 ee       	ldi	r22, 0xE2	; 226
    34ee:	74 e0       	ldi	r23, 0x04	; 4
    34f0:	7c ce       	rjmp	.-776    	; 0x31ea <main+0x560>
handleLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:490
        doAttractLCD();
      }
    }
    return;
  }
  if (attractmode) {
    34f2:	80 91 8c 41 	lds	r24, 0x418C	; 0x80418c <handleLCD()::attractmode>
    34f6:	81 11       	cpse	r24, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:491
    lcd.clear();
    34f8:	0e 94 44 07 	call	0xe88	; 0xe88 <hd44780::clear() [clone .constprop.24]>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:493
  }
  if (uichg & 1 && currentMode == 10) {
    34fc:	10 ff       	sbrs	r17, 0
    34fe:	0d c0       	rjmp	.+26     	; 0x351a <main+0x890>
    3500:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    3504:	8a 30       	cpi	r24, 0x0A	; 10
    3506:	49 f4       	brne	.+18     	; 0x351a <main+0x890>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:494
    if (getPalleteNumber() != drift2_colors) {
    3508:	0e 94 c0 07 	call	0xf80	; 0xf80 <getPalleteNumber()>
    350c:	90 91 05 40 	lds	r25, 0x4005	; 0x804005 <handleLCD()::drift2_colors>
    3510:	89 13       	cpse	r24, r25
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:495
      initColorsDrift2();
    3512:	0e 94 0d 0f 	call	0x1e1a	; 0x1e1a <initColorsDrift2()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:497
    }
    initLookupDrift2();
    3516:	0e 94 59 12 	call	0x24b2	; 0x24b2 <initLookupDrift2()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:499
  }
  if (currentMode == 10) {
    351a:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    351e:	8a 30       	cpi	r24, 0x0A	; 10
    3520:	51 f4       	brne	.+20     	; 0x3536 <main+0x8ac>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:500
    if (getPalleteNumber() != drift2_colors) {
    3522:	0e 94 c0 07 	call	0xf80	; 0xf80 <getPalleteNumber()>
    3526:	90 91 05 40 	lds	r25, 0x4005	; 0x804005 <handleLCD()::drift2_colors>
    352a:	89 17       	cp	r24, r25
    352c:	21 f0       	breq	.+8      	; 0x3536 <main+0x8ac>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:501
      drift2_colors = getPalleteNumber();
    352e:	0e 94 c0 07 	call	0xf80	; 0xf80 <getPalleteNumber()>
    3532:	80 93 05 40 	sts	0x4005, r24	; 0x804005 <handleLCD()::drift2_colors>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:504
    }
  }
  lastInputAt = millis();
    3536:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
    353a:	60 93 8d 41 	sts	0x418D, r22	; 0x80418d <handleLCD()::lastInputAt>
    353e:	70 93 8e 41 	sts	0x418E, r23	; 0x80418e <handleLCD()::lastInputAt+0x1>
    3542:	80 93 8f 41 	sts	0x418F, r24	; 0x80418f <handleLCD()::lastInputAt+0x2>
    3546:	90 93 90 41 	sts	0x4190, r25	; 0x804190 <handleLCD()::lastInputAt+0x3>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:505
  if ((uichg & 6) || attractmode ) { //if setting or mode has changed, redraw settings
    354a:	81 2f       	mov	r24, r17
    354c:	86 70       	andi	r24, 0x06	; 6
    354e:	29 f4       	brne	.+10     	; 0x355a <main+0x8d0>
    3550:	80 91 8c 41 	lds	r24, 0x418C	; 0x80418c <handleLCD()::attractmode>
    3554:	88 23       	and	r24, r24
    3556:	09 f4       	brne	.+2      	; 0x355a <main+0x8d0>
    3558:	38 c0       	rjmp	.+112    	; 0x35ca <main+0x940>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:506
    lcd.setCursor(0, 0);
    355a:	40 e0       	ldi	r20, 0x00	; 0
    355c:	60 e0       	ldi	r22, 0x00	; 0
    355e:	85 e1       	ldi	r24, 0x15	; 21
    3560:	9e e4       	ldi	r25, 0x4E	; 78
    3562:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:507
    if (currentMode < 7 ) {
    3566:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    356a:	87 30       	cpi	r24, 0x07	; 7
    356c:	08 f0       	brcs	.+2      	; 0x3570 <main+0x8e6>
    356e:	58 c0       	rjmp	.+176    	; 0x3620 <main+0x996>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:508
      lcd.print(FLASH(modesL[currentMode][currentSettingLeft]));
    3570:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    3574:	38 e0       	ldi	r19, 0x08	; 8
    3576:	83 9f       	mul	r24, r19
    3578:	c0 01       	movw	r24, r0
    357a:	11 24       	eor	r1, r1
    357c:	e8 0f       	add	r30, r24
    357e:	f9 2f       	mov	r31, r25
    3580:	f1 1d       	adc	r31, r1
    3582:	ee 0f       	add	r30, r30
    3584:	ff 1f       	adc	r31, r31
    3586:	e7 5a       	subi	r30, 0xA7	; 167
    3588:	f9 4f       	sbci	r31, 0xF9	; 249
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:510
    } else {
      lcd.print(FLASH(palleteNames[currentValueLeft[0]]));
    358a:	65 91       	lpm	r22, Z+
    358c:	74 91       	lpm	r23, Z
    358e:	85 e1       	ldi	r24, 0x15	; 21
    3590:	9e e4       	ldi	r25, 0x4E	; 78
    3592:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:512
    }
    lcd.print(' ');
    3596:	60 e2       	ldi	r22, 0x20	; 32
    3598:	85 e1       	ldi	r24, 0x15	; 21
    359a:	9e e4       	ldi	r25, 0x4E	; 78
    359c:	0e 94 10 04 	call	0x820	; 0x820 <Print::print(char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:513
    lcd.print(FLASH(modesR[currentMode][currentSettingRight]));
    35a0:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
    35a4:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    35a8:	48 e0       	ldi	r20, 0x08	; 8
    35aa:	84 9f       	mul	r24, r20
    35ac:	c0 01       	movw	r24, r0
    35ae:	11 24       	eor	r1, r1
    35b0:	e8 0f       	add	r30, r24
    35b2:	f9 2f       	mov	r31, r25
    35b4:	f1 1d       	adc	r31, r1
    35b6:	ee 0f       	add	r30, r30
    35b8:	ff 1f       	adc	r31, r31
    35ba:	ed 56       	subi	r30, 0x6D	; 109
    35bc:	fa 4f       	sbci	r31, 0xFA	; 250
    35be:	65 91       	lpm	r22, Z+
    35c0:	74 91       	lpm	r23, Z
    35c2:	85 e1       	ldi	r24, 0x15	; 21
    35c4:	9e e4       	ldi	r25, 0x4E	; 78
    35c6:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:515
  }
  if ((uichg & 7) || attractmode) { //if mode, setting, or value has changed, redraw second line
    35ca:	17 70       	andi	r17, 0x07	; 7
    35cc:	29 f4       	brne	.+10     	; 0x35d8 <main+0x94e>
    35ce:	80 91 8c 41 	lds	r24, 0x418C	; 0x80418c <handleLCD()::attractmode>
    35d2:	88 23       	and	r24, r24
    35d4:	09 f4       	brne	.+2      	; 0x35d8 <main+0x94e>
    35d6:	92 c0       	rjmp	.+292    	; 0x36fc <main+0xa72>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:517
    byte tval;
    if (currentMode > 6) {
    35d8:	e0 91 89 47 	lds	r30, 0x4789	; 0x804789 <currentMode>
    35dc:	e7 30       	cpi	r30, 0x07	; 7
    35de:	40 f1       	brcs	.+80     	; 0x3630 <main+0x9a6>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:518
      lcd.setCursor(0, 0);
    35e0:	40 e0       	ldi	r20, 0x00	; 0
    35e2:	60 e0       	ldi	r22, 0x00	; 0
    35e4:	85 e1       	ldi	r24, 0x15	; 21
    35e6:	9e e4       	ldi	r25, 0x4E	; 78
    35e8:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:519
      lcd.print(FLASH(palleteNames[currentValueLeft[0]]));
    35ec:	e0 91 79 47 	lds	r30, 0x4779	; 0x804779 <currentValueLeft>
    35f0:	f0 e0       	ldi	r31, 0x00	; 0
    35f2:	ee 0f       	add	r30, r30
    35f4:	ff 1f       	adc	r31, r31
    35f6:	ed 5b       	subi	r30, 0xBD	; 189
    35f8:	f9 4f       	sbci	r31, 0xF9	; 249
    35fa:	65 91       	lpm	r22, Z+
    35fc:	74 91       	lpm	r23, Z
    35fe:	85 e1       	ldi	r24, 0x15	; 21
    3600:	9e e4       	ldi	r25, 0x4E	; 78
    3602:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:520
      lcd.setCursor(0, 1);
    3606:	41 e0       	ldi	r20, 0x01	; 1
    3608:	60 e0       	ldi	r22, 0x00	; 0
    360a:	85 e1       	ldi	r24, 0x15	; 21
    360c:	9e e4       	ldi	r25, 0x4E	; 78
    360e:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:521
      lcd.print(F("    "));
    3612:	6e e8       	ldi	r22, 0x8E	; 142
    3614:	75 e0       	ldi	r23, 0x05	; 5
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:530
      lcd.print(tval);
      lcd.print(' ');
      if (tval < 10) lcd.print(' ');
    } else {
      lcd.setCursor(0, 1);
      lcd.print(F("    "));
    3616:	85 e1       	ldi	r24, 0x15	; 21
    3618:	9e e4       	ldi	r25, 0x4E	; 78
    361a:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
    361e:	35 c0       	rjmp	.+106    	; 0x368a <main+0xa00>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:510
  if ((uichg & 6) || attractmode ) { //if setting or mode has changed, redraw settings
    lcd.setCursor(0, 0);
    if (currentMode < 7 ) {
      lcd.print(FLASH(modesL[currentMode][currentSettingLeft]));
    } else {
      lcd.print(FLASH(palleteNames[currentValueLeft[0]]));
    3620:	e0 91 79 47 	lds	r30, 0x4779	; 0x804779 <currentValueLeft>
    3624:	f0 e0       	ldi	r31, 0x00	; 0
    3626:	ee 0f       	add	r30, r30
    3628:	ff 1f       	adc	r31, r31
    362a:	ed 5b       	subi	r30, 0xBD	; 189
    362c:	f9 4f       	sbci	r31, 0xF9	; 249
    362e:	ad cf       	rjmp	.-166    	; 0x358a <main+0x900>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:522
    if (currentMode > 6) {
      lcd.setCursor(0, 0);
      lcd.print(FLASH(palleteNames[currentValueLeft[0]]));
      lcd.setCursor(0, 1);
      lcd.print(F("    "));
    } else if (pgm_read_byte_near(&maxSetting[currentMode][0]) != 255) {
    3630:	f0 e0       	ldi	r31, 0x00	; 0
    3632:	ee 0f       	add	r30, r30
    3634:	ff 1f       	adc	r31, r31
    3636:	e8 58       	subi	r30, 0x88	; 136
    3638:	fa 4f       	sbci	r31, 0xFA	; 250
    363a:	e4 91       	lpm	r30, Z
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:523
      lcd.setCursor(0, 1);
    363c:	41 e0       	ldi	r20, 0x01	; 1
    363e:	60 e0       	ldi	r22, 0x00	; 0
    3640:	85 e1       	ldi	r24, 0x15	; 21
    3642:	9e e4       	ldi	r25, 0x4E	; 78
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:522
    if (currentMode > 6) {
      lcd.setCursor(0, 0);
      lcd.print(FLASH(palleteNames[currentValueLeft[0]]));
      lcd.setCursor(0, 1);
      lcd.print(F("    "));
    } else if (pgm_read_byte_near(&maxSetting[currentMode][0]) != 255) {
    3644:	ef 3f       	cpi	r30, 0xFF	; 255
    3646:	09 f4       	brne	.+2      	; 0x364a <main+0x9c0>
    3648:	5c c0       	rjmp	.+184    	; 0x3702 <main+0xa78>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:523
      lcd.setCursor(0, 1);
    364a:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:524
      tval = getLeftVal(currentValueLeft[currentSettingLeft]);
    364e:	e0 91 8b 41 	lds	r30, 0x418B	; 0x80418b <currentSettingLeft>
    3652:	f0 e0       	ldi	r31, 0x00	; 0
    3654:	e7 58       	subi	r30, 0x87	; 135
    3656:	f8 4b       	sbci	r31, 0xB8	; 184
    3658:	80 81       	ld	r24, Z
    365a:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    365e:	18 2f       	mov	r17, r24
print():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:73
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
    3660:	48 2f       	mov	r20, r24
    3662:	50 e0       	ldi	r21, 0x00	; 0
    3664:	70 e0       	ldi	r23, 0x00	; 0
    3666:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:105
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    3668:	2a e0       	ldi	r18, 0x0A	; 10
    366a:	85 e1       	ldi	r24, 0x15	; 21
    366c:	9e e4       	ldi	r25, 0x4E	; 78
    366e:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <Print::printNumber(unsigned long, unsigned char)>
handleLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:526
      lcd.print(tval);
      lcd.print(' ');
    3672:	60 e2       	ldi	r22, 0x20	; 32
    3674:	85 e1       	ldi	r24, 0x15	; 21
    3676:	9e e4       	ldi	r25, 0x4E	; 78
    3678:	0e 94 10 04 	call	0x820	; 0x820 <Print::print(char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:527
      if (tval < 10) lcd.print(' ');
    367c:	1a 30       	cpi	r17, 0x0A	; 10
    367e:	28 f4       	brcc	.+10     	; 0x368a <main+0xa00>
    3680:	60 e2       	ldi	r22, 0x20	; 32
    3682:	85 e1       	ldi	r24, 0x15	; 21
    3684:	9e e4       	ldi	r25, 0x4E	; 78
    3686:	0e 94 10 04 	call	0x820	; 0x820 <Print::print(char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:532
    } else {
      lcd.setCursor(0, 1);
      lcd.print(F("    "));
    }
    lcd.setCursor(4, 1);
    368a:	41 e0       	ldi	r20, 0x01	; 1
    368c:	64 e0       	ldi	r22, 0x04	; 4
    368e:	85 e1       	ldi	r24, 0x15	; 21
    3690:	9e e4       	ldi	r25, 0x4E	; 78
    3692:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:533
    lcd.print(FLASH(modeNames[currentMode]));
    3696:	e0 91 89 47 	lds	r30, 0x4789	; 0x804789 <currentMode>
    369a:	f0 e0       	ldi	r31, 0x00	; 0
    369c:	ee 0f       	add	r30, r30
    369e:	ff 1f       	adc	r31, r31
    36a0:	e3 5a       	subi	r30, 0xA3	; 163
    36a2:	fa 4f       	sbci	r31, 0xFA	; 250
    36a4:	65 91       	lpm	r22, Z+
    36a6:	74 91       	lpm	r23, Z
    36a8:	85 e1       	ldi	r24, 0x15	; 21
    36aa:	9e e4       	ldi	r25, 0x4E	; 78
    36ac:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:534
    lcd.setCursor(13, 1);
    36b0:	41 e0       	ldi	r20, 0x01	; 1
    36b2:	6d e0       	ldi	r22, 0x0D	; 13
    36b4:	85 e1       	ldi	r24, 0x15	; 21
    36b6:	9e e4       	ldi	r25, 0x4E	; 78
    36b8:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:535
    if (pgm_read_byte_near(&maxValueRight[currentMode][currentSettingRight]) == 1) { //if max is 1, that means it's forward/reverse
    36bc:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
    36c0:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    36c4:	58 e0       	ldi	r21, 0x08	; 8
    36c6:	85 9f       	mul	r24, r21
    36c8:	c0 01       	movw	r24, r0
    36ca:	11 24       	eor	r1, r1
    36cc:	e8 0f       	add	r30, r24
    36ce:	f9 2f       	mov	r31, r25
    36d0:	f1 1d       	adc	r31, r1
    36d2:	ec 5a       	subi	r30, 0xAC	; 172
    36d4:	f8 4f       	sbci	r31, 0xF8	; 248
    36d6:	e4 91       	lpm	r30, Z
    36d8:	e1 30       	cpi	r30, 0x01	; 1
    36da:	c1 f4       	brne	.+48     	; 0x370c <main+0xa82>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:536
      if (currentValueRight[currentSettingRight]) {
    36dc:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
    36e0:	f0 e0       	ldi	r31, 0x00	; 0
    36e2:	ef 57       	subi	r30, 0x7F	; 127
    36e4:	f8 4b       	sbci	r31, 0xB8	; 184
    36e6:	80 81       	ld	r24, Z
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:537
        lcd.print(F("REV"));
    36e8:	69 e5       	ldi	r22, 0x59	; 89
    36ea:	75 e0       	ldi	r23, 0x05	; 5
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:536
    }
    lcd.setCursor(4, 1);
    lcd.print(FLASH(modeNames[currentMode]));
    lcd.setCursor(13, 1);
    if (pgm_read_byte_near(&maxValueRight[currentMode][currentSettingRight]) == 1) { //if max is 1, that means it's forward/reverse
      if (currentValueRight[currentSettingRight]) {
    36ec:	81 11       	cpse	r24, r1
    36ee:	02 c0       	rjmp	.+4      	; 0x36f4 <main+0xa6a>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:539
        lcd.print(F("REV"));
      } else {
        lcd.print(F("FWD"));
    36f0:	65 e5       	ldi	r22, 0x55	; 85
    36f2:	75 e0       	ldi	r23, 0x05	; 5
    36f4:	85 e1       	ldi	r24, 0x15	; 21
    36f6:	9e e4       	ldi	r25, 0x4E	; 78
    36f8:	0e 94 17 04 	call	0x82e	; 0x82e <Print::print(__FlashStringHelper const*)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:552
      } else {
        lcd.print(' ');
      }
    }
  }
  attractmode = 0;
    36fc:	10 92 8c 41 	sts	0x418C, r1	; 0x80418c <handleLCD()::attractmode>
    3700:	77 ce       	rjmp	.-786    	; 0x33f0 <main+0x766>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:529
      tval = getLeftVal(currentValueLeft[currentSettingLeft]);
      lcd.print(tval);
      lcd.print(' ');
      if (tval < 10) lcd.print(' ');
    } else {
      lcd.setCursor(0, 1);
    3702:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:530
      lcd.print(F("    "));
    3706:	63 e7       	ldi	r22, 0x73	; 115
    3708:	75 e0       	ldi	r23, 0x05	; 5
    370a:	85 cf       	rjmp	.-246    	; 0x3616 <main+0x98c>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:542
        lcd.print(F("REV"));
      } else {
        lcd.print(F("FWD"));
      }
    } else {
      tval = currentValueRight[currentSettingRight];
    370c:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
    3710:	f0 e0       	ldi	r31, 0x00	; 0
    3712:	ef 57       	subi	r30, 0x7F	; 127
    3714:	f8 4b       	sbci	r31, 0xB8	; 184
    3716:	10 81       	ld	r17, Z
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:543
      if (tval < 100) lcd.print(' ');
    3718:	14 36       	cpi	r17, 0x64	; 100
    371a:	60 f4       	brcc	.+24     	; 0x3734 <main+0xaaa>
    371c:	60 e2       	ldi	r22, 0x20	; 32
    371e:	85 e1       	ldi	r24, 0x15	; 21
    3720:	9e e4       	ldi	r25, 0x4E	; 78
    3722:	0e 94 10 04 	call	0x820	; 0x820 <Print::print(char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:544
      if (tval < 10) lcd.print(' ');
    3726:	1a 30       	cpi	r17, 0x0A	; 10
    3728:	28 f4       	brcc	.+10     	; 0x3734 <main+0xaaa>
    372a:	60 e2       	ldi	r22, 0x20	; 32
    372c:	85 e1       	ldi	r24, 0x15	; 21
    372e:	9e e4       	ldi	r25, 0x4E	; 78
    3730:	0e 94 10 04 	call	0x820	; 0x820 <Print::print(char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:545
      if (pgm_read_byte_near(&maxValueRight[currentMode][currentSettingRight])) { //if max is 0, then this is blank
    3734:	e0 91 8a 41 	lds	r30, 0x418A	; 0x80418a <currentSettingRight>
    3738:	80 91 89 47 	lds	r24, 0x4789	; 0x804789 <currentMode>
    373c:	68 e0       	ldi	r22, 0x08	; 8
    373e:	86 9f       	mul	r24, r22
    3740:	c0 01       	movw	r24, r0
    3742:	11 24       	eor	r1, r1
    3744:	e8 0f       	add	r30, r24
    3746:	f9 2f       	mov	r31, r25
    3748:	f1 1d       	adc	r31, r1
    374a:	ec 5a       	subi	r30, 0xAC	; 172
    374c:	f8 4f       	sbci	r31, 0xF8	; 248
    374e:	e4 91       	lpm	r30, Z
    3750:	ee 23       	and	r30, r30
    3752:	51 f0       	breq	.+20     	; 0x3768 <main+0xade>
print():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:73
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
    3754:	41 2f       	mov	r20, r17
    3756:	50 e0       	ldi	r21, 0x00	; 0
    3758:	70 e0       	ldi	r23, 0x00	; 0
    375a:	60 e0       	ldi	r22, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Print.cpp:105
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
    375c:	2a e0       	ldi	r18, 0x0A	; 10
    375e:	85 e1       	ldi	r24, 0x15	; 21
    3760:	9e e4       	ldi	r25, 0x4E	; 78
    3762:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <Print::printNumber(unsigned long, unsigned char)>
    3766:	ca cf       	rjmp	.-108    	; 0x36fc <main+0xa72>
handleLCD():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:548
        lcd.print(tval);
      } else {
        lcd.print(' ');
    3768:	60 e2       	ldi	r22, 0x20	; 32
    376a:	85 e1       	ldi	r24, 0x15	; 21
    376c:	9e e4       	ldi	r25, 0x4E	; 78
    376e:	0e 94 10 04 	call	0x820	; 0x820 <Print::print(char)>
    3772:	c4 cf       	rjmp	.-120    	; 0x36fc <main+0xa72>
updatePattern():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:588
void updatePattern() {
  if (currentMode == 0) {
    for (unsigned int i = 0; i < LENGTH * 3; i++) {
      pixels[i] = getLeftVal(currentValueLeft[i % 3]);
    }
  } else if (currentMode == 1) {
    3774:	01 30       	cpi	r16, 0x01	; 1
    3776:	09 f0       	breq	.+2      	; 0x377a <main+0xaf0>
    3778:	75 c0       	rjmp	.+234    	; 0x3864 <main+0xbda>
updatePatternDrift():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:855

/*
   Below this are pattern handlers that have not been updated since getModeColors()
*/
void updatePatternDrift() {
  byte driftchance = 16 + currentValueRight[0] * 10;
    377a:	00 91 81 47 	lds	r16, 0x4781	; 0x804781 <currentValueRight>
    377e:	8a e0       	ldi	r24, 0x0A	; 10
    3780:	08 9f       	mul	r16, r24
    3782:	00 2d       	mov	r16, r0
    3784:	11 24       	eor	r1, r1
    3786:	00 5f       	subi	r16, 0xF0	; 240
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:856
  byte randinc = 255 - driftchance;
    3788:	80 2e       	mov	r8, r16
    378a:	80 94       	com	r8
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:862
  byte randdec = driftchance;
  for (unsigned int i = 0; i < (LENGTH * 3); i++) {
    byte tem = i % 3;
    tem *= 2;
    byte rand = random(255);
    if (rand > (pixels[i] > 32 ? randinc : (randinc + driftchance / 2)) && (pixels[i] < getLeftVal(currentValueLeft[tem + 1]))) {
    378c:	91 2c       	mov	r9, r1
    378e:	80 2f       	mov	r24, r16
    3790:	86 95       	lsr	r24
    3792:	90 e0       	ldi	r25, 0x00	; 0
    3794:	a4 01       	movw	r20, r8
    3796:	48 0f       	add	r20, r24
    3798:	59 1f       	adc	r21, r25
    379a:	4d 87       	std	Y+13, r20	; 0x0d
    379c:	5e 87       	std	Y+14, r21	; 0x0e
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:868
      if (pixels[i] > 128 && pixels[i] < 254) {
        pixels[i] += 2;
      } else {
        pixels[i]++;
      }
    } else if (rand < (pixels[i] > 32 ? randdec : (randdec - driftchance / 2)) && (pixels[i] > getLeftVal(currentValueLeft[tem]))) {
    379e:	10 e0       	ldi	r17, 0x00	; 0
    37a0:	f8 01       	movw	r30, r16
    37a2:	e8 1b       	sub	r30, r24
    37a4:	f9 0b       	sbc	r31, r25
    37a6:	ef 87       	std	Y+15, r30	; 0x0f
    37a8:	f8 8b       	std	Y+16, r31	; 0x10
    37aa:	46 e2       	ldi	r20, 0x26	; 38
    37ac:	e4 2e       	mov	r14, r20
    37ae:	48 e4       	ldi	r20, 0x48	; 72
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:858
*/
void updatePatternDrift() {
  byte driftchance = 16 + currentValueRight[0] * 10;
  byte randinc = 255 - driftchance;
  byte randdec = driftchance;
  for (unsigned int i = 0; i < (LENGTH * 3); i++) {
    37b0:	f4 2e       	mov	r15, r20
main():
    37b2:	b1 2c       	mov	r11, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:859
    byte tem = i % 3;
    37b4:	a1 2c       	mov	r10, r1
updatePatternDrift():
    37b6:	c5 01       	movw	r24, r10
    37b8:	63 e0       	ldi	r22, 0x03	; 3
    37ba:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:860
    tem *= 2;
    37bc:	bd d7       	rcall	.+3962   	; 0x4738 <__udivmodhi4>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:40
    37be:	78 2e       	mov	r7, r24
    37c0:	77 0c       	add	r7, r7
random():
    37c2:	df d4       	rcall	.+2494   	; 0x4182 <random>
    37c4:	a2 01       	movw	r20, r4
    37c6:	91 01       	movw	r18, r2
    37c8:	31 d5       	rcall	.+2658   	; 0x422c <__divmodsi4>
updatePatternDrift():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:862
    byte rand = random(255);
    if (rand > (pixels[i] > 32 ? randinc : (randinc + driftchance / 2)) && (pixels[i] < getLeftVal(currentValueLeft[tem + 1]))) {
    37ca:	c6 2e       	mov	r12, r22
    37cc:	d1 2c       	mov	r13, r1
    37ce:	f7 01       	movw	r30, r14
    37d0:	60 80       	ld	r6, Z
    37d2:	f0 e2       	ldi	r31, 0x20	; 32
    37d4:	f6 15       	cp	r31, r6
    37d6:	a0 f4       	brcc	.+40     	; 0x3800 <main+0xb76>
    37d8:	8c 14       	cp	r8, r12
    37da:	9d 04       	cpc	r9, r13
    37dc:	ec f4       	brge	.+58     	; 0x3818 <main+0xb8e>
    37de:	e7 2d       	mov	r30, r7
    37e0:	f0 e0       	ldi	r31, 0x00	; 0
    37e2:	e6 58       	subi	r30, 0x86	; 134
    37e4:	f8 4b       	sbci	r31, 0xB8	; 184
    37e6:	80 81       	ld	r24, Z
    37e8:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    37ec:	f7 01       	movw	r30, r14
    37ee:	90 81       	ld	r25, Z
    37f0:	68 16       	cp	r6, r24
    37f2:	70 f4       	brcc	.+28     	; 0x3810 <main+0xb86>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:863
      if (pixels[i] > 128 && pixels[i] < 254) {
    37f4:	8f e7       	ldi	r24, 0x7F	; 127
    37f6:	89 0f       	add	r24, r25
    37f8:	8d 37       	cpi	r24, 0x7D	; 125
    37fa:	10 f1       	brcs	.+68     	; 0x3840 <main+0xbb6>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:866
        pixels[i] += 2;
      } else {
        pixels[i]++;
    37fc:	9f 5f       	subi	r25, 0xFF	; 255
    37fe:	21 c0       	rjmp	.+66     	; 0x3842 <main+0xbb8>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:862
  byte randdec = driftchance;
  for (unsigned int i = 0; i < (LENGTH * 3); i++) {
    byte tem = i % 3;
    tem *= 2;
    byte rand = random(255);
    if (rand > (pixels[i] > 32 ? randinc : (randinc + driftchance / 2)) && (pixels[i] < getLeftVal(currentValueLeft[tem + 1]))) {
    3800:	2d 85       	ldd	r18, Y+13	; 0x0d
    3802:	3e 85       	ldd	r19, Y+14	; 0x0e
    3804:	2c 15       	cp	r18, r12
    3806:	3d 05       	cpc	r19, r13
    3808:	54 f3       	brlt	.-44     	; 0x37de <main+0xb54>
main():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:868
      if (pixels[i] > 128 && pixels[i] < 254) {
        pixels[i] += 2;
      } else {
        pixels[i]++;
      }
    } else if (rand < (pixels[i] > 32 ? randdec : (randdec - driftchance / 2)) && (pixels[i] > getLeftVal(currentValueLeft[tem]))) {
    380a:	8f 85       	ldd	r24, Y+15	; 0x0f
    380c:	98 89       	ldd	r25, Y+16	; 0x10
    380e:	05 c0       	rjmp	.+10     	; 0x381a <main+0xb90>
updatePatternDrift():
    3810:	69 2e       	mov	r6, r25
    3812:	f0 e2       	ldi	r31, 0x20	; 32
    3814:	f9 17       	cp	r31, r25
    3816:	c8 f7       	brcc	.-14     	; 0x380a <main+0xb80>
main():
    3818:	c8 01       	movw	r24, r16
updatePatternDrift():
    381a:	c8 16       	cp	r12, r24
    381c:	d9 06       	cpc	r13, r25
    381e:	9c f4       	brge	.+38     	; 0x3846 <main+0xbbc>
    3820:	e7 2d       	mov	r30, r7
    3822:	f0 e0       	ldi	r31, 0x00	; 0
    3824:	e7 58       	subi	r30, 0x87	; 135
    3826:	f8 4b       	sbci	r31, 0xB8	; 184
    3828:	80 81       	ld	r24, Z
    382a:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    382e:	86 15       	cp	r24, r6
    3830:	50 f4       	brcc	.+20     	; 0x3846 <main+0xbbc>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:869
      if (pixels[i] > 128) {
    3832:	f7 01       	movw	r30, r14
    3834:	80 81       	ld	r24, Z
    3836:	81 38       	cpi	r24, 0x81	; 129
    3838:	98 f0       	brcs	.+38     	; 0x3860 <main+0xbd6>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:870
        pixels[i] -= 2;
    383a:	82 50       	subi	r24, 0x02	; 2
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:872
      } else {
        pixels[i]--;
    383c:	80 83       	st	Z, r24
    383e:	03 c0       	rjmp	.+6      	; 0x3846 <main+0xbbc>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:864
    byte tem = i % 3;
    tem *= 2;
    byte rand = random(255);
    if (rand > (pixels[i] > 32 ? randinc : (randinc + driftchance / 2)) && (pixels[i] < getLeftVal(currentValueLeft[tem + 1]))) {
      if (pixels[i] > 128 && pixels[i] < 254) {
        pixels[i] += 2;
    3840:	9e 5f       	subi	r25, 0xFE	; 254
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:866
      } else {
        pixels[i]++;
    3842:	f7 01       	movw	r30, r14
    3844:	90 83       	st	Z, r25
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:858
*/
void updatePatternDrift() {
  byte driftchance = 16 + currentValueRight[0] * 10;
  byte randinc = 255 - driftchance;
  byte randdec = driftchance;
  for (unsigned int i = 0; i < (LENGTH * 3); i++) {
    3846:	ff ef       	ldi	r31, 0xFF	; 255
    3848:	af 1a       	sub	r10, r31
    384a:	bf 0a       	sbc	r11, r31
    384c:	2f ef       	ldi	r18, 0xFF	; 255
    384e:	e2 1a       	sub	r14, r18
    3850:	f2 0a       	sbc	r15, r18
    3852:	3c ed       	ldi	r19, 0xDC	; 220
    3854:	a3 16       	cp	r10, r19
    3856:	35 e0       	ldi	r19, 0x05	; 5
    3858:	b3 06       	cpc	r11, r19
    385a:	09 f0       	breq	.+2      	; 0x385e <main+0xbd4>
    385c:	ac cf       	rjmp	.-168    	; 0x37b6 <main+0xb2c>
    385e:	ed cd       	rjmp	.-1062   	; 0x343a <main+0x7b0>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:872
      }
    } else if (rand < (pixels[i] > 32 ? randdec : (randdec - driftchance / 2)) && (pixels[i] > getLeftVal(currentValueLeft[tem]))) {
      if (pixels[i] > 128) {
        pixels[i] -= 2;
      } else {
        pixels[i]--;
    3860:	81 50       	subi	r24, 0x01	; 1
    3862:	ec cf       	rjmp	.-40     	; 0x383c <main+0xbb2>
updatePattern():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:592
    }
  } else if (currentMode == 1) {
    updatePatternDrift();
    //} else if (currentMode == 2) {
    //updatePatternComets();
  } else if (currentMode == 3) {
    3864:	03 30       	cpi	r16, 0x03	; 3
    3866:	09 f0       	breq	.+2      	; 0x386a <main+0xbe0>
    3868:	21 c1       	rjmp	.+578    	; 0x3aac <main+0xe22>
    386a:	39 e9       	ldi	r19, 0x99	; 153
    386c:	e3 2e       	mov	r14, r19
    386e:	31 e4       	ldi	r19, 0x41	; 65
    3870:	f3 2e       	mov	r15, r19
    3872:	06 e2       	ldi	r16, 0x26	; 38
    3874:	18 e4       	ldi	r17, 0x48	; 72
updatePatternPulse():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:880
  }
}

void updatePatternPulse() {
  for (int  i = 0; i < (LENGTH * 3) - 2; i += 3) {
    byte max_r = (scratch[i] & 0x7C) >> 2;
    3876:	f7 01       	movw	r30, r14
    3878:	80 81       	ld	r24, Z
    387a:	90 e0       	ldi	r25, 0x00	; 0
    387c:	9c 01       	movw	r18, r24
    387e:	35 95       	asr	r19
    3880:	27 95       	ror	r18
    3882:	35 95       	asr	r19
    3884:	27 95       	ror	r18
    3886:	f2 2f       	mov	r31, r18
    3888:	ff 71       	andi	r31, 0x1F	; 31
    388a:	6f 2e       	mov	r6, r31
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:881
    byte max_g = (((scratch[i] & 0x02) << 3) | ((scratch[i + 1] >> 5))); //dont need to mask the low 5 bits here because we're just pushing them off the edge
    388c:	f7 01       	movw	r30, r14
    388e:	41 81       	ldd	r20, Z+1	; 0x01
    3890:	9c 01       	movw	r18, r24
    3892:	73 e0       	ldi	r23, 0x03	; 3
    3894:	22 0f       	add	r18, r18
    3896:	33 1f       	adc	r19, r19
    3898:	7a 95       	dec	r23
    389a:	e1 f7       	brne	.-8      	; 0x3894 <main+0xc0a>
    389c:	20 71       	andi	r18, 0x10	; 16
    389e:	94 2e       	mov	r9, r20
    38a0:	92 94       	swap	r9
    38a2:	96 94       	lsr	r9
    38a4:	a7 e0       	ldi	r26, 0x07	; 7
    38a6:	9a 22       	and	r9, r26
    38a8:	92 2a       	or	r9, r18
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:882
    byte max_b = (scratch[i + 1]) & 0x1F;
    38aa:	4f 71       	andi	r20, 0x1F	; 31
    38ac:	74 2e       	mov	r7, r20
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:883
    byte speed = 1 + (scratch[i + 2] >> 6);
    38ae:	22 81       	ldd	r18, Z+2	; 0x02
    38b0:	82 2e       	mov	r8, r18
    38b2:	82 94       	swap	r8
    38b4:	86 94       	lsr	r8
    38b6:	86 94       	lsr	r8
    38b8:	b3 e0       	ldi	r27, 0x03	; 3
    38ba:	8b 22       	and	r8, r27
    38bc:	83 94       	inc	r8
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:884
    byte bright = scratch[i + 2] & 0x3F;
    38be:	2f 73       	andi	r18, 0x3F	; 63
    38c0:	a2 2e       	mov	r10, r18
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:885
    byte dir = (scratch[i] >> 7);
    38c2:	88 0f       	add	r24, r24
    38c4:	89 2f       	mov	r24, r25
    38c6:	88 1f       	adc	r24, r24
    38c8:	99 0b       	sbc	r25, r25
    38ca:	b8 2e       	mov	r11, r24
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:886
    if (!(max_r + max_b + max_g)) { // need to consider generating new target
    38cc:	26 2d       	mov	r18, r6
    38ce:	24 0f       	add	r18, r20
    38d0:	33 27       	eor	r19, r19
    38d2:	33 1f       	adc	r19, r19
    38d4:	c9 01       	movw	r24, r18
    38d6:	89 0d       	add	r24, r9
    38d8:	91 1d       	adc	r25, r1
    38da:	89 2b       	or	r24, r25
    38dc:	09 f0       	breq	.+2      	; 0x38e0 <main+0xc56>
    38de:	8f c0       	rjmp	.+286    	; 0x39fe <main+0xd74>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:887
      if (random(0, (currentValueRight[0] + 2) * 4 * pgm_read_byte_near(&maxValueRight[currentMode][1])) < currentValueRight[1]) {
    38e0:	80 91 81 47 	lds	r24, 0x4781	; 0x804781 <currentValueRight>
    38e4:	e0 91 89 47 	lds	r30, 0x4789	; 0x804789 <currentMode>
    38e8:	38 e0       	ldi	r19, 0x08	; 8
    38ea:	e3 9f       	mul	r30, r19
    38ec:	f0 01       	movw	r30, r0
    38ee:	11 24       	eor	r1, r1
    38f0:	eb 5a       	subi	r30, 0xAB	; 171
    38f2:	f8 4f       	sbci	r31, 0xF8	; 248
    38f4:	e4 91       	lpm	r30, Z
    38f6:	90 e0       	ldi	r25, 0x00	; 0
    38f8:	02 96       	adiw	r24, 0x02	; 2
    38fa:	88 0f       	add	r24, r24
    38fc:	99 1f       	adc	r25, r25
    38fe:	88 0f       	add	r24, r24
    3900:	99 1f       	adc	r25, r25
    3902:	e8 9f       	mul	r30, r24
    3904:	90 01       	movw	r18, r0
    3906:	e9 9f       	mul	r30, r25
    3908:	30 0d       	add	r19, r0
    390a:	11 24       	eor	r1, r1
    390c:	03 2e       	mov	r0, r19
    390e:	00 0c       	add	r0, r0
    3910:	44 0b       	sbc	r20, r20
    3912:	55 0b       	sbc	r21, r21
    3914:	60 e0       	ldi	r22, 0x00	; 0
    3916:	70 e0       	ldi	r23, 0x00	; 0
    3918:	cb 01       	movw	r24, r22
    391a:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <random(long, long)>
    391e:	20 91 82 47 	lds	r18, 0x4782	; 0x804782 <currentValueRight+0x1>
    3922:	30 e0       	ldi	r19, 0x00	; 0
    3924:	50 e0       	ldi	r21, 0x00	; 0
    3926:	40 e0       	ldi	r20, 0x00	; 0
    3928:	62 17       	cp	r22, r18
    392a:	73 07       	cpc	r23, r19
    392c:	84 07       	cpc	r24, r20
    392e:	95 07       	cpc	r25, r21
    3930:	84 f5       	brge	.+96     	; 0x3992 <main+0xd08>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:888
        max_r = random(currentValueLeft[0], currentValueLeft[1]);
    3932:	20 91 7a 47 	lds	r18, 0x477A	; 0x80477a <currentValueLeft+0x1>
    3936:	60 91 79 47 	lds	r22, 0x4779	; 0x804779 <currentValueLeft>
    393a:	30 e0       	ldi	r19, 0x00	; 0
    393c:	50 e0       	ldi	r21, 0x00	; 0
    393e:	40 e0       	ldi	r20, 0x00	; 0
    3940:	70 e0       	ldi	r23, 0x00	; 0
    3942:	90 e0       	ldi	r25, 0x00	; 0
    3944:	80 e0       	ldi	r24, 0x00	; 0
    3946:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <random(long, long)>
    394a:	66 2e       	mov	r6, r22
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:889
        max_g = random(currentValueLeft[2], currentValueLeft[3]);
    394c:	20 91 7c 47 	lds	r18, 0x477C	; 0x80477c <currentValueLeft+0x3>
    3950:	60 91 7b 47 	lds	r22, 0x477B	; 0x80477b <currentValueLeft+0x2>
    3954:	30 e0       	ldi	r19, 0x00	; 0
    3956:	50 e0       	ldi	r21, 0x00	; 0
    3958:	40 e0       	ldi	r20, 0x00	; 0
    395a:	70 e0       	ldi	r23, 0x00	; 0
    395c:	90 e0       	ldi	r25, 0x00	; 0
    395e:	80 e0       	ldi	r24, 0x00	; 0
    3960:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <random(long, long)>
    3964:	96 2e       	mov	r9, r22
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:890
        max_b = random(currentValueLeft[4], currentValueLeft[5]);
    3966:	20 91 7e 47 	lds	r18, 0x477E	; 0x80477e <currentValueLeft+0x5>
    396a:	60 91 7d 47 	lds	r22, 0x477D	; 0x80477d <currentValueLeft+0x4>
    396e:	30 e0       	ldi	r19, 0x00	; 0
    3970:	50 e0       	ldi	r21, 0x00	; 0
    3972:	40 e0       	ldi	r20, 0x00	; 0
    3974:	70 e0       	ldi	r23, 0x00	; 0
    3976:	90 e0       	ldi	r25, 0x00	; 0
    3978:	80 e0       	ldi	r24, 0x00	; 0
    397a:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <random(long, long)>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:40
    397e:	76 2e       	mov	r7, r22
random():
    3980:	00 d4       	rcall	.+2048   	; 0x4182 <random>
    3982:	23 e0       	ldi	r18, 0x03	; 3
    3984:	30 e0       	ldi	r19, 0x00	; 0
    3986:	40 e0       	ldi	r20, 0x00	; 0
    3988:	50 e0       	ldi	r21, 0x00	; 0
    398a:	50 d4       	rcall	.+2208   	; 0x422c <__divmodsi4>
updatePatternPulse():
    398c:	86 2e       	mov	r8, r22
main():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:891
        speed = random(0, 3);
    398e:	b1 2c       	mov	r11, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:893
        bright = 0;
        dir = 0;
    3990:	a1 2c       	mov	r10, r1
updatePatternPulse():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:892
      if (random(0, (currentValueRight[0] + 2) * 4 * pgm_read_byte_near(&maxValueRight[currentMode][1])) < currentValueRight[1]) {
        max_r = random(currentValueLeft[0], currentValueLeft[1]);
        max_g = random(currentValueLeft[2], currentValueLeft[3]);
        max_b = random(currentValueLeft[4], currentValueLeft[5]);
        speed = random(0, 3);
        bright = 0;
    3992:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:895
        dir = 0;
      }
      pixels[i] = 0;
    3994:	10 82       	st	Z, r1
    3996:	11 82       	std	Z+1, r1	; 0x01
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:896
      pixels[i + 1] = 0;
    3998:	12 82       	std	Z+2, r1	; 0x02
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:897
      pixels[i + 2] = 0;
    399a:	49 2d       	mov	r20, r9
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:928
            }
          }
        }
      }
    }
    scratch[i] = (dir << 7) | (max_r << 2) | (max_g >> 3);
    399c:	50 e0       	ldi	r21, 0x00	; 0
    399e:	20 e8       	ldi	r18, 0x80	; 128
    39a0:	b2 9e       	mul	r11, r18
    39a2:	c0 01       	movw	r24, r0
    39a4:	11 24       	eor	r1, r1
    39a6:	64 e0       	ldi	r22, 0x04	; 4
    39a8:	66 9e       	mul	r6, r22
    39aa:	90 01       	movw	r18, r0
    39ac:	11 24       	eor	r1, r1
    39ae:	82 2b       	or	r24, r18
    39b0:	9a 01       	movw	r18, r20
    39b2:	93 e0       	ldi	r25, 0x03	; 3
    39b4:	35 95       	asr	r19
    39b6:	27 95       	ror	r18
    39b8:	9a 95       	dec	r25
    39ba:	e1 f7       	brne	.-8      	; 0x39b4 <main+0xd2a>
    39bc:	82 2b       	or	r24, r18
    39be:	f7 01       	movw	r30, r14
    39c0:	80 83       	st	Z, r24
    39c2:	25 e0       	ldi	r18, 0x05	; 5
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:929
    scratch[i + 1] = (max_g << 5) | max_b;
    39c4:	44 0f       	add	r20, r20
    39c6:	55 1f       	adc	r21, r21
    39c8:	2a 95       	dec	r18
    39ca:	e1 f7       	brne	.-8      	; 0x39c4 <main+0xd3a>
    39cc:	74 2a       	or	r7, r20
    39ce:	71 82       	std	Z+1, r7	; 0x01
    39d0:	28 2d       	mov	r18, r8
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:930
    scratch[i + 2] = ((speed - 1) << 6) | bright;
    39d2:	21 50       	subi	r18, 0x01	; 1
    39d4:	33 0b       	sbc	r19, r19
    39d6:	49 01       	movw	r8, r18
    39d8:	36 e0       	ldi	r19, 0x06	; 6
    39da:	88 0c       	add	r8, r8
    39dc:	99 1c       	adc	r9, r9
    39de:	3a 95       	dec	r19
    39e0:	e1 f7       	brne	.-8      	; 0x39da <main+0xd50>
    39e2:	a8 28       	or	r10, r8
    39e4:	a2 82       	std	Z+2, r10	; 0x02
    39e6:	33 e0       	ldi	r19, 0x03	; 3
    39e8:	e3 0e       	add	r14, r19
    39ea:	f1 1c       	adc	r15, r1
    39ec:	0d 5f       	subi	r16, 0xFD	; 253
    39ee:	1f 4f       	sbci	r17, 0xFF	; 255
    39f0:	45 e7       	ldi	r20, 0x75	; 117
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:879
    }
  }
}

void updatePatternPulse() {
  for (int  i = 0; i < (LENGTH * 3) - 2; i += 3) {
    39f2:	57 e4       	ldi	r21, 0x47	; 71
    39f4:	4e 15       	cp	r20, r14
    39f6:	5f 05       	cpc	r21, r15
    39f8:	09 f0       	breq	.+2      	; 0x39fc <main+0xd72>
    39fa:	3d cf       	rjmp	.-390    	; 0x3876 <main+0xbec>
    39fc:	1e cd       	rjmp	.-1476   	; 0x343a <main+0x7b0>
    39fe:	28 2d       	mov	r18, r8
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:899
      }
      pixels[i] = 0;
      pixels[i + 1] = 0;
      pixels[i + 2] = 0;
    } else {
      if (!(frameNumber % (speed))) {
    3a00:	30 e0       	ldi	r19, 0x00	; 0
    3a02:	50 e0       	ldi	r21, 0x00	; 0
    3a04:	40 e0       	ldi	r20, 0x00	; 0
    3a06:	60 91 75 47 	lds	r22, 0x4775	; 0x804775 <frameNumber>
    3a0a:	70 91 76 47 	lds	r23, 0x4776	; 0x804776 <frameNumber+0x1>
    3a0e:	80 91 77 47 	lds	r24, 0x4777	; 0x804777 <frameNumber+0x2>
    3a12:	90 91 78 47 	lds	r25, 0x4778	; 0x804778 <frameNumber+0x3>
    3a16:	36 d4       	rcall	.+2156   	; 0x4284 <__udivmodsi4>
    3a18:	67 2b       	or	r22, r23
    3a1a:	68 2b       	or	r22, r24
    3a1c:	69 2b       	or	r22, r25
    3a1e:	09 f0       	breq	.+2      	; 0x3a22 <main+0xd98>
    3a20:	bc cf       	rjmp	.-136    	; 0x399a <main+0xd10>
    3a22:	bb 20       	and	r11, r11
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:901

        if (dir && !bright) {
    3a24:	59 f0       	breq	.+22     	; 0x3a3c <main+0xdb2>
    3a26:	a1 10       	cpse	r10, r1
    3a28:	09 c0       	rjmp	.+18     	; 0x3a3c <main+0xdb2>
    3a2a:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:903
          dir = 0;
          pixels[i] = 0;
    3a2c:	10 82       	st	Z, r1
    3a2e:	11 82       	std	Z+1, r1	; 0x01
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:904
          pixels[i + 1] = 0;
    3a30:	12 82       	std	Z+2, r1	; 0x02
main():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:905
          pixels[i + 2] = 0;
    3a32:	b1 2c       	mov	r11, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:902
      pixels[i + 2] = 0;
    } else {
      if (!(frameNumber % (speed))) {

        if (dir && !bright) {
          dir = 0;
    3a34:	71 2c       	mov	r7, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:908
          pixels[i] = 0;
          pixels[i + 1] = 0;
          pixels[i + 2] = 0;
          max_r = 0;
          max_g = 0;
          max_b = 0;
    3a36:	91 2c       	mov	r9, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:907
          dir = 0;
          pixels[i] = 0;
          pixels[i + 1] = 0;
          pixels[i + 2] = 0;
          max_r = 0;
          max_g = 0;
    3a38:	61 2c       	mov	r6, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:906
        if (dir && !bright) {
          dir = 0;
          pixels[i] = 0;
          pixels[i + 1] = 0;
          pixels[i + 2] = 0;
          max_r = 0;
    3a3a:	af cf       	rjmp	.-162    	; 0x399a <main+0xd10>
updatePatternPulse():
    3a3c:	ea 2d       	mov	r30, r10
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:910
          max_g = 0;
          max_b = 0;
        } else {
          byte nbright = pgm_read_byte_near(&pulseBrightnessTable[bright]);
    3a3e:	f0 e0       	ldi	r31, 0x00	; 0
    3a40:	e7 5f       	subi	r30, 0xF7	; 247
    3a42:	f8 4f       	sbci	r31, 0xF8	; 248
    3a44:	c4 90       	lpm	r12, Z
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:912
          //byte nbright = bright << 2;
          pixels[i] = map(nbright, 0, 255, 0, getLeftVal(max_r));
    3a46:	86 2d       	mov	r24, r6
    3a48:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
map():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Common.cpp:6
    3a4c:	d1 2c       	mov	r13, r1
    3a4e:	28 2f       	mov	r18, r24
    3a50:	30 e0       	ldi	r19, 0x00	; 0
    3a52:	d6 01       	movw	r26, r12
    3a54:	39 d4       	rcall	.+2162   	; 0x42c8 <__umulhisi3>
    3a56:	a2 01       	movw	r20, r4
    3a58:	91 01       	movw	r18, r2
    3a5a:	e8 d3       	rcall	.+2000   	; 0x422c <__divmodsi4>
updatePatternPulse():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:912
    3a5c:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:913
          pixels[i + 1] = map(nbright, 0, 255, 0, getLeftVal(max_g));
    3a5e:	20 83       	st	Z, r18
    3a60:	89 2d       	mov	r24, r9
    3a62:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
map():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Common.cpp:6
    3a66:	96 01       	movw	r18, r12
    3a68:	a8 2f       	mov	r26, r24
    3a6a:	b0 e0       	ldi	r27, 0x00	; 0
    3a6c:	2d d4       	rcall	.+2138   	; 0x42c8 <__umulhisi3>
    3a6e:	a2 01       	movw	r20, r4
    3a70:	91 01       	movw	r18, r2
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:913
    3a72:	dc d3       	rcall	.+1976   	; 0x422c <__divmodsi4>
updatePatternPulse():
    3a74:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:914
          pixels[i + 2] = map(nbright, 0, 255, 0, getLeftVal(max_b));
    3a76:	21 83       	std	Z+1, r18	; 0x01
    3a78:	87 2d       	mov	r24, r7
    3a7a:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
map():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Common.cpp:6
    3a7e:	96 01       	movw	r18, r12
    3a80:	a8 2f       	mov	r26, r24
    3a82:	b0 e0       	ldi	r27, 0x00	; 0
    3a84:	21 d4       	rcall	.+2114   	; 0x42c8 <__umulhisi3>
    3a86:	a2 01       	movw	r20, r4
    3a88:	91 01       	movw	r18, r2
    3a8a:	d0 d3       	rcall	.+1952   	; 0x422c <__divmodsi4>
updatePatternPulse():
    3a8c:	f8 01       	movw	r30, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:914
    3a8e:	22 83       	std	Z+2, r18	; 0x02
    3a90:	bb 20       	and	r11, r11
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:915
          if (dir) {
    3a92:	11 f0       	breq	.+4      	; 0x3a98 <main+0xe0e>
    3a94:	aa 94       	dec	r10
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:916
            bright--;
    3a96:	81 cf       	rjmp	.-254    	; 0x399a <main+0xd10>
    3a98:	ff e3       	ldi	r31, 0x3F	; 63
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:918
          } else {
            if (bright == 63) {
    3a9a:	af 16       	cp	r10, r31
    3a9c:	11 f0       	breq	.+4      	; 0x3aa2 <main+0xe18>
    3a9e:	a3 94       	inc	r10
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:922
              bright--;
              dir = 1;
            } else {
              bright++;
    3aa0:	7c cf       	rjmp	.-264    	; 0x399a <main+0xd10>
main():
    3aa2:	bb 24       	eor	r11, r11
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:920
          if (dir) {
            bright--;
          } else {
            if (bright == 63) {
              bright--;
              dir = 1;
    3aa4:	b3 94       	inc	r11
    3aa6:	4e e3       	ldi	r20, 0x3E	; 62
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:919
          pixels[i + 2] = map(nbright, 0, 255, 0, getLeftVal(max_b));
          if (dir) {
            bright--;
          } else {
            if (bright == 63) {
              bright--;
    3aa8:	a4 2e       	mov	r10, r20
    3aaa:	77 cf       	rjmp	.-274    	; 0x399a <main+0xd10>
updatePattern():
    3aac:	04 30       	cpi	r16, 0x04	; 4
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:594
    updatePatternDrift();
    //} else if (currentMode == 2) {
    //updatePatternComets();
  } else if (currentMode == 3) {
    updatePatternPulse();
  } else if (currentMode == 4) {
    3aae:	19 f4       	brne	.+6      	; 0x3ab6 <main+0xe2c>
    3ab0:	0e 94 26 12 	call	0x244c	; 0x244c <updatePatternWave()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:595
    updatePatternWave(); //rainbow is just a subset of wave
    3ab4:	c2 cc       	rjmp	.-1660   	; 0x343a <main+0x7b0>
    3ab6:	05 30       	cpi	r16, 0x05	; 5
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:596
  } else if (currentMode == 5) {
    3ab8:	09 f0       	breq	.+2      	; 0x3abc <main+0xe32>
    3aba:	5c c0       	rjmp	.+184    	; 0x3b74 <main+0xeea>
updatePatternDots():
    3abc:	80 91 82 47 	lds	r24, 0x4782	; 0x804782 <currentValueRight+0x1>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:617
  frameNumber++;
}

void updatePatternDots() {
  byte r, g, b;
  if (!(frameNumber % (13 - currentValueRight[1]))) {
    3ac0:	2d e0       	ldi	r18, 0x0D	; 13
    3ac2:	30 e0       	ldi	r19, 0x00	; 0
    3ac4:	28 1b       	sub	r18, r24
    3ac6:	31 09       	sbc	r19, r1
    3ac8:	03 2e       	mov	r0, r19
    3aca:	00 0c       	add	r0, r0
    3acc:	44 0b       	sbc	r20, r20
    3ace:	55 0b       	sbc	r21, r21
    3ad0:	60 91 75 47 	lds	r22, 0x4775	; 0x804775 <frameNumber>
    3ad4:	70 91 76 47 	lds	r23, 0x4776	; 0x804776 <frameNumber+0x1>
    3ad8:	80 91 77 47 	lds	r24, 0x4777	; 0x804777 <frameNumber+0x2>
    3adc:	90 91 78 47 	lds	r25, 0x4778	; 0x804778 <frameNumber+0x3>
    3ae0:	d1 d3       	rcall	.+1954   	; 0x4284 <__udivmodsi4>
main():
    3ae2:	40 e0       	ldi	r20, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:622
    r = random(getLeftVal(currentValueLeft[0]), getLeftVal(currentValueLeft[1]));
    g = random(getLeftVal(currentValueLeft[2]), getLeftVal(currentValueLeft[3]));
    b = random(getLeftVal(currentValueLeft[4]), getLeftVal(currentValueLeft[5]));
  } else {
    r = 0; g = 0; b = 0;
    3ae4:	f1 2c       	mov	r15, r1
updatePatternDots():
    3ae6:	67 2b       	or	r22, r23
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:617
  frameNumber++;
}

void updatePatternDots() {
  byte r, g, b;
  if (!(frameNumber % (13 - currentValueRight[1]))) {
    3ae8:	68 2b       	or	r22, r24
    3aea:	69 2b       	or	r22, r25
    3aec:	e1 f5       	brne	.+120    	; 0x3b66 <main+0xedc>
    3aee:	80 91 7a 47 	lds	r24, 0x477A	; 0x80477a <currentValueLeft+0x1>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:618
    r = random(getLeftVal(currentValueLeft[0]), getLeftVal(currentValueLeft[1]));
    3af2:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3af6:	18 2f       	mov	r17, r24
    3af8:	80 91 79 47 	lds	r24, 0x4779	; 0x804779 <currentValueLeft>
    3afc:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3b00:	21 2f       	mov	r18, r17
    3b02:	30 e0       	ldi	r19, 0x00	; 0
    3b04:	50 e0       	ldi	r21, 0x00	; 0
    3b06:	40 e0       	ldi	r20, 0x00	; 0
    3b08:	68 2f       	mov	r22, r24
    3b0a:	70 e0       	ldi	r23, 0x00	; 0
    3b0c:	90 e0       	ldi	r25, 0x00	; 0
    3b0e:	80 e0       	ldi	r24, 0x00	; 0
    3b10:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <random(long, long)>
    3b14:	16 2f       	mov	r17, r22
    3b16:	80 91 7c 47 	lds	r24, 0x477C	; 0x80477c <currentValueLeft+0x3>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:619
    g = random(getLeftVal(currentValueLeft[2]), getLeftVal(currentValueLeft[3]));
    3b1a:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3b1e:	08 2f       	mov	r16, r24
    3b20:	80 91 7b 47 	lds	r24, 0x477B	; 0x80477b <currentValueLeft+0x2>
    3b24:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3b28:	20 2f       	mov	r18, r16
    3b2a:	30 e0       	ldi	r19, 0x00	; 0
    3b2c:	50 e0       	ldi	r21, 0x00	; 0
    3b2e:	40 e0       	ldi	r20, 0x00	; 0
    3b30:	68 2f       	mov	r22, r24
    3b32:	70 e0       	ldi	r23, 0x00	; 0
    3b34:	90 e0       	ldi	r25, 0x00	; 0
    3b36:	80 e0       	ldi	r24, 0x00	; 0
    3b38:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <random(long, long)>
    3b3c:	f6 2e       	mov	r15, r22
    3b3e:	80 91 7e 47 	lds	r24, 0x477E	; 0x80477e <currentValueLeft+0x5>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:620
    b = random(getLeftVal(currentValueLeft[4]), getLeftVal(currentValueLeft[5]));
    3b42:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3b46:	08 2f       	mov	r16, r24
    3b48:	80 91 7d 47 	lds	r24, 0x477D	; 0x80477d <currentValueLeft+0x4>
    3b4c:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3b50:	20 2f       	mov	r18, r16
    3b52:	30 e0       	ldi	r19, 0x00	; 0
    3b54:	50 e0       	ldi	r21, 0x00	; 0
    3b56:	40 e0       	ldi	r20, 0x00	; 0
    3b58:	68 2f       	mov	r22, r24
    3b5a:	70 e0       	ldi	r23, 0x00	; 0
    3b5c:	90 e0       	ldi	r25, 0x00	; 0
    3b5e:	80 e0       	ldi	r24, 0x00	; 0
    3b60:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <random(long, long)>
    3b64:	46 2f       	mov	r20, r22
    3b66:	20 91 83 47 	lds	r18, 0x4783	; 0x804783 <currentValueRight+0x2>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:624
  } else {
    r = 0; g = 0; b = 0;
  }
  pushPixel(r, g, b, currentValueRight[2]);
    3b6a:	6f 2d       	mov	r22, r15
    3b6c:	81 2f       	mov	r24, r17
updatePatternDots2():
    3b6e:	0e 94 bf 08 	call	0x117e	; 0x117e <pushPixel(unsigned char, unsigned char, unsigned char, unsigned char)>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:634
  if (!(frameNumber % (13 - currentValueRight[1]))) {
    getModeColors(&r, &g, &b, random(0, pgm_read_byte_near(&colorCount[getPalleteNumber()]) * (getTransitionFrames() + getDwellFrames())));
  } else {
    r = 0; g = 0; b = 0;
  }
  pushPixel(r, g, b, currentValueRight[2]);
    3b72:	63 cc       	rjmp	.-1850   	; 0x343a <main+0x7b0>
updatePattern():
    3b74:	06 30       	cpi	r16, 0x06	; 6
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:598
    updatePatternPulse();
  } else if (currentMode == 4) {
    updatePatternWave(); //rainbow is just a subset of wave
  } else if (currentMode == 5) {
    updatePatternDots();
  } else if (currentMode == 6) {
    3b76:	09 f0       	breq	.+2      	; 0x3b7a <main+0xef0>
    3b78:	7f c0       	rjmp	.+254    	; 0x3c78 <main+0xfee>
updatePatternFade():
    3b7a:	80 91 95 41 	lds	r24, 0x4195	; 0x804195 <updatePatternFade()::bright>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:650
}


void updatePatternFade() {
  static byte bright = 0;
  if (bright & 128) {
    3b7e:	87 ff       	sbrs	r24, 7
    3b80:	73 c0       	rjmp	.+230    	; 0x3c68 <main+0xfde>
    3b82:	98 2f       	mov	r25, r24
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:651
    if (bright & 63) {
    3b84:	9f 73       	andi	r25, 0x3F	; 63
    3b86:	81 50       	subi	r24, 0x01	; 1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:652
      bright--;
    3b88:	91 11       	cpse	r25, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:651


void updatePatternFade() {
  static byte bright = 0;
  if (bright & 128) {
    if (bright & 63) {
    3b8a:	71 c0       	rjmp	.+226    	; 0x3c6e <main+0xfe4>
    3b8c:	10 92 95 41 	sts	0x4195, r1	; 0x804195 <updatePatternFade()::bright>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:654
      bright--;
    } else {
      bright = 0;
    3b90:	e0 91 95 41 	lds	r30, 0x4195	; 0x804195 <updatePatternFade()::bright>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:663
      bright = 0xBF;
    } else {
      bright++;
    }
  }
  byte nbright = pgm_read_byte_near(&pulseBrightnessTable[63 & bright]);
    3b94:	ef 73       	andi	r30, 0x3F	; 63
    3b96:	f0 e0       	ldi	r31, 0x00	; 0
    3b98:	e7 5f       	subi	r30, 0xF7	; 247
    3b9a:	f8 4f       	sbci	r31, 0xF8	; 248
    3b9c:	c4 90       	lpm	r12, Z
    3b9e:	80 91 7c 47 	lds	r24, 0x477C	; 0x80477c <currentValueLeft+0x3>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:664
  byte r = map(nbright, 0, 255, getLeftVal(currentValueLeft[0]), getLeftVal(currentValueLeft[3]));
    3ba2:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3ba6:	18 2f       	mov	r17, r24
    3ba8:	80 91 79 47 	lds	r24, 0x4779	; 0x804779 <currentValueLeft>
    3bac:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3bb0:	88 2e       	mov	r8, r24
    3bb2:	91 2c       	mov	r9, r1
    3bb4:	b1 2c       	mov	r11, r1
    3bb6:	a1 2c       	mov	r10, r1
    3bb8:	d1 2c       	mov	r13, r1
    3bba:	f1 2c       	mov	r15, r1
    3bbc:	e1 2c       	mov	r14, r1
    3bbe:	21 2f       	mov	r18, r17
    3bc0:	30 e0       	ldi	r19, 0x00	; 0
    3bc2:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Common.cpp:6
    3bc4:	40 e0       	ldi	r20, 0x00	; 0
map():
    3bc6:	28 19       	sub	r18, r8
    3bc8:	39 09       	sbc	r19, r9
    3bca:	4a 09       	sbc	r20, r10
    3bcc:	5b 09       	sbc	r21, r11
    3bce:	c7 01       	movw	r24, r14
    3bd0:	b6 01       	movw	r22, r12
    3bd2:	a3 d5       	rcall	.+2886   	; 0x471a <__mulsi3>
    3bd4:	a2 01       	movw	r20, r4
    3bd6:	91 01       	movw	r18, r2
    3bd8:	29 d3       	rcall	.+1618   	; 0x422c <__divmodsi4>
updatePatternFade():
    3bda:	02 2f       	mov	r16, r18
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:664
    3bdc:	08 0d       	add	r16, r8
    3bde:	80 91 7d 47 	lds	r24, 0x477D	; 0x80477d <currentValueLeft+0x4>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:665
  byte g = map(nbright, 0, 255, getLeftVal(currentValueLeft[1]), getLeftVal(currentValueLeft[4]));
    3be2:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3be6:	18 2f       	mov	r17, r24
    3be8:	80 91 7a 47 	lds	r24, 0x477A	; 0x80477a <currentValueLeft+0x1>
    3bec:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3bf0:	88 2e       	mov	r8, r24
    3bf2:	91 2c       	mov	r9, r1
    3bf4:	b1 2c       	mov	r11, r1
    3bf6:	a1 2c       	mov	r10, r1
    3bf8:	21 2f       	mov	r18, r17
    3bfa:	30 e0       	ldi	r19, 0x00	; 0
    3bfc:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Common.cpp:6
    3bfe:	40 e0       	ldi	r20, 0x00	; 0
map():
    3c00:	28 19       	sub	r18, r8
    3c02:	39 09       	sbc	r19, r9
    3c04:	4a 09       	sbc	r20, r10
    3c06:	5b 09       	sbc	r21, r11
    3c08:	c7 01       	movw	r24, r14
    3c0a:	b6 01       	movw	r22, r12
    3c0c:	86 d5       	rcall	.+2828   	; 0x471a <__mulsi3>
    3c0e:	a2 01       	movw	r20, r4
    3c10:	91 01       	movw	r18, r2
    3c12:	0c d3       	rcall	.+1560   	; 0x422c <__divmodsi4>
updatePatternFade():
    3c14:	72 2e       	mov	r7, r18
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:665
    3c16:	78 0c       	add	r7, r8
    3c18:	80 91 7e 47 	lds	r24, 0x477E	; 0x80477e <currentValueLeft+0x5>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:666
  byte b = map(nbright, 0, 255, getLeftVal(currentValueLeft[2]), getLeftVal(currentValueLeft[5]));
    3c1c:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3c20:	18 2f       	mov	r17, r24
    3c22:	80 91 7b 47 	lds	r24, 0x477B	; 0x80477b <currentValueLeft+0x2>
    3c26:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <getLeftVal(unsigned char)>
    3c2a:	88 2e       	mov	r8, r24
    3c2c:	91 2c       	mov	r9, r1
    3c2e:	b1 2c       	mov	r11, r1
    3c30:	a1 2c       	mov	r10, r1
    3c32:	21 2f       	mov	r18, r17
    3c34:	30 e0       	ldi	r19, 0x00	; 0
    3c36:	50 e0       	ldi	r21, 0x00	; 0
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore\api/Common.cpp:6
    3c38:	40 e0       	ldi	r20, 0x00	; 0
map():
    3c3a:	28 19       	sub	r18, r8
    3c3c:	39 09       	sbc	r19, r9
    3c3e:	4a 09       	sbc	r20, r10
    3c40:	5b 09       	sbc	r21, r11
    3c42:	c7 01       	movw	r24, r14
    3c44:	b6 01       	movw	r22, r12
    3c46:	69 d5       	rcall	.+2770   	; 0x471a <__mulsi3>
    3c48:	a2 01       	movw	r20, r4
    3c4a:	91 01       	movw	r18, r2
    3c4c:	ef d2       	rcall	.+1502   	; 0x422c <__divmodsi4>
updatePatternFade():
    3c4e:	82 0e       	add	r8, r18
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:666
    3c50:	e6 e2       	ldi	r30, 0x26	; 38
    3c52:	f8 e4       	ldi	r31, 0x48	; 72
setAll():
    3c54:	00 83       	st	Z, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:686
}


void setAll(byte r, byte g, byte b) {
  for (unsigned int i = 0; i < ((LENGTH) * 3); i += 3) {
    pixels[i] = r;
    3c56:	71 82       	std	Z+1, r7	; 0x01
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:687
    pixels[i + 1] = g;
    3c58:	82 82       	std	Z+2, r8	; 0x02
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:688
    pixels[i + 2] = b;
    3c5a:	33 96       	adiw	r30, 0x03	; 3
    3c5c:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:685
  pushPixel(r, g, b, currentValueRight[currentMode == 4 ? 2 : 3]);
}


void setAll(byte r, byte g, byte b) {
  for (unsigned int i = 0; i < ((LENGTH) * 3); i += 3) {
    3c5e:	9e e4       	ldi	r25, 0x4E	; 78
    3c60:	8e 17       	cp	r24, r30
    3c62:	9f 07       	cpc	r25, r31
    3c64:	b9 f7       	brne	.-18     	; 0x3c54 <main+0xfca>
    3c66:	e9 cb       	rjmp	.-2094   	; 0x343a <main+0x7b0>
updatePatternFade():
    3c68:	8f 33       	cpi	r24, 0x3F	; 63
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:657
      bright--;
    } else {
      bright = 0;
    }
  } else {
    if (bright >= 63) {
    3c6a:	20 f0       	brcs	.+8      	; 0x3c74 <main+0xfea>
    3c6c:	8f eb       	ldi	r24, 0xBF	; 191
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:658
      bright = 0xBF;
    3c6e:	80 93 95 41 	sts	0x4195, r24	; 0x804195 <updatePatternFade()::bright>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:660
    } else {
      bright++;
    3c72:	8e cf       	rjmp	.-228    	; 0x3b90 <main+0xf06>
    3c74:	8f 5f       	subi	r24, 0xFF	; 255
    3c76:	fb cf       	rjmp	.-10     	; 0x3c6e <main+0xfe4>
updatePattern():
    3c78:	07 30       	cpi	r16, 0x07	; 7
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:601
  } else if (currentMode == 5) {
    updatePatternDots();
  } else if (currentMode == 6) {
    updatePatternFade();

  } else if (currentMode == 7) {
    3c7a:	09 f4       	brne	.+2      	; 0x3c7e <main+0xff4>
    3c7c:	19 cf       	rjmp	.-462    	; 0x3ab0 <main+0xe26>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:603
    updatePatternWave();
  } else if (currentMode == 8) {
    3c7e:	08 30       	cpi	r16, 0x08	; 8
    3c80:	09 f0       	breq	.+2      	; 0x3c84 <main+0xffa>
    3c82:	4b c0       	rjmp	.+150    	; 0x3d1a <main+0x1090>
updatePatternDots2():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:629
  pushPixel(r, g, b, currentValueRight[2]);
}

void updatePatternDots2() {
  static byte r, g, b;
  if (!(frameNumber % (13 - currentValueRight[1]))) {
    3c84:	80 91 82 47 	lds	r24, 0x4782	; 0x804782 <currentValueRight+0x1>
    3c88:	2d e0       	ldi	r18, 0x0D	; 13
    3c8a:	30 e0       	ldi	r19, 0x00	; 0
    3c8c:	28 1b       	sub	r18, r24
    3c8e:	31 09       	sbc	r19, r1
    3c90:	03 2e       	mov	r0, r19
    3c92:	00 0c       	add	r0, r0
    3c94:	44 0b       	sbc	r20, r20
    3c96:	55 0b       	sbc	r21, r21
    3c98:	60 91 75 47 	lds	r22, 0x4775	; 0x804775 <frameNumber>
    3c9c:	70 91 76 47 	lds	r23, 0x4776	; 0x804776 <frameNumber+0x1>
    3ca0:	80 91 77 47 	lds	r24, 0x4777	; 0x804777 <frameNumber+0x2>
    3ca4:	90 91 78 47 	lds	r25, 0x4778	; 0x804778 <frameNumber+0x3>
    3ca8:	ed d2       	rcall	.+1498   	; 0x4284 <__udivmodsi4>
    3caa:	67 2b       	or	r22, r23
    3cac:	68 2b       	or	r22, r24
    3cae:	69 2b       	or	r22, r25
    3cb0:	69 f5       	brne	.+90     	; 0x3d0c <main+0x1082>
    3cb2:	0e 94 c0 07 	call	0xf80	; 0xf80 <getPalleteNumber()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:630
    getModeColors(&r, &g, &b, random(0, pgm_read_byte_near(&colorCount[getPalleteNumber()]) * (getTransitionFrames() + getDwellFrames())));
    3cb6:	e8 2f       	mov	r30, r24
    3cb8:	f0 e0       	ldi	r31, 0x00	; 0
    3cba:	e7 5b       	subi	r30, 0xB7	; 183
    3cbc:	f8 4f       	sbci	r31, 0xF8	; 248
    3cbe:	f4 90       	lpm	r15, Z
    3cc0:	0e 94 c9 07 	call	0xf92	; 0xf92 <getTransitionFrames()>
    3cc4:	8c 01       	movw	r16, r24
    3cc6:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <getDwellFrames()>
    3cca:	80 0f       	add	r24, r16
    3ccc:	91 1f       	adc	r25, r17
    3cce:	f8 9e       	mul	r15, r24
    3cd0:	90 01       	movw	r18, r0
    3cd2:	f9 9e       	mul	r15, r25
    3cd4:	30 0d       	add	r19, r0
    3cd6:	11 24       	eor	r1, r1
    3cd8:	50 e0       	ldi	r21, 0x00	; 0
    3cda:	40 e0       	ldi	r20, 0x00	; 0
    3cdc:	60 e0       	ldi	r22, 0x00	; 0
    3cde:	70 e0       	ldi	r23, 0x00	; 0
    3ce0:	cb 01       	movw	r24, r22
    3ce2:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <random(long, long)>
    3ce6:	8b 01       	movw	r16, r22
    3ce8:	9c 01       	movw	r18, r24
    3cea:	46 e9       	ldi	r20, 0x96	; 150
    3cec:	51 e4       	ldi	r21, 0x41	; 65
    3cee:	67 e9       	ldi	r22, 0x97	; 151
    3cf0:	71 e4       	ldi	r23, 0x41	; 65
    3cf2:	88 e9       	ldi	r24, 0x98	; 152
    3cf4:	91 e4       	ldi	r25, 0x41	; 65
    3cf6:	0e 94 a5 10 	call	0x214a	; 0x214a <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)>
    3cfa:	20 91 83 47 	lds	r18, 0x4783	; 0x804783 <currentValueRight+0x2>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:634
  } else {
    r = 0; g = 0; b = 0;
  }
  pushPixel(r, g, b, currentValueRight[2]);
    3cfe:	40 91 96 41 	lds	r20, 0x4196	; 0x804196 <updatePatternDots2()::b>
    3d02:	60 91 97 41 	lds	r22, 0x4197	; 0x804197 <updatePatternDots2()::g>
    3d06:	80 91 98 41 	lds	r24, 0x4198	; 0x804198 <updatePatternDots2()::r>
    3d0a:	31 cf       	rjmp	.-414    	; 0x3b6e <main+0xee4>
    3d0c:	10 92 98 41 	sts	0x4198, r1	; 0x804198 <updatePatternDots2()::r>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:632
void updatePatternDots2() {
  static byte r, g, b;
  if (!(frameNumber % (13 - currentValueRight[1]))) {
    getModeColors(&r, &g, &b, random(0, pgm_read_byte_near(&colorCount[getPalleteNumber()]) * (getTransitionFrames() + getDwellFrames())));
  } else {
    r = 0; g = 0; b = 0;
    3d10:	10 92 97 41 	sts	0x4197, r1	; 0x804197 <updatePatternDots2()::g>
    3d14:	10 92 96 41 	sts	0x4196, r1	; 0x804196 <updatePatternDots2()::b>
    3d18:	f0 cf       	rjmp	.-32     	; 0x3cfa <main+0x1070>
updatePattern():
    3d1a:	09 30       	cpi	r16, 0x09	; 9
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:605

  } else if (currentMode == 7) {
    updatePatternWave();
  } else if (currentMode == 8) {
    updatePatternDots2();
  } else if (currentMode == 9) {
    3d1c:	09 f5       	brne	.+66     	; 0x3d60 <main+0x10d6>
updatePatternFade2():
    3d1e:	00 91 75 47 	lds	r16, 0x4775	; 0x804775 <frameNumber>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:672
  setAll(r, g, b);
}

void updatePatternFade2() {
  byte r, g, b;
  getModeColors(&r, &g, &b, frameNumber);
    3d22:	10 91 76 47 	lds	r17, 0x4776	; 0x804776 <frameNumber+0x1>
    3d26:	20 91 77 47 	lds	r18, 0x4777	; 0x804777 <frameNumber+0x2>
    3d2a:	30 91 78 47 	lds	r19, 0x4778	; 0x804778 <frameNumber+0x3>
    3d2e:	ae 01       	movw	r20, r28
    3d30:	48 5f       	subi	r20, 0xF8	; 248
    3d32:	5f 4f       	sbci	r21, 0xFF	; 255
    3d34:	be 01       	movw	r22, r28
    3d36:	67 5f       	subi	r22, 0xF7	; 247
    3d38:	7f 4f       	sbci	r23, 0xFF	; 255
    3d3a:	ce 01       	movw	r24, r28
    3d3c:	0a 96       	adiw	r24, 0x0a	; 10
    3d3e:	0e 94 a5 10 	call	0x214a	; 0x214a <getModeColors(unsigned char*, unsigned char*, unsigned char*, unsigned long)>
    3d42:	88 85       	ldd	r24, Y+8	; 0x08
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:673
  setAll(r, g, b);
    3d44:	99 85       	ldd	r25, Y+9	; 0x09
    3d46:	2a 85       	ldd	r18, Y+10	; 0x0a
    3d48:	e6 e2       	ldi	r30, 0x26	; 38
    3d4a:	f8 e4       	ldi	r31, 0x48	; 72
setAll():
    3d4c:	20 83       	st	Z, r18
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:686
}


void setAll(byte r, byte g, byte b) {
  for (unsigned int i = 0; i < ((LENGTH) * 3); i += 3) {
    pixels[i] = r;
    3d4e:	91 83       	std	Z+1, r25	; 0x01
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:687
    pixels[i + 1] = g;
    3d50:	82 83       	std	Z+2, r24	; 0x02
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:688
    pixels[i + 2] = b;
    3d52:	33 96       	adiw	r30, 0x03	; 3
    3d54:	42 e0       	ldi	r20, 0x02	; 2
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:685
  pushPixel(r, g, b, currentValueRight[currentMode == 4 ? 2 : 3]);
}


void setAll(byte r, byte g, byte b) {
  for (unsigned int i = 0; i < ((LENGTH) * 3); i += 3) {
    3d56:	5e e4       	ldi	r21, 0x4E	; 78
    3d58:	4e 17       	cp	r20, r30
    3d5a:	5f 07       	cpc	r21, r31
    3d5c:	b9 f7       	brne	.-18     	; 0x3d4c <main+0x10c2>
    3d5e:	6d cb       	rjmp	.-2342   	; 0x343a <main+0x7b0>
updatePattern():
    3d60:	0a 30       	cpi	r16, 0x0A	; 10
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:607
    updatePatternWave();
  } else if (currentMode == 8) {
    updatePatternDots2();
  } else if (currentMode == 9) {
    updatePatternFade2();
  } else if (currentMode == 10) {
    3d62:	09 f0       	breq	.+2      	; 0x3d66 <main+0x10dc>
    3d64:	ce c0       	rjmp	.+412    	; 0x3f02 <main+0x1278>
updatePatternDrift2():
    3d66:	90 90 81 47 	lds	r9, 0x4781	; 0x804781 <currentValueRight>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:750
  }
  }

*/
void updatePatternDrift2() {
  byte driftchance = 16 + currentValueRight[0] * 10;
    3d6a:	90 9e       	mul	r9, r16
    3d6c:	00 2d       	mov	r16, r0
    3d6e:	11 24       	eor	r1, r1
    3d70:	a0 e1       	ldi	r26, 0x10	; 16
    3d72:	9a 2e       	mov	r9, r26
    3d74:	90 0e       	add	r9, r16
    3d76:	89 2c       	mov	r8, r9
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:751
  byte randinc = 255 - driftchance;
    3d78:	80 94       	com	r8
    3d7a:	0e 94 c0 07 	call	0xf80	; 0xf80 <getPalleteNumber()>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:753
  byte randdec = driftchance;
  uint16_t len = (pgm_read_byte_near(&colorCount[getPalleteNumber()]) * (getDwellFrames() + getTransitionFrames()));
    3d7e:	e8 2f       	mov	r30, r24
    3d80:	f0 e0       	ldi	r31, 0x00	; 0
    3d82:	e7 5b       	subi	r30, 0xB7	; 183
    3d84:	f8 4f       	sbci	r31, 0xF8	; 248
    3d86:	f4 90       	lpm	r15, Z
    3d88:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <getDwellFrames()>
    3d8c:	8c 01       	movw	r16, r24
    3d8e:	0e 94 c9 07 	call	0xf92	; 0xf92 <getTransitionFrames()>
    3d92:	80 0f       	add	r24, r16
    3d94:	91 1f       	adc	r25, r17
    3d96:	f8 9e       	mul	r15, r24
    3d98:	50 01       	movw	r10, r0
    3d9a:	f9 9e       	mul	r15, r25
    3d9c:	b0 0c       	add	r11, r0
    3d9e:	11 24       	eor	r1, r1
    3da0:	b6 e2       	ldi	r27, 0x26	; 38
    3da2:	cb 2e       	mov	r12, r27
    3da4:	b8 e4       	ldi	r27, 0x48	; 72
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:754
  for (uint16_t i = 0; i < LENGTH; i += 2) {
    3da6:	db 2e       	mov	r13, r27
main():
    3da8:	71 2c       	mov	r7, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:770
      if (f1 > len) {
        f1 = len;
      }
    }
    rand = rand >> 8;
    if (rand > randinc) {
    3daa:	61 2c       	mov	r6, r1
updatePatternDrift2():
    3dac:	88 2d       	mov	r24, r8
    3dae:	90 e0       	ldi	r25, 0x00	; 0
    3db0:	8d 87       	std	Y+13, r24	; 0x0d
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:775
      f2++;
      if (f2 > len) {
        f2 = 0;
      }
    } else if (rand < randdec) {
    3db2:	9e 87       	std	Y+14, r25	; 0x0e
    3db4:	e9 2d       	mov	r30, r9
    3db6:	f0 e0       	ldi	r31, 0x00	; 0
    3db8:	ef 87       	std	Y+15, r30	; 0x0f
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/WMath.cpp:40
    3dba:	f8 8b       	std	Y+16, r31	; 0x10
random():
    3dbc:	e2 d1       	rcall	.+964    	; 0x4182 <random>
    3dbe:	2f ef       	ldi	r18, 0xFF	; 255
    3dc0:	3f ef       	ldi	r19, 0xFF	; 255
    3dc2:	40 e0       	ldi	r20, 0x00	; 0
    3dc4:	50 e0       	ldi	r21, 0x00	; 0
    3dc6:	32 d2       	rcall	.+1124   	; 0x422c <__divmodsi4>
updatePatternDrift2():
    3dc8:	c6 01       	movw	r24, r12
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:756
  byte randinc = 255 - driftchance;
  byte randdec = driftchance;
  uint16_t len = (pgm_read_byte_near(&colorCount[getPalleteNumber()]) * (getDwellFrames() + getTransitionFrames()));
  for (uint16_t i = 0; i < LENGTH; i += 2) {
    uint16_t rand = random(65535);
    uint16_t f1 = scratch[(i * 3) >> 1] + ((scratch[(i >> 1) * 3 + 2] & 0x0F) << 8);
    3dca:	86 52       	subi	r24, 0x26	; 38
    3dcc:	98 44       	sbci	r25, 0x48	; 72
    3dce:	96 95       	lsr	r25
    3dd0:	87 95       	ror	r24
    3dd2:	93 01       	movw	r18, r6
    3dd4:	36 95       	lsr	r19
    3dd6:	27 95       	ror	r18
    3dd8:	f9 01       	movw	r30, r18
    3dda:	ee 0f       	add	r30, r30
    3ddc:	ff 1f       	adc	r31, r31
    3dde:	e2 0f       	add	r30, r18
    3de0:	f3 1f       	adc	r31, r19
    3de2:	9f 01       	movw	r18, r30
    3de4:	25 56       	subi	r18, 0x65	; 101
    3de6:	3e 4b       	sbci	r19, 0xBE	; 190
    3de8:	29 8b       	std	Y+17, r18	; 0x11
    3dea:	3a 8b       	std	Y+18, r19	; 0x12
    3dec:	f9 01       	movw	r30, r18
    3dee:	e0 80       	ld	r14, Z
    3df0:	f1 2c       	mov	r15, r1
    3df2:	1e 2d       	mov	r17, r14
    3df4:	00 27       	eor	r16, r16
    3df6:	00 27       	eor	r16, r16
    3df8:	1f 70       	andi	r17, 0x0F	; 15
    3dfa:	dc 01       	movw	r26, r24
    3dfc:	a7 56       	subi	r26, 0x67	; 103
    3dfe:	be 4b       	sbci	r27, 0xBE	; 190
    3e00:	2c 91       	ld	r18, X
    3e02:	02 0f       	add	r16, r18
    3e04:	11 1d       	adc	r17, r1
    3e06:	f4 e0       	ldi	r31, 0x04	; 4
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:757
    uint16_t f2 = scratch[1 + ((i * 3) >> 1)] + ((scratch[(i >> 1) * 3 + 2] & 0xF0) << 4);
    3e08:	ee 0c       	add	r14, r14
    3e0a:	ff 1c       	adc	r15, r15
    3e0c:	fa 95       	dec	r31
    3e0e:	e1 f7       	brne	.-8      	; 0x3e08 <main+0x117e>
    3e10:	ee 24       	eor	r14, r14
    3e12:	ff e0       	ldi	r31, 0x0F	; 15
    3e14:	ff 22       	and	r15, r31
    3e16:	86 56       	subi	r24, 0x66	; 102
    3e18:	9e 4b       	sbci	r25, 0xBE	; 190
    3e1a:	fc 01       	movw	r30, r24
    3e1c:	20 81       	ld	r18, Z
    3e1e:	e2 0e       	add	r14, r18
    3e20:	f1 1c       	adc	r15, r1
    3e22:	86 16       	cp	r8, r22
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:758
    if ((byte)rand > randinc) {
    3e24:	08 f0       	brcs	.+2      	; 0x3e28 <main+0x119e>
    3e26:	4b c0       	rjmp	.+150    	; 0x3ebe <main+0x1234>
    3e28:	0f 5f       	subi	r16, 0xFF	; 255
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:759
      f1++;
    3e2a:	1f 4f       	sbci	r17, 0xFF	; 255
    3e2c:	a0 16       	cp	r10, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:760
      if (f1 > len) {
    3e2e:	b1 06       	cpc	r11, r17
    3e30:	08 f4       	brcc	.+2      	; 0x3e34 <main+0x11aa>
    3e32:	50 c0       	rjmp	.+160    	; 0x3ed4 <main+0x124a>
    3e34:	7b 87       	std	Y+11, r23	; 0x0b
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:769
      f1--;
      if (f1 > len) {
        f1 = len;
      }
    }
    rand = rand >> 8;
    3e36:	1c 86       	std	Y+12, r1	; 0x0c
    3e38:	2b 85       	ldd	r18, Y+11	; 0x0b
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:770
    if (rand > randinc) {
    3e3a:	3c 85       	ldd	r19, Y+12	; 0x0c
    3e3c:	4d 85       	ldd	r20, Y+13	; 0x0d
    3e3e:	5e 85       	ldd	r21, Y+14	; 0x0e
    3e40:	42 17       	cp	r20, r18
    3e42:	53 07       	cpc	r21, r19
    3e44:	08 f0       	brcs	.+2      	; 0x3e48 <main+0x11be>
    3e46:	49 c0       	rjmp	.+146    	; 0x3eda <main+0x1250>
    3e48:	5f ef       	ldi	r21, 0xFF	; 255
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:771
      f2++;
    3e4a:	e5 1a       	sub	r14, r21
    3e4c:	f5 0a       	sbc	r15, r21
    3e4e:	ae 14       	cp	r10, r14
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:772
      if (f2 > len) {
    3e50:	bf 04       	cpc	r11, r15
    3e52:	08 f4       	brcc	.+2      	; 0x3e56 <main+0x11cc>
    3e54:	53 c0       	rjmp	.+166    	; 0x3efc <main+0x1272>
    3e56:	0c 93       	st	X, r16
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:781
      f2--;
      if (f2 > len) {
        f2 = len;
      }
    }
    scratch[(i * 3) >> 1] = f1 & 0xFF;
    3e58:	fc 01       	movw	r30, r24
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:782
    scratch[1 + ((i * 3) >> 1)] = f2 & 0xFF;
    3e5a:	e0 82       	st	Z, r14
    3e5c:	81 2f       	mov	r24, r17
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:783
    scratch[(i >> 1) * 3 + 2] = (f1 >> 8) & ((f2 >> 4) & 0xF0);
    3e5e:	80 7f       	andi	r24, 0xF0	; 240
    3e60:	97 01       	movw	r18, r14
    3e62:	94 e0       	ldi	r25, 0x04	; 4
    3e64:	36 95       	lsr	r19
    3e66:	27 95       	ror	r18
    3e68:	9a 95       	dec	r25
    3e6a:	e1 f7       	brne	.-8      	; 0x3e64 <main+0x11da>
    3e6c:	82 23       	and	r24, r18
    3e6e:	e9 89       	ldd	r30, Y+17	; 0x11
    3e70:	fa 89       	ldd	r31, Y+18	; 0x12
    3e72:	80 83       	st	Z, r24
    3e74:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:784
    getDrift2Colors(&pixels[i * 3], &pixels[i * 3] + 1, &pixels[i * 3] + 2, f1);
    3e76:	20 e0       	ldi	r18, 0x00	; 0
    3e78:	a6 01       	movw	r20, r12
    3e7a:	4e 5f       	subi	r20, 0xFE	; 254
    3e7c:	5f 4f       	sbci	r21, 0xFF	; 255
    3e7e:	b6 01       	movw	r22, r12
    3e80:	6f 5f       	subi	r22, 0xFF	; 255
    3e82:	7f 4f       	sbci	r23, 0xFF	; 255
    3e84:	c6 01       	movw	r24, r12
    3e86:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)>
    3e8a:	87 01       	movw	r16, r14
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:785
    getDrift2Colors(&pixels[i * 3] + 3, &pixels[i * 3] + 4, &pixels[i * 3] + 5, f2);
    3e8c:	30 e0       	ldi	r19, 0x00	; 0
    3e8e:	20 e0       	ldi	r18, 0x00	; 0
    3e90:	a6 01       	movw	r20, r12
    3e92:	4b 5f       	subi	r20, 0xFB	; 251
    3e94:	5f 4f       	sbci	r21, 0xFF	; 255
    3e96:	b6 01       	movw	r22, r12
    3e98:	6c 5f       	subi	r22, 0xFC	; 252
    3e9a:	7f 4f       	sbci	r23, 0xFF	; 255
    3e9c:	c6 01       	movw	r24, r12
    3e9e:	03 96       	adiw	r24, 0x03	; 3
    3ea0:	0e 94 f2 07 	call	0xfe4	; 0xfe4 <getDrift2Colors(unsigned char*, unsigned char*, unsigned char*, unsigned long)>
    3ea4:	f2 e0       	ldi	r31, 0x02	; 2
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:754
void updatePatternDrift2() {
  byte driftchance = 16 + currentValueRight[0] * 10;
  byte randinc = 255 - driftchance;
  byte randdec = driftchance;
  uint16_t len = (pgm_read_byte_near(&colorCount[getPalleteNumber()]) * (getDwellFrames() + getTransitionFrames()));
  for (uint16_t i = 0; i < LENGTH; i += 2) {
    3ea6:	6f 0e       	add	r6, r31
    3ea8:	71 1c       	adc	r7, r1
    3eaa:	26 e0       	ldi	r18, 0x06	; 6
    3eac:	c2 0e       	add	r12, r18
    3eae:	d1 1c       	adc	r13, r1
    3eb0:	34 ef       	ldi	r19, 0xF4	; 244
    3eb2:	63 16       	cp	r6, r19
    3eb4:	31 e0       	ldi	r19, 0x01	; 1
    3eb6:	73 06       	cpc	r7, r19
    3eb8:	09 f0       	breq	.+2      	; 0x3ebc <main+0x1232>
    3eba:	80 cf       	rjmp	.-256    	; 0x3dbc <main+0x1132>
    3ebc:	be ca       	rjmp	.-2692   	; 0x343a <main+0x7b0>
    3ebe:	69 15       	cp	r22, r9
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:763
    if ((byte)rand > randinc) {
      f1++;
      if (f1 > len) {
        f1 = 0;
      }
    } else if ((byte)rand < randdec) {
    3ec0:	08 f0       	brcs	.+2      	; 0x3ec4 <main+0x123a>
    3ec2:	b8 cf       	rjmp	.-144    	; 0x3e34 <main+0x11aa>
    3ec4:	01 50       	subi	r16, 0x01	; 1
    3ec6:	11 09       	sbc	r17, r1
    3ec8:	a0 16       	cp	r10, r16
    3eca:	b1 06       	cpc	r11, r17
    3ecc:	08 f0       	brcs	.+2      	; 0x3ed0 <main+0x1246>
    3ece:	b2 cf       	rjmp	.-156    	; 0x3e34 <main+0x11aa>
    3ed0:	85 01       	movw	r16, r10
    3ed2:	b0 cf       	rjmp	.-160    	; 0x3e34 <main+0x11aa>
main():
    3ed4:	10 e0       	ldi	r17, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:761
    uint16_t f1 = scratch[(i * 3) >> 1] + ((scratch[(i >> 1) * 3 + 2] & 0x0F) << 8);
    uint16_t f2 = scratch[1 + ((i * 3) >> 1)] + ((scratch[(i >> 1) * 3 + 2] & 0xF0) << 4);
    if ((byte)rand > randinc) {
      f1++;
      if (f1 > len) {
        f1 = 0;
    3ed6:	00 e0       	ldi	r16, 0x00	; 0
    3ed8:	ad cf       	rjmp	.-166    	; 0x3e34 <main+0x11aa>
updatePatternDrift2():
    3eda:	eb 85       	ldd	r30, Y+11	; 0x0b
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:775
    if (rand > randinc) {
      f2++;
      if (f2 > len) {
        f2 = 0;
      }
    } else if (rand < randdec) {
    3edc:	fc 85       	ldd	r31, Y+12	; 0x0c
    3ede:	2f 85       	ldd	r18, Y+15	; 0x0f
    3ee0:	38 89       	ldd	r19, Y+16	; 0x10
    3ee2:	e2 17       	cp	r30, r18
    3ee4:	f3 07       	cpc	r31, r19
    3ee6:	08 f0       	brcs	.+2      	; 0x3eea <main+0x1260>
    3ee8:	b6 cf       	rjmp	.-148    	; 0x3e56 <main+0x11cc>
    3eea:	31 e0       	ldi	r19, 0x01	; 1
    3eec:	e3 1a       	sub	r14, r19
    3eee:	f1 08       	sbc	r15, r1
    3ef0:	ae 14       	cp	r10, r14
    3ef2:	bf 04       	cpc	r11, r15
    3ef4:	08 f0       	brcs	.+2      	; 0x3ef8 <main+0x126e>
    3ef6:	af cf       	rjmp	.-162    	; 0x3e56 <main+0x11cc>
    3ef8:	75 01       	movw	r14, r10
    3efa:	ad cf       	rjmp	.-166    	; 0x3e56 <main+0x11cc>
main():
    3efc:	f1 2c       	mov	r15, r1
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:773
    }
    rand = rand >> 8;
    if (rand > randinc) {
      f2++;
      if (f2 > len) {
        f2 = 0;
    3efe:	e1 2c       	mov	r14, r1
    3f00:	aa cf       	rjmp	.-172    	; 0x3e56 <main+0x11cc>
updatePattern():
    3f02:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:610
  } else if (currentMode == 9) {
    updatePatternFade2();
  } else if (currentMode == 10) {
    updatePatternDrift2();
  } else {
    setMode(0);
    3f04:	0e 94 bf 12 	call	0x257e	; 0x257e <setMode(unsigned char)>
    3f08:	98 ca       	rjmp	.-2768   	; 0x343a <main+0x7b0>
loop():
    3f0a:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:258
  if (!updated) {
    digitalWriteFast(INDICATE1,HIGH);
    updatePattern();
    digitalWriteFast(INDICATE1,LOW);
    updated = 1;
  } else if (millis() - lastFrameAt > getFrameDelay()) {
    3f0e:	c0 90 8a 47 	lds	r12, 0x478A	; 0x80478a <lastFrameAt>
    3f12:	d0 90 8b 47 	lds	r13, 0x478B	; 0x80478b <lastFrameAt+0x1>
    3f16:	e0 90 8c 47 	lds	r14, 0x478C	; 0x80478c <lastFrameAt+0x2>
    3f1a:	f0 90 8d 47 	lds	r15, 0x478D	; 0x80478d <lastFrameAt+0x3>
    3f1e:	ab 01       	movw	r20, r22
    3f20:	bc 01       	movw	r22, r24
    3f22:	4c 19       	sub	r20, r12
    3f24:	5d 09       	sbc	r21, r13
    3f26:	6e 09       	sbc	r22, r14
    3f28:	7f 09       	sbc	r23, r15
main():
    3f2a:	80 e5       	ldi	r24, 0x50	; 80
getFrameDelay():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:269
  }
}

byte getFrameDelay() {
  if (currentMode == 1 || currentMode == 0) {
    return 80;
    3f2c:	02 30       	cpi	r16, 0x02	; 2
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:268
    digitalWriteFast(INDICATE0,LOW);
  }
}

byte getFrameDelay() {
  if (currentMode == 1 || currentMode == 0) {
    3f2e:	70 f0       	brcs	.+28     	; 0x3f4c <main+0x12c2>
    3f30:	03 30       	cpi	r16, 0x03	; 3
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:270
    return 80;
  } else if (currentMode == 3) {
    3f32:	09 f0       	breq	.+2      	; 0x3f36 <main+0x12ac>
    3f34:	8f c0       	rjmp	.+286    	; 0x4054 <nextbyte24+0x2e>
    3f36:	ec e6       	ldi	r30, 0x6C	; 108
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:271
    return 30 + 10 * (pgm_read_byte_near(&maxValueRight[currentMode][0]) - currentValueRight[0]);
    3f38:	f7 e0       	ldi	r31, 0x07	; 7
    3f3a:	84 91       	lpm	r24, Z
    3f3c:	90 91 81 47 	lds	r25, 0x4781	; 0x804781 <currentValueRight>
    3f40:	89 1b       	sub	r24, r25
    3f42:	9a e0       	ldi	r25, 0x0A	; 10
    3f44:	89 9f       	mul	r24, r25
    3f46:	80 2d       	mov	r24, r0
    3f48:	11 24       	eor	r1, r1
    3f4a:	82 5e       	subi	r24, 0xE2	; 226
loop():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:273
  }
  return 30 + 20 * (pgm_read_byte_near(&maxValueRight[currentMode][0]) - currentValueRight[0]);
    3f4c:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:258
  if (!updated) {
    digitalWriteFast(INDICATE1,HIGH);
    updatePattern();
    digitalWriteFast(INDICATE1,LOW);
    updated = 1;
  } else if (millis() - lastFrameAt > getFrameDelay()) {
    3f4e:	b0 e0       	ldi	r27, 0x00	; 0
    3f50:	a0 e0       	ldi	r26, 0x00	; 0
    3f52:	84 17       	cp	r24, r20
    3f54:	95 07       	cpc	r25, r21
    3f56:	a6 07       	cpc	r26, r22
    3f58:	b7 07       	cpc	r27, r23
    3f5a:	08 f0       	brcs	.+2      	; 0x3f5e <main+0x12d4>
    3f5c:	bb c8       	rjmp	.-3722   	; 0x30d4 <main+0x44a>
    3f5e:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:259
    lastFrameAt = millis();
    3f62:	60 93 8a 47 	sts	0x478A, r22	; 0x80478a <lastFrameAt>
    3f66:	70 93 8b 47 	sts	0x478B, r23	; 0x80478b <lastFrameAt+0x1>
    3f6a:	80 93 8c 47 	sts	0x478C, r24	; 0x80478c <lastFrameAt+0x2>
    3f6e:	90 93 8d 47 	sts	0x478D, r25	; 0x80478d <lastFrameAt+0x3>
digitalWriteFast():
    3f72:	a8 9a       	sbi	0x15, 0	; 21
loop():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:444
  else if (val == CHANGE)
    vport->IN |= mask;
  else // HIGH
    vport->OUT |= mask;
    3f74:	10 92 8e 47 	sts	0x478E, r1	; 0x80478e <loop::updated>
show():
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:261
    digitalWriteFast(INDICATE0,HIGH);
    updated = 0;
    3f78:	80 91 08 4e 	lds	r24, 0x4E08	; 0x804e08 <leds+0x6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:76
}

// *INDENT-OFF*   astyle don't like assembly
void tinyNeoPixel::show(void) {

  if ((!pixels) || pin >= NUM_DIGITAL_PINS)  {
    3f7c:	90 91 09 4e 	lds	r25, 0x4E09	; 0x804e09 <leds+0x7>
    3f80:	89 2b       	or	r24, r25
    3f82:	09 f4       	brne	.+2      	; 0x3f86 <main+0x12fc>
    3f84:	65 c0       	rjmp	.+202    	; 0x4050 <nextbyte24+0x2a>
    3f86:	80 91 06 4e 	lds	r24, 0x4E06	; 0x804e06 <leds+0x4>
    3f8a:	89 32       	cpi	r24, 0x29	; 41
    3f8c:	0c f0       	brlt	.+2      	; 0x3f90 <main+0x1306>
    3f8e:	60 c0       	rjmp	.+192    	; 0x4050 <nextbyte24+0x2a>
_ZN12tinyNeoPixel7canShowEv.isra.0():
    3f90:	0e 94 8c 06 	call	0xd18	; 0xd18 <micros>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.h:298
             function instead.
  */
  static uint32_t gamma32(uint32_t x);

  #if (!defined(MILLIS_USE_TIMERNONE) && !defined(MILLIS_USE_TIMERRTC) && !defined(MILLIS_USE_TIMERRTC_XTAL) && !defined(MILLIS_USE_TIMERRTC_XOSC))
    inline bool canShow(void) { return (micros() - endTime) >= 50L; }
    3f94:	00 91 0e 4e 	lds	r16, 0x4E0E	; 0x804e0e <leds+0xc>
    3f98:	10 91 0f 4e 	lds	r17, 0x4E0F	; 0x804e0f <leds+0xd>
    3f9c:	20 91 10 4e 	lds	r18, 0x4E10	; 0x804e10 <leds+0xe>
    3fa0:	30 91 11 4e 	lds	r19, 0x4E11	; 0x804e11 <leds+0xf>
    3fa4:	60 1b       	sub	r22, r16
    3fa6:	71 0b       	sbc	r23, r17
    3fa8:	82 0b       	sbc	r24, r18
    3faa:	93 0b       	sbc	r25, r19
show():
    3fac:	62 33       	cpi	r22, 0x32	; 50
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:86
  // put a delay at the end of the function, the ending time is noted and
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  while (!canShow());
    3fae:	71 05       	cpc	r23, r1
    3fb0:	81 05       	cpc	r24, r1
    3fb2:	91 05       	cpc	r25, r1
    3fb4:	68 f3       	brcs	.-38     	; 0x3f90 <main+0x1306>
    3fb6:	f8 94       	cli
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:101
  // while data is being issued to the LEDs, so no other code will be
  // accessing the PORT.  The code takes an initial 'snapshot' of the PORT
  // state, computes 'pin high' and 'pin low' values, and writes these back
  // to the PORT register as needed.

  noInterrupts(); // Need 100% focus on instruction timing
    3fb8:	80 91 04 4e 	lds	r24, 0x4E04	; 0x804e04 <leds+0x2>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:111
  // Dx-series parts. This is by no means intended to imply that they will
  // run at those speeds, only that - if they do - you can control WS2812s
  // with them.

  volatile uint16_t
    i   = numBytes; // Loop counter
    3fbc:	90 91 05 4e 	lds	r25, 0x4E05	; 0x804e05 <leds+0x3>
    3fc0:	89 83       	std	Y+1, r24	; 0x01
    3fc2:	9a 83       	std	Y+2, r25	; 0x02
    3fc4:	a0 91 08 4e 	lds	r26, 0x4E08	; 0x804e08 <leds+0x6>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:113
  volatile uint8_t
   *ptr = pixels,   // Pointer to next byte
    3fc8:	b0 91 09 4e 	lds	r27, 0x4E09	; 0x804e09 <leds+0x7>
    3fcc:	fd 01       	movw	r30, r26
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:114
    b   = *ptr++,   // Current byte value
    3fce:	31 96       	adiw	r30, 0x01	; 1
    3fd0:	8c 91       	ld	r24, X
    3fd2:	8f 83       	std	Y+7, r24	; 0x07
    3fd4:	a0 91 12 4e 	lds	r26, 0x4E12	; 0x804e12 <leds+0x10>
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:485
    // 30 inst. clocks per bit: HHHHHHHxxxxxxxxLLLLLLLLLL
    // ST instructions:         ^      ^       ^       (T=0,9,18)

    volatile uint8_t next, bit;

    hi   = *port |  pinMask;
    3fd8:	b0 91 13 4e 	lds	r27, 0x4E13	; 0x804e13 <leds+0x11>
    3fdc:	9c 91       	ld	r25, X
    3fde:	80 91 14 4e 	lds	r24, 0x4E14	; 0x804e14 <leds+0x12>
    3fe2:	98 2b       	or	r25, r24
    3fe4:	9e 83       	std	Y+6, r25	; 0x06
    3fe6:	9c 91       	ld	r25, X
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:486
    lo   = *port & ~pinMask;
    3fe8:	80 95       	com	r24
    3fea:	89 23       	and	r24, r25
    3fec:	8d 83       	std	Y+5, r24	; 0x05
    3fee:	8d 81       	ldd	r24, Y+5	; 0x05
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:487
    next = lo;
    3ff0:	8c 83       	std	Y+4, r24	; 0x04
    3ff2:	88 e0       	ldi	r24, 0x08	; 8
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:488
    bit  = 8;
    3ff4:	8b 83       	std	Y+3, r24	; 0x03
    3ff6:	5e 81       	ldd	r21, Y+6	; 0x06
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:525
      [bit]   "+d" (bit),   /* euhm, no this can't be "any register" if you're gonna LDI to it. */
      [next]  "+r" (next),
      [count] "+w" (i)
    : [port]   "e" (port),  /* We're overwriting the SFR it's pointed at, not to the address of that register. */
      [hi]     "r" (hi),
      [lo]     "r" (lo));
    3ff8:	6d 81       	ldd	r22, Y+5	; 0x05
    3ffa:	4f 81       	ldd	r20, Y+7	; 0x07
    3ffc:	3b 81       	ldd	r19, Y+3	; 0x03
    3ffe:	2c 81       	ldd	r18, Y+4	; 0x04
    4000:	89 81       	ldd	r24, Y+1	; 0x01
    4002:	9a 81       	ldd	r25, Y+2	; 0x02

00004004 <head24>:
    4004:	00 c0       	rjmp	.+0      	; 0x4006 <head24+0x2>
    4006:	5c 93       	st	X, r21
    4008:	47 fd       	sbrc	r20, 7
    400a:	25 2f       	mov	r18, r21
    400c:	44 1f       	adc	r20, r20
    400e:	3a 95       	dec	r19
    4010:	00 c0       	rjmp	.+0      	; 0x4012 <head24+0xe>
    4012:	2c 93       	st	X, r18
    4014:	00 c0       	rjmp	.+0      	; 0x4016 <head24+0x12>
    4016:	26 2f       	mov	r18, r22
    4018:	05 d0       	rcall	.+10     	; 0x4024 <smallerdelay24>
    401a:	6c 93       	st	X, r22
    401c:	21 f0       	breq	.+8      	; 0x4026 <nextbyte24>
    401e:	01 d0       	rcall	.+2      	; 0x4022 <seconddelay24>
    4020:	f1 cf       	rjmp	.-30     	; 0x4004 <head24>

00004022 <seconddelay24>:
    4022:	00 c0       	rjmp	.+0      	; 0x4024 <smallerdelay24>

00004024 <smallerdelay24>:
    4024:	08 95       	ret

00004026 <nextbyte24>:
    4026:	38 e0       	ldi	r19, 0x08	; 8
    4028:	41 91       	ld	r20, Z+
    402a:	00 c0       	rjmp	.+0      	; 0x402c <nextbyte24+0x6>
    402c:	01 97       	sbiw	r24, 0x01	; 1
    402e:	51 f7       	brne	.-44     	; 0x4004 <head24>
    4030:	4f 83       	std	Y+7, r20	; 0x07
    4032:	3b 83       	std	Y+3, r19	; 0x03
    4034:	2c 83       	std	Y+4, r18	; 0x04
    4036:	89 83       	std	Y+1, r24	; 0x01
    4038:	9a 83       	std	Y+2, r25	; 0x02
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:815
#endif

  // END AVR ----------------------------------------------------------------


  interrupts();
    403a:	78 94       	sei
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\tinyNeoPixel_Static/tinyNeoPixel_Static.cpp:817
  #if (!defined(MILLIS_USE_TIMERNONE) && !defined(MILLIS_USE_TIMERRTC) && !defined(MILLIS_USE_TIMERRTC_XTAL) && !defined(MILLIS_USE_TIMERRTC_XOSC))
    endTime = micros();
    403c:	0e 94 8c 06 	call	0xd18	; 0xd18 <micros>
    4040:	60 93 0e 4e 	sts	0x4E0E, r22	; 0x804e0e <leds+0xc>
    4044:	70 93 0f 4e 	sts	0x4E0F, r23	; 0x804e0f <leds+0xd>
    4048:	80 93 10 4e 	sts	0x4E10, r24	; 0x804e10 <leds+0xe>
    404c:	90 93 11 4e 	sts	0x4E11, r25	; 0x804e11 <leds+0xf>
digitalWriteFast():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\cores\dxcore/wiring_digital.c:440
    vport->OUT &= ~mask;
  else // CHANGE
    vport->IN = mask;
*/
  if (val == LOW)
    vport->OUT &= ~mask;
    4050:	a8 98       	cbi	0x15, 0	; 21
    4052:	40 c8       	rjmp	.-3968   	; 0x30d4 <main+0x44a>
getFrameDelay():
    4054:	28 e0       	ldi	r18, 0x08	; 8
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:273
  if (currentMode == 1 || currentMode == 0) {
    return 80;
  } else if (currentMode == 3) {
    return 30 + 10 * (pgm_read_byte_near(&maxValueRight[currentMode][0]) - currentValueRight[0]);
  }
  return 30 + 20 * (pgm_read_byte_near(&maxValueRight[currentMode][0]) - currentValueRight[0]);
    4056:	02 9f       	mul	r16, r18
    4058:	f0 01       	movw	r30, r0
    405a:	11 24       	eor	r1, r1
    405c:	ec 5a       	subi	r30, 0xAC	; 172
    405e:	f8 4f       	sbci	r31, 0xF8	; 248
    4060:	84 91       	lpm	r24, Z
    4062:	90 91 81 47 	lds	r25, 0x4781	; 0x804781 <currentValueRight>
    4066:	e8 2f       	mov	r30, r24
    4068:	e9 1b       	sub	r30, r25
    406a:	84 e1       	ldi	r24, 0x14	; 20
    406c:	e8 9f       	mul	r30, r24
    406e:	80 2d       	mov	r24, r0
    4070:	11 24       	eor	r1, r1
    4072:	6b cf       	rjmp	.-298    	; 0x3f4a <main+0x12c0>
handleUI():
    4074:	0e 94 01 07 	call	0xe02	; 0xe02 <millis>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:425
            lcd.print(F("Saved mode"));
            lcd.setCursor(5, 1);
            lcd.print(F("cleared"));
            delay(1000);
            UIChanged = 7;
          } else if (lastPressAt && millis() - lastPressAt > 3000) {
    4078:	68 19       	sub	r22, r8
    407a:	79 09       	sbc	r23, r9
    407c:	8a 09       	sbc	r24, r10
    407e:	9b 09       	sbc	r25, r11
    4080:	69 3b       	cpi	r22, 0xB9	; 185
    4082:	7b 40       	sbci	r23, 0x0B	; 11
    4084:	81 05       	cpc	r24, r1
    4086:	91 05       	cpc	r25, r1
    4088:	08 f4       	brcc	.+2      	; 0x408c <nextbyte24+0x66>
    408a:	4a c9       	rjmp	.-3436   	; 0x3320 <main+0x696>
    408c:	60 91 89 47 	lds	r22, 0x4789	; 0x804789 <currentMode>
_ZN5EERefC2Eh():
    4090:	8f e0       	ldi	r24, 0x0F	; 15
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:43
 */

struct EERef {

  EERef(const uint8_t index)
    : index(index)                 {}
    4092:	88 87       	std	Y+8, r24	; 0x08
_ZN11EEPROMClass5writeEhh.isra.5():
    4094:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:221
  }
  uint8_t read(uint8_t idx)              {
    return EERef(idx);
  }
  void write(uint8_t idx, uint8_t val)   {
    (EERef(idx)) = val;
    4096:	08 96       	adiw	r24, 0x08	; 8
    4098:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <EERef::operator=(unsigned char)>
    409c:	30 e1       	ldi	r19, 0x10	; 16
    409e:	e3 2e       	mov	r14, r19
    40a0:	d1 2c       	mov	r13, r1
    40a2:	c1 2c       	mov	r12, r1
saveMode():
    40a4:	f6 01       	movw	r30, r12
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:366


void saveMode() {
  EEPROM.write(0x0F, currentMode);
  for (byte i = 0; i < 8; i++) {
    EEPROM.write(0x10 + i, currentValueLeft[i]);
    40a6:	e7 58       	subi	r30, 0x87	; 135
    40a8:	f8 4b       	sbci	r31, 0xB8	; 184
    40aa:	60 81       	ld	r22, Z
_ZN5EERefC2Eh():
    40ac:	e8 86       	std	Y+8, r14	; 0x08
_ZN11EEPROMClass5writeEhh.isra.5():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:43
 */

struct EERef {

  EERef(const uint8_t index)
    : index(index)                 {}
    40ae:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:221
  }
  uint8_t read(uint8_t idx)              {
    return EERef(idx);
  }
  void write(uint8_t idx, uint8_t val)   {
    (EERef(idx)) = val;
    40b0:	08 96       	adiw	r24, 0x08	; 8
    40b2:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <EERef::operator=(unsigned char)>
saveMode():
    40b6:	f6 01       	movw	r30, r12
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:367
    EEPROM.write(0x18 + i, currentValueRight[i]);
    40b8:	ef 57       	subi	r30, 0x7F	; 127
    40ba:	f8 4b       	sbci	r31, 0xB8	; 184
    40bc:	60 81       	ld	r22, Z
    40be:	88 e0       	ldi	r24, 0x08	; 8
    40c0:	8e 0d       	add	r24, r14
_ZN5EERefC2Eh():
    40c2:	88 87       	std	Y+8, r24	; 0x08
_ZN11EEPROMClass5writeEhh.isra.5():
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:43
 */

struct EERef {

  EERef(const uint8_t index)
    : index(index)                 {}
    40c4:	ce 01       	movw	r24, r28
C:\Users\Spence\Documents\Arduino\hardware\DxCore\megaavr\libraries\EEPROM\src/EEPROM.h:221
  }
  uint8_t read(uint8_t idx)              {
    return EERef(idx);
  }
  void write(uint8_t idx, uint8_t val)   {
    (EERef(idx)) = val;
    40c6:	08 96       	adiw	r24, 0x08	; 8
    40c8:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <EERef::operator=(unsigned char)>
    40cc:	4f ef       	ldi	r20, 0xFF	; 255
    40ce:	c4 1a       	sub	r12, r20
    40d0:	d4 0a       	sbc	r13, r20
    40d2:	e3 94       	inc	r14
saveMode():
    40d4:	58 e1       	ldi	r21, 0x18	; 24
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:365
}


void saveMode() {
  EEPROM.write(0x0F, currentMode);
  for (byte i = 0; i < 8; i++) {
    40d6:	e5 12       	cpse	r14, r21
    40d8:	e5 cf       	rjmp	.-54     	; 0x40a4 <nextbyte24+0x7e>
handleUI():
    40da:	0e 94 44 07 	call	0xe88	; 0xe88 <hd44780::clear() [clone .constprop.24]>
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:427
            lcd.print(F("cleared"));
            delay(1000);
            UIChanged = 7;
          } else if (lastPressAt && millis() - lastPressAt > 3000) {
            saveMode();
            lcd.clear();
    40de:	40 e0       	ldi	r20, 0x00	; 0
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:428
            lcd.setCursor(3, 0);
    40e0:	63 e0       	ldi	r22, 0x03	; 3
    40e2:	85 e1       	ldi	r24, 0x15	; 21
    40e4:	9e e4       	ldi	r25, 0x4E	; 78
    40e6:	0e 94 48 07 	call	0xe90	; 0xe90 <hd44780::setCursor(unsigned char, unsigned char)>
    40ea:	64 ec       	ldi	r22, 0xC4	; 196
C:\Users\Spence\Documents\Electronics\DriftAnimate\DriftAnimate_V2/DriftAnimate_V2.ino:429
            lcd.print(F("Mode Saved"));
    40ec:	74 e0       	ldi	r23, 0x04	; 4
    40ee:	0c c9       	rjmp	.-3560   	; 0x3308 <main+0x67e>

000040f0 <random_r>:
random_r():
    40f0:	8f 92       	push	r8
    40f2:	9f 92       	push	r9
    40f4:	af 92       	push	r10
    40f6:	bf 92       	push	r11
    40f8:	cf 92       	push	r12
    40fa:	df 92       	push	r13
    40fc:	ef 92       	push	r14
    40fe:	ff 92       	push	r15
    4100:	cf 93       	push	r28
    4102:	df 93       	push	r29
    4104:	ec 01       	movw	r28, r24
    4106:	68 81       	ld	r22, Y
    4108:	79 81       	ldd	r23, Y+1	; 0x01
    410a:	8a 81       	ldd	r24, Y+2	; 0x02
    410c:	9b 81       	ldd	r25, Y+3	; 0x03
    410e:	61 15       	cp	r22, r1
    4110:	71 05       	cpc	r23, r1
    4112:	81 05       	cpc	r24, r1
    4114:	91 05       	cpc	r25, r1
    4116:	21 f4       	brne	.+8      	; 0x4120 <random_r+0x30>
    4118:	64 e2       	ldi	r22, 0x24	; 36
    411a:	79 ed       	ldi	r23, 0xD9	; 217
    411c:	8b e5       	ldi	r24, 0x5B	; 91
    411e:	97 e0       	ldi	r25, 0x07	; 7
    4120:	2d e1       	ldi	r18, 0x1D	; 29
    4122:	33 ef       	ldi	r19, 0xF3	; 243
    4124:	41 e0       	ldi	r20, 0x01	; 1
    4126:	50 e0       	ldi	r21, 0x00	; 0
    4128:	81 d0       	rcall	.+258    	; 0x422c <__divmodsi4>
    412a:	49 01       	movw	r8, r18
    412c:	5a 01       	movw	r10, r20
    412e:	9b 01       	movw	r18, r22
    4130:	ac 01       	movw	r20, r24
    4132:	a7 ea       	ldi	r26, 0xA7	; 167
    4134:	b1 e4       	ldi	r27, 0x41	; 65
    4136:	96 d0       	rcall	.+300    	; 0x4264 <__muluhisi3>
    4138:	6b 01       	movw	r12, r22
    413a:	7c 01       	movw	r14, r24
    413c:	ac ee       	ldi	r26, 0xEC	; 236
    413e:	b4 ef       	ldi	r27, 0xF4	; 244
    4140:	a5 01       	movw	r20, r10
    4142:	94 01       	movw	r18, r8
    4144:	9b d0       	rcall	.+310    	; 0x427c <__mulohisi3>
    4146:	c6 0e       	add	r12, r22
    4148:	d7 1e       	adc	r13, r23
    414a:	e8 1e       	adc	r14, r24
    414c:	f9 1e       	adc	r15, r25
    414e:	f7 fe       	sbrs	r15, 7
    4150:	06 c0       	rjmp	.+12     	; 0x415e <random_r+0x6e>
    4152:	81 e0       	ldi	r24, 0x01	; 1
    4154:	c8 1a       	sub	r12, r24
    4156:	d1 08       	sbc	r13, r1
    4158:	e1 08       	sbc	r14, r1
    415a:	80 e8       	ldi	r24, 0x80	; 128
    415c:	f8 0a       	sbc	r15, r24
    415e:	c8 82       	st	Y, r12
    4160:	d9 82       	std	Y+1, r13	; 0x01
    4162:	ea 82       	std	Y+2, r14	; 0x02
    4164:	fb 82       	std	Y+3, r15	; 0x03
    4166:	c7 01       	movw	r24, r14
    4168:	b6 01       	movw	r22, r12
    416a:	9f 77       	andi	r25, 0x7F	; 127
    416c:	df 91       	pop	r29
    416e:	cf 91       	pop	r28
    4170:	ff 90       	pop	r15
    4172:	ef 90       	pop	r14
    4174:	df 90       	pop	r13
    4176:	cf 90       	pop	r12
    4178:	bf 90       	pop	r11
    417a:	af 90       	pop	r10
    417c:	9f 90       	pop	r9
    417e:	8f 90       	pop	r8
    4180:	08 95       	ret

00004182 <random>:
random():
    4182:	8f 92       	push	r8
    4184:	9f 92       	push	r9
    4186:	af 92       	push	r10
    4188:	bf 92       	push	r11
    418a:	cf 92       	push	r12
    418c:	df 92       	push	r13
    418e:	ef 92       	push	r14
    4190:	ff 92       	push	r15
    4192:	60 91 07 40 	lds	r22, 0x4007	; 0x804007 <next>
    4196:	70 91 08 40 	lds	r23, 0x4008	; 0x804008 <next+0x1>
    419a:	80 91 09 40 	lds	r24, 0x4009	; 0x804009 <next+0x2>
    419e:	90 91 0a 40 	lds	r25, 0x400A	; 0x80400a <next+0x3>
    41a2:	61 15       	cp	r22, r1
    41a4:	71 05       	cpc	r23, r1
    41a6:	81 05       	cpc	r24, r1
    41a8:	91 05       	cpc	r25, r1
    41aa:	21 f4       	brne	.+8      	; 0x41b4 <random+0x32>
    41ac:	64 e2       	ldi	r22, 0x24	; 36
    41ae:	79 ed       	ldi	r23, 0xD9	; 217
    41b0:	8b e5       	ldi	r24, 0x5B	; 91
    41b2:	97 e0       	ldi	r25, 0x07	; 7
    41b4:	2d e1       	ldi	r18, 0x1D	; 29
    41b6:	33 ef       	ldi	r19, 0xF3	; 243
    41b8:	41 e0       	ldi	r20, 0x01	; 1
    41ba:	50 e0       	ldi	r21, 0x00	; 0
    41bc:	37 d0       	rcall	.+110    	; 0x422c <__divmodsi4>
    41be:	49 01       	movw	r8, r18
    41c0:	5a 01       	movw	r10, r20
    41c2:	9b 01       	movw	r18, r22
    41c4:	ac 01       	movw	r20, r24
    41c6:	a7 ea       	ldi	r26, 0xA7	; 167
    41c8:	b1 e4       	ldi	r27, 0x41	; 65
    41ca:	4c d0       	rcall	.+152    	; 0x4264 <__muluhisi3>
    41cc:	6b 01       	movw	r12, r22
    41ce:	7c 01       	movw	r14, r24
    41d0:	ac ee       	ldi	r26, 0xEC	; 236
    41d2:	b4 ef       	ldi	r27, 0xF4	; 244
    41d4:	a5 01       	movw	r20, r10
    41d6:	94 01       	movw	r18, r8
    41d8:	51 d0       	rcall	.+162    	; 0x427c <__mulohisi3>
    41da:	c6 0e       	add	r12, r22
    41dc:	d7 1e       	adc	r13, r23
    41de:	e8 1e       	adc	r14, r24
    41e0:	f9 1e       	adc	r15, r25
    41e2:	f7 fe       	sbrs	r15, 7
    41e4:	06 c0       	rjmp	.+12     	; 0x41f2 <random+0x70>
    41e6:	81 e0       	ldi	r24, 0x01	; 1
    41e8:	c8 1a       	sub	r12, r24
    41ea:	d1 08       	sbc	r13, r1
    41ec:	e1 08       	sbc	r14, r1
    41ee:	80 e8       	ldi	r24, 0x80	; 128
    41f0:	f8 0a       	sbc	r15, r24
    41f2:	c0 92 07 40 	sts	0x4007, r12	; 0x804007 <next>
    41f6:	d0 92 08 40 	sts	0x4008, r13	; 0x804008 <next+0x1>
    41fa:	e0 92 09 40 	sts	0x4009, r14	; 0x804009 <next+0x2>
    41fe:	f0 92 0a 40 	sts	0x400A, r15	; 0x80400a <next+0x3>
    4202:	c7 01       	movw	r24, r14
    4204:	b6 01       	movw	r22, r12
    4206:	9f 77       	andi	r25, 0x7F	; 127
    4208:	ff 90       	pop	r15
    420a:	ef 90       	pop	r14
    420c:	df 90       	pop	r13
    420e:	cf 90       	pop	r12
    4210:	bf 90       	pop	r11
    4212:	af 90       	pop	r10
    4214:	9f 90       	pop	r9
    4216:	8f 90       	pop	r8
    4218:	08 95       	ret

0000421a <srandom>:
srandom():
    421a:	60 93 07 40 	sts	0x4007, r22	; 0x804007 <next>
    421e:	70 93 08 40 	sts	0x4008, r23	; 0x804008 <next+0x1>
    4222:	80 93 09 40 	sts	0x4009, r24	; 0x804009 <next+0x2>
    4226:	90 93 0a 40 	sts	0x400A, r25	; 0x80400a <next+0x3>
    422a:	08 95       	ret

0000422c <__divmodsi4>:
__divmodsi4():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
    422c:	05 2e       	mov	r0, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
    422e:	97 fb       	bst	r25, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
    4230:	16 f4       	brtc	.+4      	; 0x4236 <__divmodsi4+0xa>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
    4232:	00 94       	com	r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
    4234:	0f d0       	rcall	.+30     	; 0x4254 <__negsi2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
    4236:	57 fd       	sbrc	r21, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
    4238:	05 d0       	rcall	.+10     	; 0x4244 <__divmodsi4_neg2>
    423a:	24 d0       	rcall	.+72     	; 0x4284 <__udivmodsi4>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
    423c:	07 fc       	sbrc	r0, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
    423e:	02 d0       	rcall	.+4      	; 0x4244 <__divmodsi4_neg2>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
    4240:	46 f4       	brtc	.+16     	; 0x4252 <__divmodsi4_exit>
    4242:	08 c0       	rjmp	.+16     	; 0x4254 <__negsi2>

00004244 <__divmodsi4_neg2>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
    4244:	50 95       	com	r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
    4246:	40 95       	com	r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
    4248:	30 95       	com	r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
    424a:	21 95       	neg	r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
    424c:	3f 4f       	sbci	r19, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
    424e:	4f 4f       	sbci	r20, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
    4250:	5f 4f       	sbci	r21, 0xFF	; 255

00004252 <__divmodsi4_exit>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
    4252:	08 95       	ret

00004254 <__negsi2>:
__negsi2():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
    4254:	90 95       	com	r25
    4256:	80 95       	com	r24
    4258:	70 95       	com	r23
    425a:	61 95       	neg	r22
    425c:	7f 4f       	sbci	r23, 0xFF	; 255
    425e:	8f 4f       	sbci	r24, 0xFF	; 255
    4260:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
    4262:	08 95       	ret

00004264 <__muluhisi3>:
__muluhisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    4264:	31 d0       	rcall	.+98     	; 0x42c8 <__umulhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    4266:	a5 9f       	mul	r26, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    4268:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    426a:	b4 9f       	mul	r27, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    426c:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    426e:	a4 9f       	mul	r26, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    4270:	80 0d       	add	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    4272:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    4274:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    4276:	08 95       	ret

00004278 <__mulshisi3>:
__mulshisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    4278:	b7 ff       	sbrs	r27, 7
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    427a:	f4 cf       	rjmp	.-24     	; 0x4264 <__muluhisi3>

0000427c <__mulohisi3>:
__mulohisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    427c:	f3 df       	rcall	.-26     	; 0x4264 <__muluhisi3>
    427e:	82 1b       	sub	r24, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    4280:	93 0b       	sbc	r25, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    4282:	08 95       	ret

00004284 <__udivmodsi4>:
__udivmodsi4():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    4284:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    4286:	1a 2e       	mov	r1, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    4288:	aa 1b       	sub	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    428a:	bb 1b       	sub	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    428c:	fd 01       	movw	r30, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    428e:	0d c0       	rjmp	.+26     	; 0x42aa <__udivmodsi4_ep>

00004290 <__udivmodsi4_loop>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    4290:	aa 1f       	adc	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    4292:	bb 1f       	adc	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    4294:	ee 1f       	adc	r30, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    4296:	ff 1f       	adc	r31, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    4298:	a2 17       	cp	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    429a:	b3 07       	cpc	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    429c:	e4 07       	cpc	r30, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    429e:	f5 07       	cpc	r31, r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    42a0:	20 f0       	brcs	.+8      	; 0x42aa <__udivmodsi4_ep>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    42a2:	a2 1b       	sub	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    42a4:	b3 0b       	sbc	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    42a6:	e4 0b       	sbc	r30, r20
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    42a8:	f5 0b       	sbc	r31, r21

000042aa <__udivmodsi4_ep>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    42aa:	66 1f       	adc	r22, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    42ac:	77 1f       	adc	r23, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    42ae:	88 1f       	adc	r24, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    42b0:	99 1f       	adc	r25, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    42b2:	1a 94       	dec	r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    42b4:	69 f7       	brne	.-38     	; 0x4290 <__udivmodsi4_loop>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    42b6:	60 95       	com	r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    42b8:	70 95       	com	r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    42ba:	80 95       	com	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    42bc:	90 95       	com	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    42be:	9b 01       	movw	r18, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    42c0:	ac 01       	movw	r20, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    42c2:	bd 01       	movw	r22, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    42c4:	cf 01       	movw	r24, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    42c6:	08 95       	ret

000042c8 <__umulhisi3>:
__umulhisi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    42c8:	a2 9f       	mul	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    42ca:	b0 01       	movw	r22, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    42cc:	b3 9f       	mul	r27, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    42ce:	c0 01       	movw	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    42d0:	a3 9f       	mul	r26, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    42d2:	70 0d       	add	r23, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    42d4:	81 1d       	adc	r24, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    42d6:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    42d8:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    42da:	b2 9f       	mul	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    42dc:	70 0d       	add	r23, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    42de:	81 1d       	adc	r24, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    42e0:	11 24       	eor	r1, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    42e2:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    42e4:	08 95       	ret

000042e6 <__subsf3>:
__subsf3():
    42e6:	50 58       	subi	r21, 0x80	; 128

000042e8 <__addsf3>:
    42e8:	bb 27       	eor	r27, r27
    42ea:	aa 27       	eor	r26, r26
    42ec:	0e d0       	rcall	.+28     	; 0x430a <__addsf3x>
    42ee:	70 c1       	rjmp	.+736    	; 0x45d0 <__fp_round>
__addsf3():
    42f0:	61 d1       	rcall	.+706    	; 0x45b4 <__fp_pscA>
    42f2:	30 f0       	brcs	.+12     	; 0x4300 <__addsf3+0x18>
    42f4:	66 d1       	rcall	.+716    	; 0x45c2 <__fp_pscB>
    42f6:	20 f0       	brcs	.+8      	; 0x4300 <__addsf3+0x18>
    42f8:	31 f4       	brne	.+12     	; 0x4306 <__addsf3+0x1e>
    42fa:	9f 3f       	cpi	r25, 0xFF	; 255
    42fc:	11 f4       	brne	.+4      	; 0x4302 <__addsf3+0x1a>
    42fe:	1e f4       	brtc	.+6      	; 0x4306 <__addsf3+0x1e>
    4300:	56 c1       	rjmp	.+684    	; 0x45ae <__fp_nan>
    4302:	0e f4       	brtc	.+2      	; 0x4306 <__addsf3+0x1e>
    4304:	e0 95       	com	r30
    4306:	e7 fb       	bst	r30, 7
    4308:	4c c1       	rjmp	.+664    	; 0x45a2 <__fp_inf>

0000430a <__addsf3x>:
__addsf3x():
    430a:	e9 2f       	mov	r30, r25
    430c:	72 d1       	rcall	.+740    	; 0x45f2 <__fp_split3>
    430e:	80 f3       	brcs	.-32     	; 0x42f0 <__addsf3+0x8>
    4310:	ba 17       	cp	r27, r26
    4312:	62 07       	cpc	r22, r18
    4314:	73 07       	cpc	r23, r19
    4316:	84 07       	cpc	r24, r20
    4318:	95 07       	cpc	r25, r21
    431a:	18 f0       	brcs	.+6      	; 0x4322 <__addsf3x+0x18>
    431c:	71 f4       	brne	.+28     	; 0x433a <__addsf3x+0x30>
    431e:	9e f5       	brtc	.+102    	; 0x4386 <__addsf3x+0x7c>
    4320:	8a c1       	rjmp	.+788    	; 0x4636 <__fp_zero>
    4322:	0e f4       	brtc	.+2      	; 0x4326 <__addsf3x+0x1c>
    4324:	e0 95       	com	r30
    4326:	0b 2e       	mov	r0, r27
    4328:	ba 2f       	mov	r27, r26
    432a:	a0 2d       	mov	r26, r0
    432c:	0b 01       	movw	r0, r22
    432e:	b9 01       	movw	r22, r18
    4330:	90 01       	movw	r18, r0
    4332:	0c 01       	movw	r0, r24
    4334:	ca 01       	movw	r24, r20
    4336:	a0 01       	movw	r20, r0
    4338:	11 24       	eor	r1, r1
    433a:	ff 27       	eor	r31, r31
    433c:	59 1b       	sub	r21, r25
    433e:	99 f0       	breq	.+38     	; 0x4366 <__addsf3x+0x5c>
    4340:	59 3f       	cpi	r21, 0xF9	; 249
    4342:	50 f4       	brcc	.+20     	; 0x4358 <__addsf3x+0x4e>
    4344:	50 3e       	cpi	r21, 0xE0	; 224
    4346:	68 f1       	brcs	.+90     	; 0x43a2 <__addsf3x+0x98>
    4348:	1a 16       	cp	r1, r26
    434a:	f0 40       	sbci	r31, 0x00	; 0
    434c:	a2 2f       	mov	r26, r18
    434e:	23 2f       	mov	r18, r19
    4350:	34 2f       	mov	r19, r20
    4352:	44 27       	eor	r20, r20
    4354:	58 5f       	subi	r21, 0xF8	; 248
    4356:	f3 cf       	rjmp	.-26     	; 0x433e <__addsf3x+0x34>
    4358:	46 95       	lsr	r20
    435a:	37 95       	ror	r19
    435c:	27 95       	ror	r18
    435e:	a7 95       	ror	r26
    4360:	f0 40       	sbci	r31, 0x00	; 0
    4362:	53 95       	inc	r21
    4364:	c9 f7       	brne	.-14     	; 0x4358 <__addsf3x+0x4e>
    4366:	7e f4       	brtc	.+30     	; 0x4386 <__addsf3x+0x7c>
    4368:	1f 16       	cp	r1, r31
    436a:	ba 0b       	sbc	r27, r26
    436c:	62 0b       	sbc	r22, r18
    436e:	73 0b       	sbc	r23, r19
    4370:	84 0b       	sbc	r24, r20
    4372:	ba f0       	brmi	.+46     	; 0x43a2 <__addsf3x+0x98>
    4374:	91 50       	subi	r25, 0x01	; 1
    4376:	a1 f0       	breq	.+40     	; 0x43a0 <__addsf3x+0x96>
    4378:	ff 0f       	add	r31, r31
    437a:	bb 1f       	adc	r27, r27
    437c:	66 1f       	adc	r22, r22
    437e:	77 1f       	adc	r23, r23
    4380:	88 1f       	adc	r24, r24
    4382:	c2 f7       	brpl	.-16     	; 0x4374 <__addsf3x+0x6a>
    4384:	0e c0       	rjmp	.+28     	; 0x43a2 <__addsf3x+0x98>
    4386:	ba 0f       	add	r27, r26
    4388:	62 1f       	adc	r22, r18
    438a:	73 1f       	adc	r23, r19
    438c:	84 1f       	adc	r24, r20
    438e:	48 f4       	brcc	.+18     	; 0x43a2 <__addsf3x+0x98>
    4390:	87 95       	ror	r24
    4392:	77 95       	ror	r23
    4394:	67 95       	ror	r22
    4396:	b7 95       	ror	r27
    4398:	f7 95       	ror	r31
    439a:	9e 3f       	cpi	r25, 0xFE	; 254
    439c:	08 f0       	brcs	.+2      	; 0x43a0 <__addsf3x+0x96>
    439e:	b3 cf       	rjmp	.-154    	; 0x4306 <__addsf3+0x1e>
    43a0:	93 95       	inc	r25
    43a2:	88 0f       	add	r24, r24
    43a4:	08 f0       	brcs	.+2      	; 0x43a8 <__addsf3x+0x9e>
    43a6:	99 27       	eor	r25, r25
    43a8:	ee 0f       	add	r30, r30
    43aa:	97 95       	ror	r25
    43ac:	87 95       	ror	r24
    43ae:	08 95       	ret

000043b0 <__cmpsf2>:
    43b0:	d4 d0       	rcall	.+424    	; 0x455a <__fp_cmp>
    43b2:	08 f4       	brcc	.+2      	; 0x43b6 <__cmpsf2+0x6>
    43b4:	81 e0       	ldi	r24, 0x01	; 1
    43b6:	08 95       	ret

000043b8 <__divsf3>:
    43b8:	0c d0       	rcall	.+24     	; 0x43d2 <__divsf3x>
    43ba:	0a c1       	rjmp	.+532    	; 0x45d0 <__fp_round>
    43bc:	02 d1       	rcall	.+516    	; 0x45c2 <__fp_pscB>
    43be:	40 f0       	brcs	.+16     	; 0x43d0 <__divsf3+0x18>
    43c0:	f9 d0       	rcall	.+498    	; 0x45b4 <__fp_pscA>
    43c2:	30 f0       	brcs	.+12     	; 0x43d0 <__divsf3+0x18>
    43c4:	21 f4       	brne	.+8      	; 0x43ce <__divsf3+0x16>
    43c6:	5f 3f       	cpi	r21, 0xFF	; 255
    43c8:	19 f0       	breq	.+6      	; 0x43d0 <__divsf3+0x18>
    43ca:	eb c0       	rjmp	.+470    	; 0x45a2 <__fp_inf>
    43cc:	51 11       	cpse	r21, r1
    43ce:	34 c1       	rjmp	.+616    	; 0x4638 <__fp_szero>
    43d0:	ee c0       	rjmp	.+476    	; 0x45ae <__fp_nan>

000043d2 <__divsf3x>:
    43d2:	0f d1       	rcall	.+542    	; 0x45f2 <__fp_split3>
    43d4:	98 f3       	brcs	.-26     	; 0x43bc <__divsf3+0x4>

000043d6 <__divsf3_pse>:
__divsf3_pse():
    43d6:	99 23       	and	r25, r25
    43d8:	c9 f3       	breq	.-14     	; 0x43cc <__divsf3+0x14>
    43da:	55 23       	and	r21, r21
    43dc:	b1 f3       	breq	.-20     	; 0x43ca <__divsf3+0x12>
    43de:	95 1b       	sub	r25, r21
    43e0:	55 0b       	sbc	r21, r21
    43e2:	bb 27       	eor	r27, r27
    43e4:	aa 27       	eor	r26, r26
    43e6:	62 17       	cp	r22, r18
    43e8:	73 07       	cpc	r23, r19
    43ea:	84 07       	cpc	r24, r20
    43ec:	38 f0       	brcs	.+14     	; 0x43fc <__divsf3_pse+0x26>
    43ee:	9f 5f       	subi	r25, 0xFF	; 255
    43f0:	5f 4f       	sbci	r21, 0xFF	; 255
    43f2:	22 0f       	add	r18, r18
    43f4:	33 1f       	adc	r19, r19
    43f6:	44 1f       	adc	r20, r20
    43f8:	aa 1f       	adc	r26, r26
    43fa:	a9 f3       	breq	.-22     	; 0x43e6 <__divsf3_pse+0x10>
    43fc:	33 d0       	rcall	.+102    	; 0x4464 <__divsf3_pse+0x8e>
    43fe:	0e 2e       	mov	r0, r30
    4400:	3a f0       	brmi	.+14     	; 0x4410 <__divsf3_pse+0x3a>
    4402:	e0 e8       	ldi	r30, 0x80	; 128
    4404:	30 d0       	rcall	.+96     	; 0x4466 <__divsf3_pse+0x90>
    4406:	91 50       	subi	r25, 0x01	; 1
    4408:	50 40       	sbci	r21, 0x00	; 0
    440a:	e6 95       	lsr	r30
    440c:	00 1c       	adc	r0, r0
    440e:	ca f7       	brpl	.-14     	; 0x4402 <__divsf3_pse+0x2c>
    4410:	29 d0       	rcall	.+82     	; 0x4464 <__divsf3_pse+0x8e>
    4412:	fe 2f       	mov	r31, r30
    4414:	27 d0       	rcall	.+78     	; 0x4464 <__divsf3_pse+0x8e>
    4416:	66 0f       	add	r22, r22
    4418:	77 1f       	adc	r23, r23
    441a:	88 1f       	adc	r24, r24
    441c:	bb 1f       	adc	r27, r27
    441e:	26 17       	cp	r18, r22
    4420:	37 07       	cpc	r19, r23
    4422:	48 07       	cpc	r20, r24
    4424:	ab 07       	cpc	r26, r27
    4426:	b0 e8       	ldi	r27, 0x80	; 128
    4428:	09 f0       	breq	.+2      	; 0x442c <__divsf3_pse+0x56>
    442a:	bb 0b       	sbc	r27, r27
    442c:	80 2d       	mov	r24, r0
    442e:	bf 01       	movw	r22, r30
    4430:	ff 27       	eor	r31, r31
    4432:	93 58       	subi	r25, 0x83	; 131
    4434:	5f 4f       	sbci	r21, 0xFF	; 255
    4436:	2a f0       	brmi	.+10     	; 0x4442 <__divsf3_pse+0x6c>
    4438:	9e 3f       	cpi	r25, 0xFE	; 254
    443a:	51 05       	cpc	r21, r1
    443c:	68 f0       	brcs	.+26     	; 0x4458 <__divsf3_pse+0x82>
    443e:	b1 c0       	rjmp	.+354    	; 0x45a2 <__fp_inf>
    4440:	fb c0       	rjmp	.+502    	; 0x4638 <__fp_szero>
    4442:	5f 3f       	cpi	r21, 0xFF	; 255
    4444:	ec f3       	brlt	.-6      	; 0x4440 <__divsf3_pse+0x6a>
    4446:	98 3e       	cpi	r25, 0xE8	; 232
    4448:	dc f3       	brlt	.-10     	; 0x4440 <__divsf3_pse+0x6a>
    444a:	86 95       	lsr	r24
    444c:	77 95       	ror	r23
    444e:	67 95       	ror	r22
    4450:	b7 95       	ror	r27
    4452:	f7 95       	ror	r31
    4454:	9f 5f       	subi	r25, 0xFF	; 255
    4456:	c9 f7       	brne	.-14     	; 0x444a <__divsf3_pse+0x74>
    4458:	88 0f       	add	r24, r24
    445a:	91 1d       	adc	r25, r1
    445c:	96 95       	lsr	r25
    445e:	87 95       	ror	r24
    4460:	97 f9       	bld	r25, 7
    4462:	08 95       	ret
    4464:	e1 e0       	ldi	r30, 0x01	; 1
    4466:	66 0f       	add	r22, r22
    4468:	77 1f       	adc	r23, r23
    446a:	88 1f       	adc	r24, r24
    446c:	bb 1f       	adc	r27, r27
    446e:	62 17       	cp	r22, r18
    4470:	73 07       	cpc	r23, r19
    4472:	84 07       	cpc	r24, r20
    4474:	ba 07       	cpc	r27, r26
    4476:	20 f0       	brcs	.+8      	; 0x4480 <__divsf3_pse+0xaa>
    4478:	62 1b       	sub	r22, r18
    447a:	73 0b       	sbc	r23, r19
    447c:	84 0b       	sbc	r24, r20
    447e:	ba 0b       	sbc	r27, r26
    4480:	ee 1f       	adc	r30, r30
    4482:	88 f7       	brcc	.-30     	; 0x4466 <__divsf3_pse+0x90>
    4484:	e0 95       	com	r30
    4486:	08 95       	ret

00004488 <__fixunssfsi>:
__fixunssfsi():
    4488:	bc d0       	rcall	.+376    	; 0x4602 <__fp_splitA>
    448a:	88 f0       	brcs	.+34     	; 0x44ae <__fixunssfsi+0x26>
    448c:	9f 57       	subi	r25, 0x7F	; 127
    448e:	90 f0       	brcs	.+36     	; 0x44b4 <__fixunssfsi+0x2c>
    4490:	b9 2f       	mov	r27, r25
    4492:	99 27       	eor	r25, r25
    4494:	b7 51       	subi	r27, 0x17	; 23
    4496:	a0 f0       	brcs	.+40     	; 0x44c0 <__fixunssfsi+0x38>
    4498:	d1 f0       	breq	.+52     	; 0x44ce <__fixunssfsi+0x46>
    449a:	66 0f       	add	r22, r22
    449c:	77 1f       	adc	r23, r23
    449e:	88 1f       	adc	r24, r24
    44a0:	99 1f       	adc	r25, r25
    44a2:	1a f0       	brmi	.+6      	; 0x44aa <__fixunssfsi+0x22>
    44a4:	ba 95       	dec	r27
    44a6:	c9 f7       	brne	.-14     	; 0x449a <__fixunssfsi+0x12>
    44a8:	12 c0       	rjmp	.+36     	; 0x44ce <__fixunssfsi+0x46>
    44aa:	b1 30       	cpi	r27, 0x01	; 1
    44ac:	81 f0       	breq	.+32     	; 0x44ce <__fixunssfsi+0x46>
    44ae:	c3 d0       	rcall	.+390    	; 0x4636 <__fp_zero>
    44b0:	b1 e0       	ldi	r27, 0x01	; 1
    44b2:	08 95       	ret
    44b4:	c0 c0       	rjmp	.+384    	; 0x4636 <__fp_zero>
    44b6:	67 2f       	mov	r22, r23
    44b8:	78 2f       	mov	r23, r24
    44ba:	88 27       	eor	r24, r24
    44bc:	b8 5f       	subi	r27, 0xF8	; 248
    44be:	39 f0       	breq	.+14     	; 0x44ce <__fixunssfsi+0x46>
    44c0:	b9 3f       	cpi	r27, 0xF9	; 249
    44c2:	cc f3       	brlt	.-14     	; 0x44b6 <__fixunssfsi+0x2e>
    44c4:	86 95       	lsr	r24
    44c6:	77 95       	ror	r23
    44c8:	67 95       	ror	r22
    44ca:	b3 95       	inc	r27
    44cc:	d9 f7       	brne	.-10     	; 0x44c4 <__fixunssfsi+0x3c>
    44ce:	3e f4       	brtc	.+14     	; 0x44de <__fixunssfsi+0x56>
    44d0:	90 95       	com	r25
    44d2:	80 95       	com	r24
    44d4:	70 95       	com	r23
    44d6:	61 95       	neg	r22
    44d8:	7f 4f       	sbci	r23, 0xFF	; 255
    44da:	8f 4f       	sbci	r24, 0xFF	; 255
    44dc:	9f 4f       	sbci	r25, 0xFF	; 255
    44de:	08 95       	ret

000044e0 <__floatunsisf>:
__floatunsisf():
    44e0:	e8 94       	clt
    44e2:	09 c0       	rjmp	.+18     	; 0x44f6 <__floatsisf+0x12>

000044e4 <__floatsisf>:
    44e4:	97 fb       	bst	r25, 7
    44e6:	3e f4       	brtc	.+14     	; 0x44f6 <__floatsisf+0x12>
    44e8:	90 95       	com	r25
    44ea:	80 95       	com	r24
    44ec:	70 95       	com	r23
    44ee:	61 95       	neg	r22
    44f0:	7f 4f       	sbci	r23, 0xFF	; 255
    44f2:	8f 4f       	sbci	r24, 0xFF	; 255
    44f4:	9f 4f       	sbci	r25, 0xFF	; 255
    44f6:	99 23       	and	r25, r25
    44f8:	a9 f0       	breq	.+42     	; 0x4524 <__floatsisf+0x40>
    44fa:	f9 2f       	mov	r31, r25
    44fc:	96 e9       	ldi	r25, 0x96	; 150
    44fe:	bb 27       	eor	r27, r27
    4500:	93 95       	inc	r25
    4502:	f6 95       	lsr	r31
    4504:	87 95       	ror	r24
    4506:	77 95       	ror	r23
    4508:	67 95       	ror	r22
    450a:	b7 95       	ror	r27
    450c:	f1 11       	cpse	r31, r1
    450e:	f8 cf       	rjmp	.-16     	; 0x4500 <__floatsisf+0x1c>
    4510:	fa f4       	brpl	.+62     	; 0x4550 <__floatsisf+0x6c>
    4512:	bb 0f       	add	r27, r27
    4514:	11 f4       	brne	.+4      	; 0x451a <__floatsisf+0x36>
    4516:	60 ff       	sbrs	r22, 0
    4518:	1b c0       	rjmp	.+54     	; 0x4550 <__floatsisf+0x6c>
    451a:	6f 5f       	subi	r22, 0xFF	; 255
    451c:	7f 4f       	sbci	r23, 0xFF	; 255
    451e:	8f 4f       	sbci	r24, 0xFF	; 255
    4520:	9f 4f       	sbci	r25, 0xFF	; 255
    4522:	16 c0       	rjmp	.+44     	; 0x4550 <__floatsisf+0x6c>
    4524:	88 23       	and	r24, r24
    4526:	11 f0       	breq	.+4      	; 0x452c <__floatsisf+0x48>
    4528:	96 e9       	ldi	r25, 0x96	; 150
    452a:	11 c0       	rjmp	.+34     	; 0x454e <__floatsisf+0x6a>
    452c:	77 23       	and	r23, r23
    452e:	21 f0       	breq	.+8      	; 0x4538 <__floatsisf+0x54>
    4530:	9e e8       	ldi	r25, 0x8E	; 142
    4532:	87 2f       	mov	r24, r23
    4534:	76 2f       	mov	r23, r22
    4536:	05 c0       	rjmp	.+10     	; 0x4542 <__floatsisf+0x5e>
    4538:	66 23       	and	r22, r22
    453a:	71 f0       	breq	.+28     	; 0x4558 <__floatsisf+0x74>
    453c:	96 e8       	ldi	r25, 0x86	; 134
    453e:	86 2f       	mov	r24, r22
    4540:	70 e0       	ldi	r23, 0x00	; 0
    4542:	60 e0       	ldi	r22, 0x00	; 0
    4544:	2a f0       	brmi	.+10     	; 0x4550 <__floatsisf+0x6c>
    4546:	9a 95       	dec	r25
    4548:	66 0f       	add	r22, r22
    454a:	77 1f       	adc	r23, r23
    454c:	88 1f       	adc	r24, r24
    454e:	da f7       	brpl	.-10     	; 0x4546 <__floatsisf+0x62>
    4550:	88 0f       	add	r24, r24
    4552:	96 95       	lsr	r25
    4554:	87 95       	ror	r24
    4556:	97 f9       	bld	r25, 7
    4558:	08 95       	ret

0000455a <__fp_cmp>:
__fp_cmp():
    455a:	99 0f       	add	r25, r25
    455c:	00 08       	sbc	r0, r0
    455e:	55 0f       	add	r21, r21
    4560:	aa 0b       	sbc	r26, r26
    4562:	e0 e8       	ldi	r30, 0x80	; 128
    4564:	fe ef       	ldi	r31, 0xFE	; 254
    4566:	16 16       	cp	r1, r22
    4568:	17 06       	cpc	r1, r23
    456a:	e8 07       	cpc	r30, r24
    456c:	f9 07       	cpc	r31, r25
    456e:	c0 f0       	brcs	.+48     	; 0x45a0 <__fp_cmp+0x46>
    4570:	12 16       	cp	r1, r18
    4572:	13 06       	cpc	r1, r19
    4574:	e4 07       	cpc	r30, r20
    4576:	f5 07       	cpc	r31, r21
    4578:	98 f0       	brcs	.+38     	; 0x45a0 <__fp_cmp+0x46>
    457a:	62 1b       	sub	r22, r18
    457c:	73 0b       	sbc	r23, r19
    457e:	84 0b       	sbc	r24, r20
    4580:	95 0b       	sbc	r25, r21
    4582:	39 f4       	brne	.+14     	; 0x4592 <__fp_cmp+0x38>
    4584:	0a 26       	eor	r0, r26
    4586:	61 f0       	breq	.+24     	; 0x45a0 <__fp_cmp+0x46>
    4588:	23 2b       	or	r18, r19
    458a:	24 2b       	or	r18, r20
    458c:	25 2b       	or	r18, r21
    458e:	21 f4       	brne	.+8      	; 0x4598 <__fp_cmp+0x3e>
    4590:	08 95       	ret
    4592:	0a 26       	eor	r0, r26
    4594:	09 f4       	brne	.+2      	; 0x4598 <__fp_cmp+0x3e>
    4596:	a1 40       	sbci	r26, 0x01	; 1
    4598:	a6 95       	lsr	r26
    459a:	8f ef       	ldi	r24, 0xFF	; 255
    459c:	81 1d       	adc	r24, r1
    459e:	81 1d       	adc	r24, r1
    45a0:	08 95       	ret

000045a2 <__fp_inf>:
__fp_inf():
    45a2:	97 f9       	bld	r25, 7
    45a4:	9f 67       	ori	r25, 0x7F	; 127
    45a6:	80 e8       	ldi	r24, 0x80	; 128
    45a8:	70 e0       	ldi	r23, 0x00	; 0
    45aa:	60 e0       	ldi	r22, 0x00	; 0
    45ac:	08 95       	ret

000045ae <__fp_nan>:
__fp_nan():
    45ae:	9f ef       	ldi	r25, 0xFF	; 255
    45b0:	80 ec       	ldi	r24, 0xC0	; 192
    45b2:	08 95       	ret

000045b4 <__fp_pscA>:
__fp_pscA():
    45b4:	00 24       	eor	r0, r0
    45b6:	0a 94       	dec	r0
    45b8:	16 16       	cp	r1, r22
    45ba:	17 06       	cpc	r1, r23
    45bc:	18 06       	cpc	r1, r24
    45be:	09 06       	cpc	r0, r25
    45c0:	08 95       	ret

000045c2 <__fp_pscB>:
__fp_pscB():
    45c2:	00 24       	eor	r0, r0
    45c4:	0a 94       	dec	r0
    45c6:	12 16       	cp	r1, r18
    45c8:	13 06       	cpc	r1, r19
    45ca:	14 06       	cpc	r1, r20
    45cc:	05 06       	cpc	r0, r21
    45ce:	08 95       	ret

000045d0 <__fp_round>:
__fp_round():
    45d0:	09 2e       	mov	r0, r25
    45d2:	03 94       	inc	r0
    45d4:	00 0c       	add	r0, r0
    45d6:	11 f4       	brne	.+4      	; 0x45dc <__fp_round+0xc>
    45d8:	88 23       	and	r24, r24
    45da:	52 f0       	brmi	.+20     	; 0x45f0 <__fp_round+0x20>
    45dc:	bb 0f       	add	r27, r27
    45de:	40 f4       	brcc	.+16     	; 0x45f0 <__fp_round+0x20>
    45e0:	bf 2b       	or	r27, r31
    45e2:	11 f4       	brne	.+4      	; 0x45e8 <__fp_round+0x18>
    45e4:	60 ff       	sbrs	r22, 0
    45e6:	04 c0       	rjmp	.+8      	; 0x45f0 <__fp_round+0x20>
    45e8:	6f 5f       	subi	r22, 0xFF	; 255
    45ea:	7f 4f       	sbci	r23, 0xFF	; 255
    45ec:	8f 4f       	sbci	r24, 0xFF	; 255
    45ee:	9f 4f       	sbci	r25, 0xFF	; 255
    45f0:	08 95       	ret

000045f2 <__fp_split3>:
__fp_split3():
    45f2:	57 fd       	sbrc	r21, 7
    45f4:	90 58       	subi	r25, 0x80	; 128
    45f6:	44 0f       	add	r20, r20
    45f8:	55 1f       	adc	r21, r21
    45fa:	59 f0       	breq	.+22     	; 0x4612 <__fp_splitA+0x10>
    45fc:	5f 3f       	cpi	r21, 0xFF	; 255
    45fe:	71 f0       	breq	.+28     	; 0x461c <__fp_splitA+0x1a>
    4600:	47 95       	ror	r20

00004602 <__fp_splitA>:
    4602:	88 0f       	add	r24, r24
    4604:	97 fb       	bst	r25, 7
    4606:	99 1f       	adc	r25, r25
    4608:	61 f0       	breq	.+24     	; 0x4622 <__fp_splitA+0x20>
    460a:	9f 3f       	cpi	r25, 0xFF	; 255
    460c:	79 f0       	breq	.+30     	; 0x462c <__fp_splitA+0x2a>
    460e:	87 95       	ror	r24
    4610:	08 95       	ret
    4612:	12 16       	cp	r1, r18
    4614:	13 06       	cpc	r1, r19
    4616:	14 06       	cpc	r1, r20
    4618:	55 1f       	adc	r21, r21
    461a:	f2 cf       	rjmp	.-28     	; 0x4600 <__fp_split3+0xe>
    461c:	46 95       	lsr	r20
    461e:	f1 df       	rcall	.-30     	; 0x4602 <__fp_splitA>
    4620:	08 c0       	rjmp	.+16     	; 0x4632 <__fp_splitA+0x30>
    4622:	16 16       	cp	r1, r22
    4624:	17 06       	cpc	r1, r23
    4626:	18 06       	cpc	r1, r24
    4628:	99 1f       	adc	r25, r25
    462a:	f1 cf       	rjmp	.-30     	; 0x460e <__fp_splitA+0xc>
    462c:	86 95       	lsr	r24
    462e:	71 05       	cpc	r23, r1
    4630:	61 05       	cpc	r22, r1
    4632:	08 94       	sec
    4634:	08 95       	ret

00004636 <__fp_zero>:
__fp_zero():
    4636:	e8 94       	clt

00004638 <__fp_szero>:
    4638:	bb 27       	eor	r27, r27
    463a:	66 27       	eor	r22, r22
    463c:	77 27       	eor	r23, r23
    463e:	cb 01       	movw	r24, r22
    4640:	97 f9       	bld	r25, 7
    4642:	08 95       	ret

00004644 <__gesf2>:
__gesf2():
    4644:	8a df       	rcall	.-236    	; 0x455a <__fp_cmp>
    4646:	08 f4       	brcc	.+2      	; 0x464a <__gesf2+0x6>
    4648:	8f ef       	ldi	r24, 0xFF	; 255
    464a:	08 95       	ret

0000464c <__mulsf3>:
__mulsf3():
    464c:	0b d0       	rcall	.+22     	; 0x4664 <__mulsf3x>
    464e:	c0 cf       	rjmp	.-128    	; 0x45d0 <__fp_round>
    4650:	b1 df       	rcall	.-158    	; 0x45b4 <__fp_pscA>
    4652:	28 f0       	brcs	.+10     	; 0x465e <__mulsf3+0x12>
    4654:	b6 df       	rcall	.-148    	; 0x45c2 <__fp_pscB>
    4656:	18 f0       	brcs	.+6      	; 0x465e <__mulsf3+0x12>
    4658:	95 23       	and	r25, r21
    465a:	09 f0       	breq	.+2      	; 0x465e <__mulsf3+0x12>
    465c:	a2 cf       	rjmp	.-188    	; 0x45a2 <__fp_inf>
    465e:	a7 cf       	rjmp	.-178    	; 0x45ae <__fp_nan>
    4660:	11 24       	eor	r1, r1
    4662:	ea cf       	rjmp	.-44     	; 0x4638 <__fp_szero>

00004664 <__mulsf3x>:
__mulsf3x():
    4664:	c6 df       	rcall	.-116    	; 0x45f2 <__fp_split3>
    4666:	a0 f3       	brcs	.-24     	; 0x4650 <__mulsf3+0x4>

00004668 <__mulsf3_pse>:
    4668:	95 9f       	mul	r25, r21
    466a:	d1 f3       	breq	.-12     	; 0x4660 <__mulsf3+0x14>
    466c:	95 0f       	add	r25, r21
    466e:	50 e0       	ldi	r21, 0x00	; 0
    4670:	55 1f       	adc	r21, r21
    4672:	62 9f       	mul	r22, r18
    4674:	f0 01       	movw	r30, r0
    4676:	72 9f       	mul	r23, r18
    4678:	bb 27       	eor	r27, r27
    467a:	f0 0d       	add	r31, r0
    467c:	b1 1d       	adc	r27, r1
    467e:	63 9f       	mul	r22, r19
    4680:	aa 27       	eor	r26, r26
    4682:	f0 0d       	add	r31, r0
    4684:	b1 1d       	adc	r27, r1
    4686:	aa 1f       	adc	r26, r26
    4688:	64 9f       	mul	r22, r20
    468a:	66 27       	eor	r22, r22
    468c:	b0 0d       	add	r27, r0
    468e:	a1 1d       	adc	r26, r1
    4690:	66 1f       	adc	r22, r22
    4692:	82 9f       	mul	r24, r18
    4694:	22 27       	eor	r18, r18
    4696:	b0 0d       	add	r27, r0
    4698:	a1 1d       	adc	r26, r1
    469a:	62 1f       	adc	r22, r18
    469c:	73 9f       	mul	r23, r19
    469e:	b0 0d       	add	r27, r0
    46a0:	a1 1d       	adc	r26, r1
    46a2:	62 1f       	adc	r22, r18
    46a4:	83 9f       	mul	r24, r19
    46a6:	a0 0d       	add	r26, r0
    46a8:	61 1d       	adc	r22, r1
    46aa:	22 1f       	adc	r18, r18
    46ac:	74 9f       	mul	r23, r20
    46ae:	33 27       	eor	r19, r19
    46b0:	a0 0d       	add	r26, r0
    46b2:	61 1d       	adc	r22, r1
    46b4:	23 1f       	adc	r18, r19
    46b6:	84 9f       	mul	r24, r20
    46b8:	60 0d       	add	r22, r0
    46ba:	21 1d       	adc	r18, r1
    46bc:	82 2f       	mov	r24, r18
    46be:	76 2f       	mov	r23, r22
    46c0:	6a 2f       	mov	r22, r26
    46c2:	11 24       	eor	r1, r1
    46c4:	9f 57       	subi	r25, 0x7F	; 127
    46c6:	50 40       	sbci	r21, 0x00	; 0
    46c8:	8a f0       	brmi	.+34     	; 0x46ec <__mulsf3_pse+0x84>
    46ca:	e1 f0       	breq	.+56     	; 0x4704 <__mulsf3_pse+0x9c>
    46cc:	88 23       	and	r24, r24
    46ce:	4a f0       	brmi	.+18     	; 0x46e2 <__mulsf3_pse+0x7a>
    46d0:	ee 0f       	add	r30, r30
    46d2:	ff 1f       	adc	r31, r31
    46d4:	bb 1f       	adc	r27, r27
    46d6:	66 1f       	adc	r22, r22
    46d8:	77 1f       	adc	r23, r23
    46da:	88 1f       	adc	r24, r24
    46dc:	91 50       	subi	r25, 0x01	; 1
    46de:	50 40       	sbci	r21, 0x00	; 0
    46e0:	a9 f7       	brne	.-22     	; 0x46cc <__mulsf3_pse+0x64>
    46e2:	9e 3f       	cpi	r25, 0xFE	; 254
    46e4:	51 05       	cpc	r21, r1
    46e6:	70 f0       	brcs	.+28     	; 0x4704 <__mulsf3_pse+0x9c>
    46e8:	5c cf       	rjmp	.-328    	; 0x45a2 <__fp_inf>
    46ea:	a6 cf       	rjmp	.-180    	; 0x4638 <__fp_szero>
    46ec:	5f 3f       	cpi	r21, 0xFF	; 255
    46ee:	ec f3       	brlt	.-6      	; 0x46ea <__mulsf3_pse+0x82>
    46f0:	98 3e       	cpi	r25, 0xE8	; 232
    46f2:	dc f3       	brlt	.-10     	; 0x46ea <__mulsf3_pse+0x82>
    46f4:	86 95       	lsr	r24
    46f6:	77 95       	ror	r23
    46f8:	67 95       	ror	r22
    46fa:	b7 95       	ror	r27
    46fc:	f7 95       	ror	r31
    46fe:	e7 95       	ror	r30
    4700:	9f 5f       	subi	r25, 0xFF	; 255
    4702:	c1 f7       	brne	.-16     	; 0x46f4 <__mulsf3_pse+0x8c>
    4704:	fe 2b       	or	r31, r30
    4706:	88 0f       	add	r24, r24
    4708:	91 1d       	adc	r25, r1
    470a:	96 95       	lsr	r25
    470c:	87 95       	ror	r24
    470e:	97 f9       	bld	r25, 7
    4710:	08 95       	ret

00004712 <__unordsf2>:
    4712:	23 df       	rcall	.-442    	; 0x455a <__fp_cmp>
    4714:	88 0b       	sbc	r24, r24
    4716:	99 0b       	sbc	r25, r25
    4718:	08 95       	ret

0000471a <__mulsi3>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    471a:	db 01       	movw	r26, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    471c:	8f 93       	push	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    471e:	9f 93       	push	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    4720:	a1 dd       	rcall	.-1214   	; 0x4264 <__muluhisi3>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    4722:	bf 91       	pop	r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    4724:	af 91       	pop	r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    4726:	a2 9f       	mul	r26, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    4728:	80 0d       	add	r24, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    472a:	91 1d       	adc	r25, r1
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    472c:	a3 9f       	mul	r26, r19
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    472e:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    4730:	b2 9f       	mul	r27, r18
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    4732:	90 0d       	add	r25, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    4734:	11 24       	eor	r1, r1
__mulsi3():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    4736:	08 95       	ret

00004738 <__udivmodhi4>:
__udivmodhi4():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
    4738:	aa 1b       	sub	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
    473a:	bb 1b       	sub	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
    473c:	51 e1       	ldi	r21, 0x11	; 17
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
    473e:	07 c0       	rjmp	.+14     	; 0x474e <__udivmodhi4_ep>

00004740 <__udivmodhi4_loop>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
    4740:	aa 1f       	adc	r26, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
    4742:	bb 1f       	adc	r27, r27
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
    4744:	a6 17       	cp	r26, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
    4746:	b7 07       	cpc	r27, r23
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
    4748:	10 f0       	brcs	.+4      	; 0x474e <__udivmodhi4_ep>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
    474a:	a6 1b       	sub	r26, r22
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
    474c:	b7 0b       	sbc	r27, r23

0000474e <__udivmodhi4_ep>:
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
    474e:	88 1f       	adc	r24, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
    4750:	99 1f       	adc	r25, r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
    4752:	5a 95       	dec	r21
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
    4754:	a9 f7       	brne	.-22     	; 0x4740 <__udivmodhi4_loop>
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
    4756:	80 95       	com	r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
    4758:	90 95       	com	r25
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
    475a:	bc 01       	movw	r22, r24
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
    475c:	cd 01       	movw	r24, r26
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
    475e:	08 95       	ret

00004760 <__tablejump2__>:
__tablejump2__():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    4760:	ee 0f       	add	r30, r30
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    4762:	ff 1f       	adc	r31, r31
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2304
    4764:	00 24       	eor	r0, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2305
    4766:	00 1c       	adc	r0, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2306
    4768:	0b be       	out	0x3b, r0	; 59
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2312
    476a:	07 90       	elpm	r0, Z+
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2313
    476c:	f6 91       	elpm	r31, Z
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2314
    476e:	e0 2d       	mov	r30, r0
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2319
    4770:	09 94       	ijmp

00004772 <abort>:
abort():
    4772:	81 e0       	ldi	r24, 0x01	; 1
    4774:	90 e0       	ldi	r25, 0x00	; 0
    4776:	f8 94       	cli
    4778:	00 c0       	rjmp	.+0      	; 0x477a <_exit>

0000477a <_exit>:
exit():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    477a:	f8 94       	cli

0000477c <__stop_program>:
__stop_program():
/home/admin/build/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    477c:	ff cf       	rjmp	.-2      	; 0x477c <__stop_program>
